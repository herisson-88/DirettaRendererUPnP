diff --git a/.claude/settings.json b/.claude/settings.json
deleted file mode 100644
index 9607bc7..0000000
--- a/.claude/settings.json
+++ /dev/null
@@ -1,4 +0,0 @@
-{
-  "$schema": "https://claude.ai/claude-code/settings.schema.json",
-  "projectInstructions": "See CLAUDE.md at project root (symlinked to docs/CLAUDE.md)"
-}
diff --git a/.gitignore b/.gitignore
deleted file mode 100644
index 15f64ce..0000000
--- a/.gitignore
+++ /dev/null
@@ -1,20 +0,0 @@
-# Build artifacts
-obj/
-bin/
-*.o
-*.d
-
-# FFmpeg headers (downloaded for ABI compatibility)
-ffmpeg-headers/
-.ffmpeg-version
-
-# IDE and editor files
-.vscode/
-.idea/
-*.swp
-*.swo
-*~
-
-# OS files
-.DS_Store
-Thumbs.db
diff --git a/CHANGELOG.md b/CHANGELOG.md
deleted file mode 100644
index d631660..0000000
--- a/CHANGELOG.md
+++ /dev/null
@@ -1,838 +0,0 @@
-# Changelog
-
-## 2026-01-18 (Session 4) - EXPERIMENTAL: User Interaction Full Reopen
-
-### Experimental Feature
-
-**Purpose:** Test a more conservative track transition approach.
-
-**Previous behavior:**
-- Quick path: Same format (regardless of how track change occurred)
-- Full reopen: Format change detected
-
-**New behavior (EXPERIMENTAL):**
-- Quick path: ONLY for sequential/gapless playback (SetNextAVTransportURI → natural track end)
-- Full reopen: ANY user interaction (SetAVTransportURI while playing) OR format change
-
-**Rationale:** User-initiated track changes are natural "break points" where a clean reset is acceptable. Gapless sequential playback should remain fast when formats match.
-
-**Files changed:**
-- `src/DirettaSync.h` - Added `setForceFullReopen()` method and `m_forceFullReopen` flag
-- `src/DirettaSync.cpp` - Check flag in `open()`, trigger `reopenForFormatChange()` if set
-- `src/DirettaRenderer.cpp` - Set flag in `onSetURI` callback before stopping playback
-
-**To revert:** Search for "EXPERIMENTAL:" comments and remove the related code blocks.
-
----
-
-## 2026-01-17 (Session 3) - Format Change Gapless Fix
-
-### Bug Fix
-
-**Fixed:** Track changes with format/sample rate changes now auto-resume correctly.
-
-**Root cause:** During gapless playback with format changes (e.g., DSD→PCM, 44.1kHz→96kHz), the `trackEndCallback` was incorrectly being called. This callback is designed for **playlist end** and calls `m_direttaSync->release()`, which fully disconnects from the Diretta target and sets transport state to STOPPED.
-
-**Symptom:** After a track ended and the next track had a different format, playback would stop and require manual Play command to continue.
-
-**Fix:** Removed the `trackEndCallback()` call from the format change transition path in `AudioEngine::process()`. The format change path now correctly keeps the Diretta connection alive and lets `DirettaSync::open()` handle the format transition.
-
-**File changed:** `src/AudioEngine.cpp` (lines 1554-1557)
-
----
-
-## 2026-01-17 (Session 2) - Timing Variance Optimization
-
-Systematic optimization pass focused on reducing timing variance in the audio hot path. Based on the principle that consistent timing matters more than average-case speed for audio quality.
-
-**Full technical details:** [docs/Timing_Variance_Optimization_Report.md](docs/Timing_Variance_Optimization_Report.md)
-
-### Phase 1: Quick Wins
-
-| ID | Change | Impact |
-|----|--------|--------|
-| **N3** | Consolidated bit reversal LUT | Single 256-byte table shared between AudioEngine and DirettaRingBuffer |
-| **S4** | Retry constants namespace | `DirettaRetry::` constants replace magic numbers |
-| **S5** | DSD diagnostics compile flag | Build with `make DSD_DIAG=1` when needed |
-
-### Phase 2: Moderate Effort
-
-| ID | Change | Impact |
-|----|--------|--------|
-| **R1+R2** | Format generation counter | 1 atomic load vs 5-6 per sendAudio() call (~200-300ns saved) |
-
-### Phase 3: Significant Effort
-
-| ID | Change | Impact |
-|----|--------|--------|
-| **N1** | Direct write API | Zero-copy fast path for contiguous ring buffer regions |
-| **N4** | SIMD memcpy assessment | Current AVX2 implementation deemed optimal |
-
-### New APIs
-
-**DirettaRingBuffer:**
-- `getDirectWriteRegion(size_t needed, uint8_t*& region, size_t& available)` - Get direct write pointer
-- `commitDirectWrite(size_t written)` - Commit direct write
-- `getStagingForConversion(int type)` - Get staging buffer by type
-- `getStagingBufferSize()` - Staging buffer size constant
-
-**DirettaRetry namespace:**
-- `OPEN_RETRIES`, `OPEN_DELAY_MS` - Connection establishment
-- `SETSINK_RETRIES_FULL/QUICK`, `SETSINK_DELAY_FULL/QUICK_MS` - Sink configuration
-- `CONNECT_RETRIES`, `CONNECT_DELAY_MS` - Connect sequence
-- `REOPEN_SINK_RETRIES`, `REOPEN_SINK_DELAY_MS` - Format change reopen
-
-### Build Options
-
-```bash
-make              # Normal build
-make DSD_DIAG=1   # Enable DSD diagnostic output
-```
-
-### Files Modified
-
-- `src/AudioEngine.cpp` - LUT consolidation, DSD diagnostics conditional
-- `src/DirettaSync.h` - Retry namespace, generation counter, cached format values
-- `src/DirettaSync.cpp` - Use retry constants, generation counter pattern
-- `src/DirettaRingBuffer.h` - Direct write API, optimized push()
-- `Makefile` - DSD_DIAG option
-
----
-
-## 2026-01-17 - Hot Path Simplification
-
-Systematic code simplification focused on reducing timing variance in the audio callback hot path. The goal is improved audio quality through more predictable code execution.
-
-**Full technical details:** [docs/Hot Path Simplification Report.md](docs/Hot%20Path%20Simplification%20Report.md)
-
-### Critical Changes (Hot Path)
-
-| ID | Change | Impact |
-|----|--------|--------|
-| **C0** | Lock-free callback synchronization | Eliminates syscalls from hot path |
-| **C1** | Bitmask ring buffer wrap (`& mask_`) | Constant-time position calculation |
-| **C4** | Unified memcpy path | Consistent timing, no branch |
-| **C6** | Silent underrun counting | No blocking I/O in hot path |
-| **C7** | Single bit-reversal LUT | Better cache locality |
-
-### Secondary Changes (Track Initialization)
-
-| ID | Change | Impact |
-|----|--------|--------|
-| **S1** | Dead code removal | ~75 lines removed |
-| **S2** | Legacy DSD path removal | Zero per-iteration branches |
-
-### Summary
-
-- ~200 lines of code removed
-- Zero syscalls in audio callback
-- Eliminated per-iteration branches in DSD conversion
-- Improved cache locality for DSD operations
-
-### Files Modified
-
-- `src/DirettaRingBuffer.h` - Ring buffer optimizations, LUT consolidation, legacy DSD removal
-- `src/DirettaSync.cpp` - Underrun handling, dead code removal, removed unused LUT
-- `src/DirettaSync.h` - Added underrun counter atomic
-- `src/DirettaRenderer.cpp` - Lock-free callback synchronization
-- `src/DirettaRenderer.h` - Atomic members for callback sync
-
----
-
-## 2026-01-16
-
-### FFmpeg 8.0.1 Minimal Build Option
-
-Added FFmpeg 8.0.1 as the new recommended build option in `install.sh` with a minimal audio-only configuration.
-
-**New option 3 (default):** Build FFmpeg 8.0.1 minimal
-- Smallest footprint with `--disable-everything` base
-- Installs to `/usr` (system-wide) vs `/usr/local`
-- Only essential audio components enabled
-
-**Configuration:**
-```
---prefix=/usr
---enable-shared
---disable-static
---enable-small
---enable-gpl
---enable-version3
---enable-gnutls
---disable-everything
---disable-doc
---disable-avdevice
---disable-swscale
---enable-protocol=file,http,https,tcp
---enable-demuxer=flac,wav,dsf,dff,aac,mov
---enable-decoder=flac,alac,pcm_s16le,pcm_s24le,pcm_s32le,dsd_lsbf,dsd_msbf,dsd_lsbf_planar,dsd_msbf_planar,aac
---enable-muxer=flac,wav
---enable-filter=aresample
-```
-
-**Supported formats:**
-| Format | Container | Decoder |
-|--------|-----------|---------|
-| FLAC | flac | flac |
-| WAV | wav | pcm_s16le/s24le/s32le |
-| ALAC | mov | alac |
-| AAC/M4A | mov | aac |
-| DSF (DSD) | dsf | dsd_lsbf, dsd_lsbf_planar |
-| DFF (DSD) | dff | dsd_msbf, dsd_msbf_planar |
-
-**Changes to install.sh:**
-- Added `get_ffmpeg_8_minimal_opts()` function
-- Added `build_ffmpeg_8_minimal()` function
-- Added `install_ffmpeg_8_build_deps()` (minimal: gnutls only)
-- Updated ABI compatibility mapping for FFmpeg 8 (libavformat 62)
-- Renumbered menu options (8.0.1 is now option 3, default)
-- Removed `--disable-postproc` (not valid in FFmpeg 8.x)
-
-**Files:** `install.sh`
-
----
-
-## 2026-01-15 (Session 3) - TEST BUILD
-
-### Format Transition Noise Investigation
-
-**Purpose:** Test build to diagnose switching noise during format transitions. Pre-transition silence buffers were suspected of contributing to the noise rather than preventing it.
-
-**Changes:**
-
-| Setting | Original | Test Value |
-|---------|----------|------------|
-| Pre-transition silence | Enabled (100-1000 buffers) | **Disabled** |
-| DSD→PCM delay | 800ms | **400ms** |
-| DSD rate change delay | 400ms | 400ms (unchanged) |
-| PCM rate change delay | 200ms | **100ms** |
-
-**Files modified:**
-- `src/DirettaSync.cpp`:
-  - `sendPreTransitionSilence()` (line 1140-1142) - Early return added
-  - `reopenForFormatChange()` (line 730-758) - Silence wrapped in `#if 0`
-  - DSD→PCM delay (line 459) - Reduced from 800 to 400
-  - PCM rate change delay (line 506) - Reduced from 200 to 100
-
-**To revert:**
-1. Remove early `return` in `sendPreTransitionSilence()`
-2. Change `#if 0` to `#if 1` in `reopenForFormatChange()`
-3. Restore delay values: DSD→PCM=800, PCM rate=200
-
----
-
-## 2026-01-15 (Session 2)
-
-### PCM FIFO and Bypass Optimization (thanks to @leeeanh)
-
-Four interconnected optimizations to the PCM audio path, adapted from the leeeanh fork optimization designs with preservation of existing bug fixes.
-
-#### 1. Enhanced S24 Detection
-
-**Problem:** Original S24 detection failed when 24-bit tracks start with silence.
-
-**Solution:** Hybrid detection with three layers:
-
-- Sample-based detection (checks both LSB and MSB byte positions)
-- Hint from FFmpeg metadata (fallback for silence)
-- Timeout mechanism (~1 second defaults to LSB)
-
-**Files:**
-
-- `src/DirettaRingBuffer.h` - Added `S24PackMode::Deferred`, hint mechanism, timeout
-- `src/DirettaSync.h` - Added `setS24PackModeHint()` method
-
-#### 2. AVAudioFifo for PCM Overflow
-
-**Problem:** Original overflow handling used `memmove()` with O(n) complexity.
-
-**Solution:** Replaced with FFmpeg's `AVAudioFifo`:
-
-- O(1) circular buffer operations
-- Dynamic sizing based on sample rate (8192 @ 48kHz → 64k+ @ high rates)
-- Separate DSD remainder buffer (`m_dsdPacketRemainder`) from PCM FIFO
-
-| Sample Rate | FIFO Size      |
-| ----------- | -------------- |
-| 48 kHz      | 8,192 samples  |
-| 96 kHz      | 16,384 samples |
-| 192 kHz     | 32,768 samples |
-| 384 kHz     | 65,536 samples |
-
-**Files:**
-
-- `src/AudioEngine.h` - Added `AVAudioFifo* m_pcmFifo`, separated DSD buffer
-- `src/AudioEngine.cpp` - FIFO allocation in `initResampler()`, usage in `readSamples()`
-
-#### 3. PCM Bypass Mode
-
-**Problem:** Audio processed through SwrContext even when formats match exactly.
-
-**Solution:** Bypass mode that skips SwrContext for bit-perfect playback when:
-
-- Sample rates match exactly
-- Channel counts match
-- Format is packed integer (S16 or S32) - NOT planar, NOT float
-- Bit depth matches
-
-**Files:**
-
-- `src/AudioEngine.h` - Added `m_bypassMode`, `canBypass()` method
-- `src/AudioEngine.cpp` - Bypass check in `initResampler()`, explicit bypass path in `readSamples()`
-
-**Expected log output:** `[AudioDecoder] PCM BYPASS enabled - bit-perfect path`
-
-#### 4. S24 Hint Propagation
-
-**Problem:** S24 alignment hint from FFmpeg wasn't reaching the ring buffer.
-
-**Solution:** Propagation path: `TrackInfo` → `DirettaRenderer` → `DirettaSync` → `DirettaRingBuffer`
-
-**Files:**
-
-- `src/AudioEngine.h` - Added `TrackInfo::S24Alignment` enum
-- `src/AudioEngine.cpp` - Detection based on codec ID (PCM_S24, FLAC, ALAC)
-- `src/DirettaRenderer.cpp` - Propagation to `m_direttaSync->setS24PackModeHint()`
-
----
-
-**Documentation:**
-
-- Summary: [`docs/PCM_FIFO_BYPASS_OPTIMIZATION.md`](docs/PCM_FIFO_BYPASS_OPTIMIZATION.md)
-- Design: [`docs/plans/2026-01-15-pcm-bypass-optimization-design.md`](docs/plans/2026-01-15-pcm-bypass-optimization-design.md)
-
-**Preserved bug fixes:** FFmpeg ABI compatibility, ARM64 compilation, DSD transition silence, DSD per-channel buffers, DSD512 Zen3 warmup.
-
-### DSD Conversion Function Specialization
-
-**Problem:** Per-iteration branch checks inside the DSD conversion hot loop for operations that are constant per-track. At DSD512 (22.5 MHz), this added ~176,000 unnecessary branch predictions per second.
-
-**Root cause:** `convertDSDPlanar_AVX2()` checked `if (bitReversalTable)` and `if (needByteSwap)` on every 32-byte chunk, even though these values never change during playback.
-
-**Solution:** Pre-select specialized conversion function at track open time:
-
-| Mode | Description | Use Case |
-|------|-------------|----------|
-| `Passthrough` | Just interleave (fastest) | DSF→LSB target, DFF→MSB target |
-| `BitReverseOnly` | Apply bit reversal | DSF→MSB target, DFF→LSB target |
-| `ByteSwapOnly` | Endianness conversion | Little-endian targets |
-| `BitReverseAndSwap` | Both operations | Little-endian + bit order mismatch |
-
-**Implementation:**
-- Added `DSDConversionMode` enum to `DirettaRingBuffer.h`
-- Created 4 specialized conversion functions (each ~350 lines with AVX2 + scalar fallback):
-  - `convertDSD_Passthrough()` - Zero transformation overhead
-  - `convertDSD_BitReverse()` - Embedded LUT, no null check
-  - `convertDSD_ByteSwap()` - Byte reordering only
-  - `convertDSD_BitReverseSwap()` - Combined operations
-- Added `pushDSDPlanarOptimized()` with switch-case dispatch
-- `configureSinkDSD()` now sets `m_dsdConversionMode` based on source format + sink requirements
-- `sendAudio()` uses optimized path with cached mode
-
-**Files:**
-- `src/DirettaRingBuffer.h` (lines 104-110, 326-364, 557-896)
-- `src/DirettaSync.h` (line 389) - Added `m_dsdConversionMode` member
-- `src/DirettaSync.cpp` (lines 904-975, 1215-1217) - Mode selection and usage
-
-**Documentation:**
-- Summary: [`docs/DSD_CONVERSION_OPTIMIZATION.md`](docs/DSD_CONVERSION_OPTIMIZATION.md)
-- Design: [`docs/plans/2026-01-15-dsd-conversion-optimization-design.md`](docs/plans/2026-01-15-dsd-conversion-optimization-design.md)
-
----
-
-### PCM Sample Rate Transition Noise Fix
-
-**Problem:** Transition noise when changing sample rates in PCM (e.g., 44.1kHz → 96kHz).
-
-**Root cause:** PCM rate changes used `reopenForFormatChange()` which tries to send silence buffers, but playback is already stopped when the new track arrives, so silence never gets sent. Target's internal buffers still contain old samples at the previous rate.
-
-**Solution:** PCM rate changes now use the same full close/reopen approach as DSD transitions:
-
-| Transition | Action | Delay |
-|------------|--------|-------|
-| PCM rate change | Full close/reopen | 200ms |
-| DSD→PCM | Full close/reopen | 800ms |
-| DSD rate change | Full close/reopen | 400ms |
-| PCM→DSD | reopenForFormatChange() | 800ms |
-
-**Files:**
-- `src/DirettaSync.cpp` (lines 476-522) - Added `isPcmRateChange` detection and full close/reopen path
-
----
-
-### FLAC Bypass Bug Fix
-
-**Problem:** FLAC files played at twice the normal speed.
-
-**Root cause:** `canBypass()` returned `true` for FLAC because the codec context sample format check passed. However, FLAC always decodes to planar format (`FLTP`/`S32P`), which requires conversion through SwrContext.
-
-**Solution:** Added explicit check for compressed formats at the start of `canBypass()`:
-
-```cpp
-if (m_trackInfo.isCompressed) {
-    DEBUG_LOG("[AudioDecoder] canBypass: NO (compressed format requires decoding)");
-    return false;
-}
-```
-
-**Files:**
-- `src/AudioEngine.cpp` (lines 295-299) - Added `isCompressed` check in `canBypass()`
-
----
-
-## 2026-01-15
-
-### FFmpeg ABI Compatibility Fix
-
-**Problem:** Segmentation fault when running against FFmpeg 5.x libraries after compiling on a system with FFmpeg 7.x development headers. Crash occurred in `AudioDecoder::open()` when accessing `AVStream->codecpar`.
-
-**Root cause:**
-- Compile-time FFmpeg headers (libavformat 61.x from FFmpeg 7.x) have different `AVStream` structure layout than runtime libraries (libavformat 59.x from FFmpeg 5.x)
-- The `codecpar` field offset differs between versions, causing garbage pointer dereference
-- Debug output showed: `codecpar=0x5622000000001` (garbage) instead of valid pointer
-
-**Solution - Multi-layered approach:**
-
-1. **AudioEngine.cpp** - Safer stream detection:
-   - Replaced manual stream iteration loop with `av_find_best_stream()` (FFmpeg's recommended API)
-   - Added NULL checks for `audioStream` and `audioStream->codecpar` after retrieval
-   - Handles edge cases in FFmpeg 5.x where codecpar may be invalid
-
-2. **install.sh** - Automatic header management:
-   - Added `download_ffmpeg_headers()` - downloads FFmpeg source for headers only
-   - Added `check_ffmpeg_abi_compatibility()` - detects runtime vs compile-time version mismatch
-   - Added `ensure_ffmpeg_headers()` - auto-downloads correct headers when needed
-   - Added `detect_ffmpeg_runtime_version()` and `get_ffmpeg_target_version()` for auto-detection
-   - `build_renderer()` now automatically uses `make FFMPEG_PATH=./ffmpeg-headers`
-   - FFmpeg installation now offers both **5.1.2** and **7.1** (recommended) build options
-   - Selected version saved to `.ffmpeg-version` for future builds
-   - New config variables: `FFMPEG_HEADERS_DIR`, `FFMPEG_TARGET_VERSION`
-
-3. **Makefile** - Auto-detection and warnings:
-   - Auto-detects `./ffmpeg-headers/` directory (created by install.sh)
-   - Shows clear warning box when using system headers
-   - Supports explicit override: `make FFMPEG_PATH=/path/to/headers`
-
-4. **New .gitignore** - Excludes downloaded headers from version control
-
-**Usage:**
-```bash
-# Option A: Use install.sh (recommended - auto-downloads headers)
-./install.sh --build
-
-# Option B: Manual download
-wget https://ffmpeg.org/releases/ffmpeg-5.1.2.tar.xz
-tar xf ffmpeg-5.1.2.tar.xz
-mv ffmpeg-5.1.2 ffmpeg-headers
-make clean && make
-
-# Option C: Explicit path
-make clean && make FFMPEG_PATH=/path/to/ffmpeg-5.1.2
-```
-
-**Files:**
-- `src/AudioEngine.cpp` (lines 139-171) - Stream detection rewrite
-- `install.sh` (lines 512-656) - Header download functions
-- `install.sh` (lines 721-734) - Build with correct headers
-- `Makefile` (lines 181-229) - FFmpeg path auto-detection
-- `.gitignore` - New file
-
----
-
-### ARM64 Compilation Fix
-
-**Problem:** Build failed on ARM64 (aarch64) with `fatal error: immintrin.h: No such file or directory`. The `immintrin.h` header is x86-only (AVX/SSE intrinsics) and doesn't exist on ARM64 systems.
-
-**Solution:** Added architecture detection and conditional compilation throughout `DirettaRingBuffer.h`:
-
-1. **Architecture detection macro:**
-   ```cpp
-   #if defined(__x86_64__) || defined(_M_X64) || defined(__i386__) || defined(_M_IX86)
-       #define DIRETTA_HAS_AVX2 1
-       #include <immintrin.h>
-   #else
-       #define DIRETTA_HAS_AVX2 0
-   #endif
-   ```
-
-2. **Conditional AVX2 functions:**
-   - `convert24BitPacked_AVX2()` - x86 AVX2 with scalar fallback
-   - `convert24BitPackedShifted_AVX2()` - x86 AVX2 with scalar fallback
-   - `convert16To32_AVX2()` - x86 AVX2 with scalar fallback
-   - `convertDSDPlanar_AVX2()` - x86 AVX2 with scalar fallback (uses `convertDSDPlanar_Scalar()`)
-   - `simd_bit_reverse()` - x86-only helper (guarded)
-
-3. **Scalar fallbacks for ARM64:**
-   - Pure C++ implementations for all conversion functions
-   - Uses existing `convertDSDPlanar_Scalar()` for DSD processing
-   - `memcpyfast_audio.h` already had ARM64 support (uses `std::memcpy`)
-
-**Performance note:** ARM64 builds use scalar code paths which are still efficient due to:
-- GCC/Clang NEON auto-vectorization for simple loops
-- Standard library optimizations in `std::memcpy`
-
-**Files:**
-- `src/DirettaRingBuffer.h` - Architecture guards and scalar fallbacks
-
----
-
-### Pre-Transition Silence for DSD Format Changes
-
-**Problem:** Crackling noise when switching DSD rates or transitioning DSD→PCM, despite previous fixes (full close/reopen with delays). The issue reappeared after Zen3 stabilization buffer changes.
-
-**Root cause analysis:**
-- When `onSetURI` receives a new track, it calls `stopPlayback(true)` (immediate)
-- With `immediate=true`, NO silence buffers are sent before stopping
-- The Diretta target's internal buffers still contain old DSD audio
-- Comment in code acknowledged this: "We can't send silence here because playback is already stopped"
-- The Zen3 stabilization change (longer post-online warmup) gave more time for residual audio artifacts to manifest
-
-**Solution:** Added `sendPreTransitionSilence()` method that sends rate-scaled silence BEFORE calling `stopPlayback()`:
-
-| DSD Rate | Silence Buffers | Rationale |
-|----------|-----------------|-----------|
-| DSD64    | 100             | Base level |
-| DSD128   | 200             | 2× data rate |
-| DSD256   | 400             | 4× data rate |
-| DSD512   | 800             | 8× data rate |
-| PCM      | 30              | Lower throughput |
-
-**Implementation:**
-- New public method `DirettaSync::sendPreTransitionSilence()`
-- Calculates silence buffers based on current DSD rate: `100 × (sampleRate / 2822400)`
-- Waits for silence to be consumed by `getNewStream()` (timeout scales with buffer count)
-- Called in two locations:
-  1. `onSetURI` callback before `stopPlayback()` (normal track change)
-  2. Audio callback format change detection (gapless transitions)
-
-**Transition flow after fix:**
-```
-1. onSetURI receives new track
-2. m_audioEngine->stop()
-3. waitForCallbackComplete()
-4. sendPreTransitionSilence()  ← NEW: Flushes Diretta pipeline
-5. stopPlayback(true)
-6. [New format open() proceeds with clean target state]
-```
-
-**Files:**
-- `src/DirettaSync.h` (lines 244-251) - Method declaration
-- `src/DirettaSync.cpp` (lines 1058-1103) - Implementation
-- `src/DirettaRenderer.cpp` (lines 366-368, 226-228) - Call sites
-
-**Status:** Significantly improved. If crackling persists in edge cases, consider:
-- Increasing silence buffer multiplier
-- Adjusting timeout scaling
-- Adding post-silence delay before `stopPlayback()`
-
-
-
----
-
-## 2026-01-14
-
-### 1. DSD Buffer Optimization - Pre-allocated Buffers
-
-- Eliminated per-call heap allocations in DSD hot path
-- Replaced `std::vector<uint8_t>` with pre-allocated `AudioBuffer` members
-- Added `m_dsdLeftBuffer`, `m_dsdRightBuffer`, `m_dsdBufferCapacity` to `AudioDecoder`
-- All `.insert()` operations replaced with `memcpy()` + offset tracking
-- Buffers only resize when capacity is insufficient (rare, typically once per session)
-- **Files:** `src/AudioEngine.h` (lines 141-144), `src/AudioEngine.cpp` (lines 552-661, 534)
-
-### 2. DSD Rate-Adaptive Chunk Sizing
-
-- Added `DirettaBuffer::calculateDsdSamplesPerCall()` function
-- DSD chunks now scale with sample rate to maintain ~12ms granularity
-- Previously fixed at 32768 samples regardless of DSD rate
-- Significantly reduces loop iterations for high-rate DSD (DSD256+)
-- **Files:** `src/DirettaSync.h` (lines 109-132), `src/DirettaRenderer.cpp` (lines 567-575)
-
-### Performance Impact
-
-| DSD Rate | Before (fixed 32768) | After (rate-adaptive) | Improvement |
-|----------|----------------------|-----------------------|-------------|
-| DSD64    | ~11.6ms/chunk        | ~12.1ms/chunk         | Similar |
-| DSD128   | ~5.8ms/chunk         | ~12.0ms/chunk         | 2x fewer iterations |
-| DSD256   | ~2.9ms/chunk         | ~11.6ms/chunk         | 4x fewer iterations |
-| DSD512   | ~1.45ms/chunk        | ~5.8ms/chunk          | 4x fewer iterations |
-| DSD1024  | ~0.7ms/chunk         | ~2.9ms/chunk          | 4x fewer iterations |
-
-| Metric | Before | After |
-|--------|--------|-------|
-| Heap allocations per DSD read | 2 (std::vector) | 0 (steady state) |
-| Memory pattern | Alloc/free every call | Pre-allocated, reused |
-
-### 3. DSD512 Startup Fix for Zen3 CPUs (MTU-Aware)
-
-- Scaled post-online stabilization to achieve consistent **warmup TIME** regardless of MTU
-- Fixes harsh sound at DSD512 startup on AMD Zen3 systems (works fine on Zen4)
-- Root cause: Zen3's slower memory controller and different cache hierarchy need more warmup time at high data throughput
-- Additional issue: With small MTU (1500), `getNewStream()` is called more frequently (shorter cycle time), so a fixed buffer count resulted in insufficient warmup time
-
-**Target warmup time by DSD rate:**
-
-| DSD Rate | Target Warmup |
-|----------|---------------|
-| DSD64    | 50ms          |
-| DSD128   | 100ms         |
-| DSD256   | 200ms         |
-| DSD512   | 400ms         |
-
-**Buffer count scales with MTU to achieve target time:**
-
-| MTU | Cycle Time (DSD512) | Buffers for 400ms |
-|-----|---------------------|-------------------|
-| 1500 | 261 μs | ~1530 buffers |
-| 9000 | 1,590 μs | ~252 buffers |
-| 16128 | 2,853 μs | ~140 buffers |
-
-**Formula:**
-```
-targetWarmupMs = 50ms × dsdMultiplier
-cycleTimeUs = (MTU - 24) / bytesPerSecond × 1,000,000
-buffersNeeded = targetWarmupMs × 1000 / cycleTimeUs
-```
-
-- **Files:** `src/DirettaSync.cpp` (lines 1201-1239)
-
-### 4. DSD Rate Change Transition Noise Fix
-
-- **All DSD rate changes** now use full close/reopen (not just downgrades)
-- Includes clock domain changes: DSD512×44.1kHz ↔ DSD512×48kHz
-- Previously used `reopenForFormatChange()` which tries to send silence buffers
-- Problem: When user selects new track, playback stops before transition, so `getNewStream()` isn't called and silence buffers never get sent to target
-- Target's internal buffers still contain old DSD data → causes noise on new format
-- Solution: Same aggressive approach as DSD→PCM (full `DIRETTA::Sync::close()` + delay + fresh `open()`)
-
-| Transition | Action | Delay |
-|------------|--------|-------|
-| DSD→PCM | Full close/reopen | 800ms |
-| DSD→DSD (any rate change) | Full close/reopen | 400ms |
-| PCM→DSD | reopenForFormatChange() | 800ms |
-| PCM→PCM (rate change) | reopenForFormatChange() | 800ms |
-
-- **Files:** `src/DirettaSync.cpp` (lines 401-482)
-
-### 5. Install Script Restructuring
-
-Complete rewrite of `install.sh` with modular architecture and improved FFmpeg handling.
-
-**Structural improvements:**
-- Modular function-based architecture with clear section headers
-- CLI argument support: `--full`, `--deps`, `--build`, `--configure`, `--optimize`, `--help`
-- Interactive menu system with numbered options
-- `confirm()` helper for consistent yes/no prompts
-
-**FFmpeg changes:**
-- Removed FFmpeg 5.1.2 and 6.1.1 (both have DSD segfault issues with GCC 14+)
-- FFmpeg 7.1 is now the only source build option
-- Build flags: `--enable-lto` for link-time optimization
-- Added `mjpeg` and `png` decoders for embedded album art in DSF/DFF files
-- Options: Build from source (recommended), RPM Fusion (Fedora), System packages
-
-**Network buffer optimization:**
-- Added sysctl settings for high-resolution audio streaming:
-  - `net.core.rmem_max=16777216` (16MB receive buffer)
-  - `net.core.wmem_max=16777216` (16MB send buffer)
-- Available in both normal network config and aggressive optimization
-- Persistent via `/etc/sysctl.d/99-diretta.conf`
-
-**Fedora aggressive optimization (option 5):**
-- Integrated from `optimize_fedora_server.sh`
-- Removes: firewalld, SELinux, polkit, gssproxy
-- Disables: journald, oomd, homed, auditd
-- Replaces sshd with dropbear (lightweight SSH)
-- Double confirmation required (safety)
-- Intended for dedicated audio servers only
-
-- **Files:** `install.sh`
-
-### 6. CPU Isolation and Thread Distribution Tuner Scripts
-
-Added two tuner scripts for CPU core isolation and real-time scheduling optimization.
-
-**Common features (both scripts):**
-- CPU isolation via kernel parameters (`isolcpus`, `nohz_full`, `rcu_nocbs`)
-- Systemd slice for CPU pinning
-- Real-time FIFO scheduling (priority 90)
-- IRQ affinity to housekeeping cores
-- CPU governor set to performance
-- Automatic thread distribution across cores (via `ExecStartPost`)
-- Manual `redistribute` command for testing without service restart
-
-**Option 1: `diretta-renderer-tuner.sh` (SMT enabled)**
-
-For systems where SMT (Hyper-Threading) is acceptable:
-- Housekeeping: cores 0,8 (1 physical core + SMT sibling)
-- Renderer: cores 1-7,9-15 (14 logical CPUs)
-- 11 threads distributed across 14 CPUs (~1 thread per CPU)
-
-**Option 2: `diretta-renderer-tuner-nosmt.sh` (SMT disabled)**
-
-For dedicated audio servers with low system load:
-- Adds `nosmt` kernel parameter to disable Hyper-Threading
-- Housekeeping: core 0 (1 physical core)
-- Renderer: cores 1-7 (7 physical cores)
-- 11 threads distributed across 7 cores (~1.5 threads per core)
-
-**Recommendation:**
-- For dedicated low-load audio servers: **no-SMT** provides more predictable latency
-- For multi-purpose systems: **SMT** provides more parallelism
-
-**Usage:**
-```bash
-# Apply configuration (requires reboot for kernel params)
-sudo ./diretta-renderer-tuner.sh apply
-
-# Test thread distribution immediately (no reboot)
-sudo ./diretta-renderer-tuner.sh redistribute
-
-# Check current status and thread layout
-sudo ./diretta-renderer-tuner.sh status
-
-# Revert all changes
-sudo ./diretta-renderer-tuner.sh revert
-```
-
-- **Files:** `diretta-renderer-tuner.sh`, `diretta-renderer-tuner-nosmt.sh`
-
----
-
-## 2026-01-13
-
-### 1. Full Integration of @leeeanh Optimizations
-
-- Integrated all ring buffer optimizations from @leeeanh
-- Power-of-2 bitmask modulo for single-cycle operations
-- Cache-line separation to eliminate false sharing
-- Lock-free audio path with atomic operations
-- **Files:** `src/DirettaRingBuffer.h`, `src/DirettaSync.cpp`, `src/DirettaSync.h`
-
-### 2. FFmpeg Custom Build Configuration
-
-- Following leeeanh recommendations
-- Found optimal FFmpeg 7.1 configuration that works with DSD playback
-- Minimal build with only audio codecs needed (FLAC, ALAC, DSD, AAC, Vorbis, MP3)
-- Includes libsoxr for high-quality resampling
-- Includes HDCD filter support
-- Removed problematic `--disable-inline-asm` and `--disable-x86asm` flags
-- **Files:** `install.sh`
-
-### 3. Target Release Bug Fix
-
-- Added `release()` function for proper disconnection when playlist ends
-- Previously, target remained "connected" after playback stopped
-- New `m_sdkOpen` flag tracks SDK-level connection state
-- `open()` now automatically reopens SDK if it was released
-- Ensures target can accept connections from other sources after playback
-- **Files:** `src/DirettaSync.cpp`, `src/DirettaSync.h`, `src/DirettaRenderer.cpp`
-
-### 4. Install Script Enhancements
-
-- Updated with working FFmpeg 7.1 build configuration
-- Added FFmpeg installation test suite:
-  - Checks required decoders (FLAC, ALAC, DSD, PCM)
-  - Checks required demuxers (FLAC, WAV, DSF, MOV)
-  - Checks required protocols (HTTP, HTTPS, FILE)
-  - Runs decode functionality test
-- Fixed directory handling after FFmpeg build
-- Installs to `/usr/local` (coexists with system FFmpeg)
-- **Files:** `install.sh`
-
-### 5. DSD→PCM Transition Fix for I2S Targets
-
-- Added special handling in `DirettaSync::open()` for DSD→PCM format transitions
-- I2S/LVDS targets are more timing-sensitive than USB and need cleaner transitions
-- DSD→PCM now performs: full `DIRETTA::Sync::close()` + 800ms delay + fresh `open()`
-- Other format transitions (PCM→DSD, PCM→PCM, DSD→DSD) unchanged
-- **Files:** `src/DirettaSync.cpp` (lines 372-421)
-
-### 6. UPnP Stop Signal Handling
-
-- Diretta connection now properly closed when UPnP Stop action received
-- Ensures clean handoff when switching renderers
-- Pause action unchanged (keeps connection open)
-- **Files:** `src/DirettaRenderer.cpp` (lines 419-431)
-
-### 7. Enhanced Target Listing
-
-- `--list-targets` now shows detailed target information:
-  - Output name (e.g., "LVDS", "USB") - differentiates ports
-  - Port numbers (IN/OUT) and multiport flag
-  - SDK version
-  - Product ID
-- **Files:** `src/DirettaSync.cpp` (lines 269-325)
-
----
-
-## 2026-01-12 (thanks to @leeeanh)
-
-### 1. Power-of-2 Bitmask Modulo
-
-- Added `roundUpPow2()` helper function (lines 33-44)
-- Added `mask_` member variable (line 295)
-- `resize()` now rounds up to power-of-2 and sets `mask_ = size_ - 1`
-- Replaced all `% size_` with `& mask_` throughout:
-  - `getAvailable()` - line 69
-  - `getFreeSpace()` - line 73 (simplified)
-  - `push()` - line 106
-  - `push24BitPacked()` - lines 138, 141-142, 145
-  - `push16To32()` - lines 168, 172-174, 177
-  - `pushDSDPlanar()` - lines 214, 232-234, 237-239, 244
-  - `pop()` - line 268
-
-### 2. Cache-Line Separation
-
-- Added `alignas(64)` to `writePos_` (line 298)
-- Added `alignas(64)` to `readPos_` (line 299)
-
-### Performance Impact
-
-| Operation     | Before                              | After                           |
-| ------------- | ----------------------------------- | ------------------------------- |
-| Modulo        | `% size_` (10-20 cycles)            | `& mask_` (1 cycle)             |
-| False sharing | Possible between writePos_/readPos_ | Eliminated (64-byte separation) |
-
-### Note
-
-The buffer size will now be rounded up to the next power of 2. For example:
-- Request 3MB → allocate 4MB
-- Request 1.5MB → allocate 2MB
-
-This wastes some memory but the tradeoff is worth it for the consistent fast-path performance.
-
----
-
-## 2026-01-11 (thanks to @leeeanh)
-
-### DirettaSync.h
-
-- Removed `m_pushMutex`
-- Added `m_reconfiguring` and `m_ringUsers` atomics for lock-free access
-- Converted 11 format parameters to `std::atomic<>` (`m_sampleRate`, `m_channels`, `m_bytesPerSample`, etc.)
-- Added `ReconfigureGuard` RAII class
-- Added `beginReconfigure()` / `endReconfigure()` method declarations
-
-### DirettaSync.cpp
-
-- Added `RingAccessGuard` class for lock-free ring buffer access
-- Added `beginReconfigure()` / `endReconfigure()` implementations
-- Updated `sendAudio()` to use `RingAccessGuard` instead of mutex (lock-free hot path)
-- Updated `configureRingPCM()`, `configureRingDSD()`, `fullReset()` to use `ReconfigureGuard`
-- Updated all format parameter accesses to use atomic load/store with proper memory ordering
-
-### DirettaRingBuffer.h
-
-- Added `S24PackMode` enum (`Unknown`, `LsbAligned`, `MsbAligned`)
-- Added `detectS24PackMode()` method that checks first 32 samples
-- Updated `push24BitPacked()` to auto-detect and handle both S24 formats
-- S24 detection resets on `clear()` and `resize()`
-
----
-
-## Key Benefits
-
-1. **Lock-free audio path** - `sendAudio()` no longer takes any mutex
-2. **Safe reconfiguration** - `ReconfigureGuard` waits for active readers to drain
-3. **S24 format flexibility** - Handles both LSB-aligned (FFmpeg S24_LE) and MSB-aligned formats automatically
\ No newline at end of file
diff --git a/CLAUDE.md b/CLAUDE.md
deleted file mode 120000
index 9572adb..0000000
--- a/CLAUDE.md
+++ /dev/null
@@ -1 +0,0 @@
-docs/CLAUDE.md
\ No newline at end of file
diff --git a/docs/FORK_CHANGES.md b/FORK_CHANGES.md
similarity index 100%
rename from docs/FORK_CHANGES.md
rename to FORK_CHANGES.md
diff --git a/LICENSE b/LICENSE
index 70b3723..d22808a 100644
--- a/LICENSE
+++ b/LICENSE
@@ -2,7 +2,6 @@ MIT License
 
 Copyright (c) 2025 Dominique COMET (Original Work)
 Copyright (c) 2026 SwissMontainsBear (Modifications)
-Copyright (c) 2026 Leeeanh (SIMD and PCM Optimizations)
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
diff --git a/Makefile b/Makefile
index c90695c..a297b47 100644
--- a/Makefile
+++ b/Makefile
@@ -37,15 +37,7 @@ endif
 ifeq ($(BASE_ARCH),x64)
     HAS_AVX2   := $(shell grep -q avx2 /proc/cpuinfo 2>/dev/null && echo 1 || echo 0)
     HAS_AVX512 := $(shell grep -q avx512 /proc/cpuinfo 2>/dev/null && echo 1 || echo 0)
-
-    # Zen4 detection: Ryzen 7000/8000/9000 series, EPYC 9004, Threadripper 7000
-    # Also check for "znver4" in gcc's output (more reliable)
-    IS_ZEN4    := $(shell grep -m1 "model name" /proc/cpuinfo 2>/dev/null | grep -qiE "(Ryzen.*(5|7|9)[- ]*(7[0-9]{3}|8[0-9]{3}|9[0-9]{3})|EPYC.*90[0-9]{2}|Threadripper.*7[0-9]{3})" && echo 1 || echo 0)
-
-    # Fallback: Check if compiler supports znver4 and CPU has AVX-512 + specific Zen4 features
-    ifeq ($(IS_ZEN4),0)
-        IS_ZEN4 := $(shell grep -q "avx512vbmi2" /proc/cpuinfo 2>/dev/null && grep -q "vaes" /proc/cpuinfo 2>/dev/null && echo 1 || echo 0)
-    endif
+    IS_ZEN4    := $(shell grep -m1 "model name" /proc/cpuinfo 2>/dev/null | grep -qiE "Ryzen.*(7[0-9]{3}|9[0-9]{3})" && echo 1 || echo 0)
 
     ifeq ($(IS_ZEN4),1)
         DEFAULT_VARIANT = x64-linux-15zen4
@@ -88,37 +80,15 @@ endif
 DIRETTA_ARCH = $(word 1,$(subst -, ,$(FULL_VARIANT)))
 
 ifeq ($(DIRETTA_ARCH),x64)
-    # Zen4: Full microarchitecture optimization (-march=znver4)
-    # Includes: AVX-512, optimized scheduling, cache hints, branch prediction
-    ifneq (,$(findstring zen4,$(FULL_VARIANT)))
-        CXXFLAGS += -march=znver4 -mtune=znver4
-        CFLAGS += -march=znver4 -mtune=znver4
-        $(info Compiler: Zen4 microarchitecture optimization enabled)
-
-    # AVX-512 (x86-64-v4): Intel/AMD with AVX-512
-    else ifneq (,$(findstring v4,$(FULL_VARIANT)))
-        CXXFLAGS += -march=x86-64-v4 -mavx512f -mavx512bw -mavx512vl -mavx512dq
-        CFLAGS += -march=x86-64-v4 -mavx512f -mavx512bw -mavx512vl -mavx512dq
-        $(info Compiler: x86-64-v4 (AVX-512) optimization enabled)
-
-    # AVX2 (x86-64-v3): Most modern x64 CPUs
-    else ifneq (,$(findstring v3,$(FULL_VARIANT)))
-        CXXFLAGS += -march=x86-64-v3 -mavx2 -mfma
-        CFLAGS += -march=x86-64-v3 -mavx2 -mfma
-        $(info Compiler: x86-64-v3 (AVX2) optimization enabled)
-
-    # Baseline x64 (v2)
-    else
-        CXXFLAGS += -march=x86-64-v2
-        CFLAGS += -march=x86-64-v2
-        $(info Compiler: x86-64-v2 (baseline) optimization enabled)
+    CXXFLAGS += -mavx2 -mfma
+    CFLAGS += -mavx2 -mfma
+    ifneq (,$(findstring v4,$(FULL_VARIANT)))
+        CXXFLAGS += -mavx512f -mavx512bw
+        CFLAGS += -mavx512f -mavx512bw
+    else ifneq (,$(findstring zen4,$(FULL_VARIANT)))
+        CXXFLAGS += -mavx512f -mavx512bw
+        CFLAGS += -mavx512f -mavx512bw
     endif
-
-# ARM64: Use native tuning for best results
-else ifeq ($(DIRETTA_ARCH),aarch64)
-    CXXFLAGS += -mcpu=native
-    CFLAGS += -mcpu=native
-    $(info Compiler: ARM64 native CPU optimization enabled)
 endif
 
 ifdef NOLOG
@@ -127,13 +97,6 @@ else
     NOLOG_SUFFIX =
 endif
 
-# Optional DSD diagnostics (heavy logging for DSD debugging)
-# Usage: make DSD_DIAG=1
-ifdef DSD_DIAG
-    CXXFLAGS += -DDIRETTA_DSD_DIAGNOSTICS
-    $(info DSD diagnostics: ENABLED)
-endif
-
 DIRETTA_LIB_NAME = libDirettaHost_$(FULL_VARIANT)$(NOLOG_SUFFIX).a
 ACQUA_LIB_NAME   = libACQUA_$(FULL_VARIANT)$(NOLOG_SUFFIX).a
 
@@ -154,25 +117,16 @@ $(info )
 ifdef DIRETTA_SDK_PATH
     SDK_PATH = $(DIRETTA_SDK_PATH)
 else
-    # Search for SDK in common locations (newest version first)
     SDK_SEARCH_PATHS = \
-        ../DirettaHostSDK_147_19 \
         ../DirettaHostSDK_147 \
-        ../DirettaHostSDK_148 \
-        ./DirettaHostSDK_147_19 \
         ./DirettaHostSDK_147 \
-        ./DirettaHostSDK_148 \
-        $(HOME)/DirettaHostSDK_147_19 \
         $(HOME)/DirettaHostSDK_147 \
-        $(HOME)/DirettaHostSDK_148 \
-        /opt/DirettaHostSDK_147_19 \
-        /opt/DirettaHostSDK_147 \
-        /opt/DirettaHostSDK_148
+        /opt/DirettaHostSDK_147
 
     SDK_PATH = $(firstword $(foreach path,$(SDK_SEARCH_PATHS),$(wildcard $(path))))
 
     ifeq ($(SDK_PATH),)
-        $(error Diretta SDK not found! Set DIRETTA_SDK_PATH or place SDK in one of: $(SDK_SEARCH_PATHS))
+        $(error Diretta SDK not found!)
     endif
 endif
 
@@ -189,45 +143,8 @@ $(info )
 # Paths and Libraries
 # ============================================
 
-# FFmpeg path override (for ABI compatibility with target system)
-# Usage: make FFMPEG_PATH=/path/to/ffmpeg-headers
-#
-# This is critical for avoiding crashes when compile-time headers
-# don't match runtime library version (e.g., compiling against
-# FFmpeg 7.x headers but running against FFmpeg 5.x libraries)
-
-# Auto-detect local FFmpeg headers (downloaded by install.sh)
-FFMPEG_HEADERS_LOCAL = $(wildcard ./ffmpeg-headers/.version)
-
-ifdef FFMPEG_PATH
-    # Explicit path provided
-    FFMPEG_INCLUDES = -I$(FFMPEG_PATH)
-    FFMPEG_LDFLAGS =
-    $(info FFmpeg headers: $(FFMPEG_PATH) (explicit))
-else ifneq ($(FFMPEG_HEADERS_LOCAL),)
-    # Local ffmpeg-headers directory exists (from install.sh)
-    FFMPEG_PATH = ./ffmpeg-headers
-    FFMPEG_INCLUDES = -I$(FFMPEG_PATH)
-    FFMPEG_LDFLAGS =
-    FFMPEG_LOCAL_VER := $(shell cat ./ffmpeg-headers/.version 2>/dev/null)
-    $(info FFmpeg headers: ./ffmpeg-headers (v$(FFMPEG_LOCAL_VER)))
-else
-    # Fall back to system headers
-    FFMPEG_INCLUDES = -I/usr/include/ffmpeg -I/usr/include
-    FFMPEG_LDFLAGS =
-    $(info FFmpeg headers: system (/usr/include))
-    $(info )
-    $(info ╔══════════════════════════════════════════════════════════════════╗)
-    $(info ║ NOTE: Using system FFmpeg headers. If you experience crashes,    ║)
-    $(info ║ ensure headers match your runtime FFmpeg version, or run:        ║)
-    $(info ║   make FFMPEG_PATH=/path/to/ffmpeg-source                        ║)
-    $(info ║ Or use install.sh which auto-downloads matching headers.         ║)
-    $(info ╚══════════════════════════════════════════════════════════════════╝)
-    $(info )
-endif
-
 INCLUDES = \
-    $(FFMPEG_INCLUDES) \
+    -I/usr/include/ffmpeg \
     -I/usr/include/upnp \
     -I/usr/local/include \
     -I. \
@@ -235,7 +152,6 @@ INCLUDES = \
     -I$(SDK_PATH)/Host
 
 LDFLAGS += \
-    $(FFMPEG_LDFLAGS) \
     -L/usr/local/lib \
     -L$(SDK_PATH)/lib
 
@@ -271,12 +187,9 @@ SOURCES = \
     $(SRCDIR)/DirettaSync.cpp \
     $(SRCDIR)/UPnPDevice.cpp
 
-# C sources (AVX optimized memcpy - x86 only)
-ifeq ($(BASE_ARCH),x64)
-    C_SOURCES = $(SRCDIR)/fastmemcpy-avx.c
-else
-    C_SOURCES =
-endif
+# C sources (AVX optimized memcpy)
+C_SOURCES = \
+    $(SRCDIR)/fastmemcpy-avx.c
 
 OBJECTS = $(SOURCES:$(SRCDIR)/%.cpp=$(OBJDIR)/%.o)
 C_OBJECTS = $(C_SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o)
@@ -289,7 +202,7 @@ TARGET = $(BINDIR)/DirettaRendererUPnP
 # Build Rules
 # ============================================
 
-.PHONY: all clean info show-arch list-variants
+.PHONY: all clean info
 
 all: $(TARGET)
 	@echo ""
@@ -344,45 +257,4 @@ $(TEST_TARGET): $(TEST_OBJECTS) | $(BINDIR)
 	@echo "Linking $(TEST_TARGET)..."
 	$(CXX) $(CXXFLAGS) $(INCLUDES) $(TEST_OBJECTS) -o $(TEST_TARGET)
 
-# ============================================
-# Architecture Information
-# ============================================
-
-show-arch:
-	@echo ""
-	@echo "═══════════════════════════════════════════════════════"
-	@echo "  Architecture Detection Results"
-	@echo "═══════════════════════════════════════════════════════"
-	@echo "Machine:        $(UNAME_M)"
-	@echo "Base arch:      $(BASE_ARCH)"
-	@echo "SDK variant:    $(FULL_VARIANT)"
-	@echo "SDK library:    $(DIRETTA_LIB_NAME)"
-	@echo "SDK path:       $(SDK_PATH)"
-	@echo ""
-	@echo "Detection flags:"
-ifeq ($(BASE_ARCH),x64)
-	@echo "  HAS_AVX2:     $(HAS_AVX2)"
-	@echo "  HAS_AVX512:   $(HAS_AVX512)"
-	@echo "  IS_ZEN4:      $(IS_ZEN4)"
-endif
-ifeq ($(BASE_ARCH),aarch64)
-	@echo "  PAGE_SIZE:    $(PAGE_SIZE)"
-	@echo "  IS_RPI5:      $(IS_RPI5)"
-endif
-	@echo ""
-	@echo "Compiler flags:"
-	@echo "  CXXFLAGS:     $(CXXFLAGS)"
-	@echo "  CFLAGS:       $(CFLAGS)"
-	@echo "═══════════════════════════════════════════════════════"
-	@echo ""
-
-list-variants:
-	@echo ""
-	@echo "Available SDK library variants in $(SDK_PATH)/lib/:"
-	@ls -1 $(SDK_PATH)/lib/libDirettaHost_*.a 2>/dev/null | sed 's/.*libDirettaHost_/  /' | sed 's/\.a$$//' || echo "  (none found)"
-	@echo ""
-	@echo "Usage: make ARCH_NAME=<variant>"
-	@echo "Example: make ARCH_NAME=x64-linux-15zen4"
-	@echo ""
-
 -include $(DEPENDS)
diff --git a/diretta-renderer-tuner-nosmt.sh b/diretta-renderer-tuner-nosmt.sh
deleted file mode 100644
index b051148..0000000
--- a/diretta-renderer-tuner-nosmt.sh
+++ /dev/null
@@ -1,699 +0,0 @@
-#!/bin/bash
-#
-# diretta-renderer-tuner-nosmt.sh
-# CPU isolation and real-time tuning for diretta-renderer.service
-# VERSION: NO-SMT (Hyper-Threading disabled)
-#
-# This version disables SMT (Hyper-Threading) via kernel parameter.
-# On Ryzen 7 7700X, this gives 8 physical cores (0-7) instead of 16 logical CPUs.
-#
-# Benefits of nosmt for audio:
-#   - No SMT resource contention (ALUs, cache, etc.)
-#   - More predictable latency per core
-#   - Simpler core topology
-#
-# Trade-offs:
-#   - Lose 8 logical CPUs (half the threads)
-#   - Less parallelism available
-#
-# Usage: sudo ./diretta-renderer-tuner-nosmt.sh [apply|revert|status|redistribute]
-
-# --- Bash Best Practices ---
-set -euo pipefail
-
-# =============================================================================
-# CONFIGURATION - EDIT THESE VALUES TO MATCH YOUR SYSTEM
-# =============================================================================
-
-# With nosmt on Ryzen 7 7700X: only cores 0-7 available
-# Adjust for your CPU. Use `lscpu -e` to see your layout.
-
-# Housekeeping core: System tasks, IRQs, kernel work
-# Use 1 physical core for housekeeping
-HOUSEKEEPING_CPUS="0"
-
-# Diretta Renderer cores: Isolated for audio processing
-# Use remaining 7 physical cores
-RENDERER_CPUS="1-7"
-
-# =============================================================================
-# DERIVED VARIABLES (DO NOT EDIT)
-# =============================================================================
-
-# System paths
-GRUB_FILE="/etc/default/grub"
-SYSTEMD_DIR="/etc/systemd/system"
-LOCAL_BIN_DIR="/usr/local/bin"
-
-# Service configuration
-SERVICE_NAME="diretta-renderer.service"
-SLICE_NAME="diretta-renderer.slice"
-
-# Helper scripts/services (use different names to avoid conflicts with SMT version)
-GOVERNOR_SERVICE="cpu-performance-diretta-nosmt.service"
-IRQ_SCRIPT_NAME="set-irq-affinity-diretta-nosmt.sh"
-IRQ_SCRIPT_PATH="${LOCAL_BIN_DIR}/${IRQ_SCRIPT_NAME}"
-THREAD_DIST_SCRIPT_NAME="distribute-diretta-threads-nosmt.sh"
-THREAD_DIST_SCRIPT_PATH="${LOCAL_BIN_DIR}/${THREAD_DIST_SCRIPT_NAME}"
-
-# =============================================================================
-# UTILITY FUNCTIONS
-# =============================================================================
-
-check_root() {
-    if [[ "${EUID}" -ne 0 ]]; then
-        echo "ERROR: This script must be run as root. Please use 'sudo'." >&2
-        exit 1
-    fi
-}
-
-usage() {
-    cat <<EOF
-Diretta Renderer CPU Tuner (NO-SMT VERSION)
-============================================
-
-Usage: sudo $0 [apply|revert|status|redistribute]
-
-Commands:
-  apply        - Apply CPU isolation with SMT disabled
-  revert       - Remove all tuning configurations
-  status       - Check current tuning status
-  redistribute - Manually redistribute threads now (for testing)
-
-Configuration (edit script to change):
-  HOUSEKEEPING_CPUS = ${HOUSEKEEPING_CPUS}
-  RENDERER_CPUS     = ${RENDERER_CPUS}
-
-This version DISABLES SMT (Hyper-Threading), leaving only physical cores.
-On Ryzen 7 7700X: 8 cores (0-7) instead of 16 logical CPUs.
-
-Compare with diretta-renderer-tuner.sh (SMT enabled) to evaluate performance.
-EOF
-}
-
-# Expand CPU range notation (e.g., "1-3,8" -> "1 2 3 8")
-expand_cpu_list() {
-    local input="$1"
-    local result=""
-
-    # Replace commas with spaces, then process ranges
-    for part in ${input//,/ }; do
-        if [[ "$part" == *-* ]]; then
-            local start="${part%-*}"
-            local end="${part#*-}"
-            for ((i=start; i<=end; i++)); do
-                result+="$i "
-            done
-        else
-            result+="$part "
-        fi
-    done
-
-    echo "$result"
-}
-
-# =============================================================================
-# APPLY FUNCTIONS
-# =============================================================================
-
-apply_grub_config() {
-    echo "INFO: Applying GRUB kernel parameters (with nosmt)..."
-
-    # Remove any previous instances of these parameters
-    sed -i -E 's/ (isolcpus|nohz|nohz_full|rcu_nocbs|irqaffinity|nosmt)=[^"]*//g' "${GRUB_FILE}"
-    # Also remove standalone nosmt
-    sed -i -E 's/ nosmt([" ])/ \1/g' "${GRUB_FILE}"
-
-    # Build new kernel parameters
-    # nosmt disables SMT/Hyper-Threading at boot
-    local grub_cmdline="nosmt isolcpus=${RENDERER_CPUS} nohz=on nohz_full=${RENDERER_CPUS} rcu_nocbs=${RENDERER_CPUS} irqaffinity=${HOUSEKEEPING_CPUS}"
-
-    # Append to GRUB_CMDLINE_LINUX
-    sed -i "s|^\(GRUB_CMDLINE_LINUX=\".*\)\"|\1 ${grub_cmdline}\"|" "${GRUB_FILE}"
-
-    # Update GRUB
-    if command -v update-grub &> /dev/null; then
-        update-grub
-    elif command -v grub2-mkconfig &> /dev/null; then
-        grub2-mkconfig -o /boot/grub2/grub.cfg
-    else
-        echo "WARNING: Could not find update-grub or grub2-mkconfig."
-        echo "         Please update GRUB manually."
-    fi
-
-    echo "SUCCESS: GRUB configuration updated (nosmt enabled)."
-    echo "         After reboot, only physical cores 0-7 will be available."
-}
-
-apply_systemd_slice() {
-    echo "INFO: Creating systemd slice for CPU pinning..."
-
-    cat << EOF > "${SYSTEMD_DIR}/${SLICE_NAME}"
-[Unit]
-Description=Slice for Diretta Renderer audio service (nosmt)
-Before=slices.target
-
-[Slice]
-# Pin to isolated audio cores (physical cores only, no SMT)
-AllowedCPUs=${RENDERER_CPUS}
-# Allow full CPU usage
-CPUQuota=100%
-EOF
-
-    echo "SUCCESS: Systemd slice created: ${SLICE_NAME}"
-}
-
-apply_thread_distribution() {
-    echo "INFO: Creating thread distribution script (nosmt version)..."
-
-    # Get the list of renderer CPUs as an array for round-robin
-    local expanded_cpus
-    expanded_cpus=$(expand_cpu_list "${RENDERER_CPUS}")
-
-    cat << 'SCRIPT_HEADER' > "${THREAD_DIST_SCRIPT_PATH}"
-#!/bin/bash
-#
-# distribute-diretta-threads-nosmt.sh
-# Distributes DirettaRenderer threads across physical cores (no SMT)
-#
-# With nosmt, we have fewer cores but each is a full physical core
-# with no resource sharing. This should give more consistent latency.
-#
-
-set -euo pipefail
-
-MAIN_PID="${1:-}"
-LOG_FILE="/var/log/diretta-thread-distribution-nosmt.log"
-
-log() {
-    echo "$(date '+%Y-%m-%d %H:%M:%S'): $*" | tee -a "$LOG_FILE"
-}
-
-if [[ -z "$MAIN_PID" ]]; then
-    log "ERROR: No PID provided"
-    exit 1
-fi
-
-# Wait for threads to spawn (the service needs a moment to initialize)
-sleep 1.0
-
-# Check if process still exists
-if ! ps -p "$MAIN_PID" > /dev/null 2>&1; then
-    log "WARNING: Process $MAIN_PID no longer exists, skipping"
-    exit 0
-fi
-
-SCRIPT_HEADER
-
-    # Now add the CPU array (this part uses the expanded variable)
-    cat << SCRIPT_CPUS >> "${THREAD_DIST_SCRIPT_PATH}"
-# Available renderer CPUs - physical cores only (nosmt)
-# With 11 threads and 7 cores, some cores will have 2 threads
-RENDERER_CPUS_ARRAY=(${expanded_cpus})
-NUM_CPUS=\${#RENDERER_CPUS_ARRAY[@]}
-
-SCRIPT_CPUS
-
-    cat << 'SCRIPT_BODY' >> "${THREAD_DIST_SCRIPT_PATH}"
-log "Starting thread distribution for PID $MAIN_PID (nosmt mode)"
-log "Available physical cores: ${RENDERER_CPUS_ARRAY[*]} ($NUM_CPUS cores)"
-
-# Get all thread IDs for this process
-TIDS=$(ps -T -o tid= -p "$MAIN_PID" 2>/dev/null | tr -d ' ')
-
-if [[ -z "$TIDS" ]]; then
-    log "WARNING: No threads found for PID $MAIN_PID"
-    exit 0
-fi
-
-# Count threads
-THREAD_COUNT=$(echo "$TIDS" | wc -l)
-log "Found $THREAD_COUNT threads to distribute across $NUM_CPUS physical cores"
-
-if [[ $THREAD_COUNT -gt $NUM_CPUS ]]; then
-    log "NOTE: More threads ($THREAD_COUNT) than cores ($NUM_CPUS) - some cores will run multiple threads"
-fi
-
-# Distribute threads round-robin across available CPUs
-i=0
-while read -r tid; do
-    if [[ -n "$tid" ]]; then
-        cpu_index=$(( i % NUM_CPUS ))
-        target_cpu=${RENDERER_CPUS_ARRAY[$cpu_index]}
-
-        if taskset -pc "$target_cpu" "$tid" > /dev/null 2>&1; then
-            log "  Thread $tid -> Core $target_cpu (physical)"
-        else
-            log "  Thread $tid -> Core $target_cpu (failed, may have exited)"
-        fi
-
-        i=$(( i + 1 ))
-    fi
-done <<< "$TIDS"
-
-log "Thread distribution complete: $i threads across $NUM_CPUS physical cores"
-
-# Show final distribution
-log "Final thread layout:"
-ps -T -o tid=,psr=,comm= -p "$MAIN_PID" 2>/dev/null | while read -r line; do
-    log "  $line"
-done
-
-exit 0
-SCRIPT_BODY
-
-    chmod +x "${THREAD_DIST_SCRIPT_PATH}"
-    echo "SUCCESS: Thread distribution script created: ${THREAD_DIST_SCRIPT_PATH}"
-}
-
-apply_service_override() {
-    echo "INFO: Creating service drop-in for real-time scheduling..."
-
-    local override_dir="${SYSTEMD_DIR}/${SERVICE_NAME}.d"
-    mkdir -p "${override_dir}"
-
-    cat << EOF > "${override_dir}/10-isolation.conf"
-[Service]
-# Use dedicated CPU slice
-Slice=${SLICE_NAME}
-
-# Real-time scheduling for audio hot path
-# FIFO is preferred for audio daemons (consistent latency)
-CPUSchedulingPolicy=fifo
-CPUSchedulingPriority=90
-
-# High process priority
-Nice=-19
-
-# I/O scheduling - realtime class
-IOSchedulingClass=realtime
-IOSchedulingPriority=0
-
-# Memory locking for Diretta SDK buffers
-LimitMEMLOCK=infinity
-
-# Real-time priority limit
-LimitRTPRIO=99
-
-# Distribute threads across physical cores after startup
-ExecStartPost=${THREAD_DIST_SCRIPT_PATH} \$MAINPID
-EOF
-
-    echo "SUCCESS: Service override created: ${override_dir}/10-isolation.conf"
-}
-
-apply_irq_config() {
-    echo "INFO: Creating IRQ affinity script..."
-
-    cat << EOF > "${IRQ_SCRIPT_PATH}"
-#!/bin/bash
-# Set all IRQs to housekeeping core (nosmt version)
-# With nosmt, we only have physical core 0 for housekeeping
-
-HOUSEKEEPING_CPUS="${HOUSEKEEPING_CPUS}"
-LOG_FILE="/var/log/irq-affinity-diretta-nosmt.log"
-
-echo "\$(date): Starting IRQ affinity setup (nosmt mode)" | tee "\$LOG_FILE"
-echo "Housekeeping core: \$HOUSEKEEPING_CPUS" | tee -a "\$LOG_FILE"
-
-# Set default affinity for new IRQs
-echo "\$HOUSEKEEPING_CPUS" > /proc/irq/default_smp_affinity_list 2>> "\$LOG_FILE" || true
-
-# Move all existing IRQs to housekeeping core
-for irq_dir in /proc/irq/*; do
-    if [ -f "\$irq_dir/smp_affinity_list" ]; then
-        irq=\$(basename "\$irq_dir")
-        echo "\$HOUSEKEEPING_CPUS" > "\$irq_dir/smp_affinity_list" 2>> "\$LOG_FILE" || true
-    fi
-done
-
-echo "\$(date): IRQ affinity setup complete" | tee -a "\$LOG_FILE"
-EOF
-
-    chmod +x "${IRQ_SCRIPT_PATH}"
-
-    # Create systemd service
-    cat << EOF > "${SYSTEMD_DIR}/set-irq-affinity-diretta-nosmt.service"
-[Unit]
-Description=Set IRQ affinity for Diretta Renderer (nosmt)
-After=network.target
-
-[Service]
-Type=oneshot
-ExecStart=${IRQ_SCRIPT_PATH}
-RemainAfterExit=yes
-
-[Install]
-WantedBy=multi-user.target
-EOF
-
-    echo "SUCCESS: IRQ affinity configuration created."
-}
-
-apply_governor_config() {
-    echo "INFO: Creating CPU governor service..."
-
-    local expanded_cpus
-    expanded_cpus=$(expand_cpu_list "${RENDERER_CPUS}")
-
-    cat << EOF > "${SYSTEMD_DIR}/${GOVERNOR_SERVICE}"
-[Unit]
-Description=Set CPU governor to performance (nosmt, physical cores only)
-After=multi-user.target
-
-[Service]
-Type=oneshot
-ExecStart=/bin/bash -c 'for cpu in ${expanded_cpus}; do \
-    if [ -f /sys/devices/system/cpu/cpu\$cpu/cpufreq/scaling_governor ]; then \
-        echo performance > /sys/devices/system/cpu/cpu\$cpu/cpufreq/scaling_governor 2>/dev/null || \
-        cpufreq-set -c \$cpu -g performance 2>/dev/null || true; \
-    fi; \
-done'
-RemainAfterExit=yes
-
-[Install]
-WantedBy=multi-user.target
-EOF
-
-    echo "SUCCESS: CPU governor service created."
-}
-
-# =============================================================================
-# REVERT FUNCTIONS
-# =============================================================================
-
-revert_grub_config() {
-    echo "INFO: Reverting GRUB kernel parameters..."
-
-    sed -i -E 's/ (isolcpus|nohz|nohz_full|rcu_nocbs|irqaffinity|nosmt)=[^"]*//g' "${GRUB_FILE}"
-    # Also remove standalone nosmt
-    sed -i -E 's/ nosmt([" ])/ \1/g' "${GRUB_FILE}"
-
-    if command -v update-grub &> /dev/null; then
-        update-grub
-    elif command -v grub2-mkconfig &> /dev/null; then
-        grub2-mkconfig -o /boot/grub2/grub.cfg
-    fi
-
-    echo "SUCCESS: GRUB configuration reverted (nosmt removed)."
-}
-
-revert_systemd_config() {
-    echo "INFO: Removing systemd configurations..."
-
-    # Remove slice
-    rm -f "${SYSTEMD_DIR}/${SLICE_NAME}"
-
-    # Remove service override
-    rm -rf "${SYSTEMD_DIR}/${SERVICE_NAME}.d"
-
-    # Remove IRQ service and script
-    rm -f "${SYSTEMD_DIR}/set-irq-affinity-diretta-nosmt.service"
-    rm -f "${IRQ_SCRIPT_PATH}"
-
-    # Remove governor service
-    rm -f "${SYSTEMD_DIR}/${GOVERNOR_SERVICE}"
-
-    # Remove thread distribution script
-    rm -f "${THREAD_DIST_SCRIPT_PATH}"
-
-    echo "SUCCESS: Systemd configurations removed."
-}
-
-# =============================================================================
-# STATUS FUNCTION
-# =============================================================================
-
-check_status() {
-    echo "=== Diretta Renderer Tuner Status (NO-SMT VERSION) ==="
-    echo ""
-
-    local has_error=0
-
-    # Check if nosmt is active
-    echo -n "0. SMT Status: "
-    if grep -q "nosmt" /proc/cmdline; then
-        echo "DISABLED (nosmt active)"
-        local online_cpus
-        online_cpus=$(nproc 2>/dev/null || grep -c ^processor /proc/cpuinfo)
-        echo "   Online CPUs: $online_cpus"
-    else
-        echo "ENABLED (nosmt not in cmdline - reboot required)"
-        has_error=1
-    fi
-
-    # 1. GRUB parameters
-    echo -n "1. GRUB CPU isolation: "
-    if grep -q "isolcpus=" /proc/cmdline; then
-        echo "ACTIVE"
-        echo "   Current: $(cat /proc/cmdline | grep -oE 'isolcpus=[^ ]+')"
-    else
-        echo "NOT ACTIVE (requires reboot after apply)"
-        has_error=1
-    fi
-
-    # 2. Systemd slice
-    echo -n "2. Systemd slice (${SLICE_NAME}): "
-    if [[ -f "${SYSTEMD_DIR}/${SLICE_NAME}" ]]; then
-        echo "EXISTS"
-    else
-        echo "MISSING"
-        has_error=1
-    fi
-
-    # 3. Service override
-    echo -n "3. Service override: "
-    if [[ -f "${SYSTEMD_DIR}/${SERVICE_NAME}.d/10-isolation.conf" ]]; then
-        echo "EXISTS"
-    else
-        echo "MISSING"
-        has_error=1
-    fi
-
-    # 4. IRQ affinity
-    echo -n "4. IRQ affinity service: "
-    if [[ -f "${SYSTEMD_DIR}/set-irq-affinity-diretta-nosmt.service" ]]; then
-        local irq_status
-        irq_status=$(systemctl is-active set-irq-affinity-diretta-nosmt.service 2>/dev/null || echo "inactive")
-        echo "EXISTS (${irq_status})"
-    else
-        echo "MISSING"
-        has_error=1
-    fi
-
-    # 5. Governor service
-    echo -n "5. CPU governor service: "
-    if [[ -f "${SYSTEMD_DIR}/${GOVERNOR_SERVICE}" ]]; then
-        local gov_status
-        gov_status=$(systemctl is-active "${GOVERNOR_SERVICE}" 2>/dev/null || echo "inactive")
-        echo "EXISTS (${gov_status})"
-    else
-        echo "MISSING"
-        has_error=1
-    fi
-
-    # 6. Thread distribution script
-    echo -n "6. Thread distribution script: "
-    if [[ -f "${THREAD_DIST_SCRIPT_PATH}" ]]; then
-        echo "EXISTS"
-    else
-        echo "MISSING"
-        has_error=1
-    fi
-
-    echo ""
-
-    # Service status
-    echo "=== Service Status ==="
-    echo ""
-    if systemctl is-active --quiet "${SERVICE_NAME}" 2>/dev/null; then
-        echo "Service: RUNNING"
-        systemctl show "${SERVICE_NAME}" -p Slice,CPUSchedulingPolicy,Nice 2>/dev/null | sed 's/^/  /'
-
-        # Show actual CPU affinity
-        local main_pid
-        main_pid=$(systemctl show "${SERVICE_NAME}" -p MainPID --value 2>/dev/null)
-        if [[ -n "$main_pid" && "$main_pid" != "0" ]]; then
-            echo ""
-            echo "  Process affinity (allowed CPUs):"
-            taskset -pc "$main_pid" 2>/dev/null | sed 's/^/    /' || echo "    (unable to read)"
-
-            echo ""
-            echo "  Thread distribution (current):"
-            echo "    TID      CPU  COMMAND"
-            ps -T -o tid=,psr=,comm= -p "$main_pid" 2>/dev/null | while read -r tid psr comm; do
-                printf "    %-8s %-4s %s\n" "$tid" "$psr" "$comm"
-            done
-
-            # Count threads per CPU
-            echo ""
-            echo "  Threads per physical core:"
-            ps -T -o psr= -p "$main_pid" 2>/dev/null | sort | uniq -c | while read -r count cpu; do
-                printf "    Core %s: %s threads\n" "$cpu" "$count"
-            done
-        fi
-    else
-        echo "Service: NOT RUNNING"
-    fi
-
-    echo ""
-
-    # Summary
-    if [[ $has_error -eq 0 ]]; then
-        echo "=== All configurations in place (nosmt mode) ==="
-        if ! grep -q "nosmt" /proc/cmdline; then
-            echo "NOTE: Reboot required for nosmt to take effect."
-        fi
-    else
-        echo "=== Some configurations missing - run 'apply' ==="
-    fi
-}
-
-# =============================================================================
-# MAIN
-# =============================================================================
-
-main() {
-    check_root
-
-    case "${1:-}" in
-        apply)
-            echo "=== Applying Diretta Renderer CPU Tuning (NO-SMT) ==="
-            echo ""
-            echo "Configuration:"
-            echo "  Mode:             NO-SMT (Hyper-Threading disabled)"
-            echo "  Housekeeping CPU: ${HOUSEKEEPING_CPUS} (1 physical core)"
-            echo "  Renderer CPUs:    ${RENDERER_CPUS} (7 physical cores)"
-            echo ""
-            echo "After reboot, only cores 0-7 will be available."
-            echo ""
-
-            apply_grub_config
-            apply_systemd_slice
-            apply_thread_distribution
-            apply_service_override
-            apply_irq_config
-            apply_governor_config
-
-            echo ""
-            echo "INFO: Reloading systemd daemon..."
-            systemctl daemon-reload
-
-            echo "INFO: Enabling helper services..."
-            systemctl enable set-irq-affinity-diretta-nosmt.service "${GOVERNOR_SERVICE}" 2>/dev/null || true
-
-            echo ""
-            echo "=== Configuration Applied (NO-SMT) ==="
-            echo ""
-            echo "IMPORTANT: A REBOOT is required for nosmt and CPU isolation."
-            echo ""
-            echo "After reboot:"
-            echo "  - SMT will be disabled (8 physical cores only)"
-            echo "  - Restart the service: sudo systemctl restart ${SERVICE_NAME}"
-            echo "  - Check status: sudo $0 status"
-            echo ""
-            ;;
-
-        revert)
-            echo "=== Reverting Diretta Renderer CPU Tuning (NO-SMT) ==="
-            echo ""
-
-            # Disable services first
-            systemctl disable set-irq-affinity-diretta-nosmt.service "${GOVERNOR_SERVICE}" 2>/dev/null || true
-
-            revert_grub_config
-            revert_systemd_config
-
-            echo ""
-            echo "INFO: Reloading systemd daemon..."
-            systemctl daemon-reload
-
-            echo ""
-            echo "=== Configuration Reverted ==="
-            echo ""
-            echo "IMPORTANT: A REBOOT is required to re-enable SMT."
-            echo ""
-            ;;
-
-        status)
-            check_status
-            ;;
-
-        redistribute)
-            echo "=== Manual Thread Redistribution (NO-SMT) ==="
-            echo ""
-
-            # Check if service is running
-            if ! systemctl is-active --quiet "${SERVICE_NAME}" 2>/dev/null; then
-                echo "ERROR: ${SERVICE_NAME} is not running"
-                exit 1
-            fi
-
-            # Get main PID
-            local main_pid
-            main_pid=$(systemctl show "${SERVICE_NAME}" -p MainPID --value 2>/dev/null)
-            if [[ -z "$main_pid" || "$main_pid" == "0" ]]; then
-                echo "ERROR: Could not get PID for ${SERVICE_NAME}"
-                exit 1
-            fi
-
-            echo "Service PID: $main_pid"
-            echo ""
-
-            # Check current SMT status
-            if grep -q "nosmt" /proc/cmdline; then
-                echo "SMT Status: DISABLED (nosmt active)"
-            else
-                echo "SMT Status: ENABLED (nosmt not active yet)"
-                echo "NOTE: Full nosmt benefits require reboot"
-            fi
-            echo ""
-
-            # Check if distribution script exists
-            if [[ -f "${THREAD_DIST_SCRIPT_PATH}" ]]; then
-                echo "Running thread distribution script..."
-                "${THREAD_DIST_SCRIPT_PATH}" "$main_pid"
-            else
-                echo "Thread distribution script not found at ${THREAD_DIST_SCRIPT_PATH}"
-                echo "Run 'apply' first to create it, or distributing manually..."
-                echo ""
-
-                # Manual distribution
-                local expanded_cpus
-                expanded_cpus=$(expand_cpu_list "${RENDERER_CPUS}")
-                local -a cpu_array=($expanded_cpus)
-                local num_cpus=${#cpu_array[@]}
-
-                echo "Distributing threads across physical cores: ${cpu_array[*]}"
-                echo ""
-
-                local i=0
-                ps -T -o tid= -p "$main_pid" 2>/dev/null | tr -d ' ' | while read -r tid; do
-                    if [[ -n "$tid" ]]; then
-                        local cpu_index=$(( i % num_cpus ))
-                        local target_cpu=${cpu_array[$cpu_index]}
-                        if taskset -pc "$target_cpu" "$tid" > /dev/null 2>&1; then
-                            echo "  Thread $tid -> Core $target_cpu"
-                        else
-                            echo "  Thread $tid -> Core $target_cpu (failed)"
-                        fi
-                        i=$(( i + 1 ))
-                    fi
-                done
-            fi
-
-            echo ""
-            echo "=== Current Thread Layout ==="
-            echo "TID      CPU  COMMAND"
-            ps -T -o tid=,psr=,comm= -p "$main_pid" 2>/dev/null | while read -r tid psr comm; do
-                printf "%-8s %-4s %s\n" "$tid" "$psr" "$comm"
-            done
-            ;;
-
-        *)
-            usage
-            ;;
-    esac
-}
-
-main "$@"
diff --git a/diretta-renderer-tuner.sh b/diretta-renderer-tuner.sh
deleted file mode 100644
index d4cd4c6..0000000
--- a/diretta-renderer-tuner.sh
+++ /dev/null
@@ -1,658 +0,0 @@
-#!/bin/bash
-#
-# diretta-renderer-tuner.sh
-# CPU isolation and real-time tuning for diretta-renderer.service
-#
-# Based on audiophile-tuner-fixed.sh but simplified for a single-service setup.
-# DirettaRendererUPnP is a standalone UPnP/DLNA renderer - no secondary service needed.
-#
-# Features:
-#   - CPU isolation via kernel parameters (isolcpus, nohz_full, rcu_nocbs)
-#   - Systemd slice for CPU pinning
-#   - Real-time FIFO scheduling for the audio hot path
-#   - IRQ affinity to housekeeping cores
-#   - CPU governor set to performance
-#
-# Usage: sudo ./diretta-renderer-tuner.sh [apply|revert|status]
-
-# --- Bash Best Practices ---
-set -euo pipefail
-
-# =============================================================================
-# CONFIGURATION - EDIT THESE VALUES TO MATCH YOUR SYSTEM
-# =============================================================================
-
-# Example for Ryzen 7 7700X (8 cores / 16 threads: 0-15)
-# Adjust for your CPU topology. Use `lscpu -e` to see your layout.
-
-# Housekeeping cores: System tasks, IRQs, kernel work
-# Typically use 1-2 physical cores (with their SMT siblings)
-HOUSEKEEPING_CPUS="0,8"
-
-# Diretta Renderer cores: Isolated for audio processing
-# Use remaining cores for best performance
-# The renderer has multiple threads: UPnP, decode, Diretta SDK sending
-RENDERER_CPUS="1-7,9-15"
-
-# =============================================================================
-# DERIVED VARIABLES (DO NOT EDIT)
-# =============================================================================
-
-# System paths
-GRUB_FILE="/etc/default/grub"
-SYSTEMD_DIR="/etc/systemd/system"
-LOCAL_BIN_DIR="/usr/local/bin"
-
-# Service configuration
-SERVICE_NAME="diretta-renderer.service"
-SLICE_NAME="diretta-renderer.slice"
-
-# Helper scripts/services
-GOVERNOR_SERVICE="cpu-performance-diretta.service"
-IRQ_SCRIPT_NAME="set-irq-affinity-diretta.sh"
-IRQ_SCRIPT_PATH="${LOCAL_BIN_DIR}/${IRQ_SCRIPT_NAME}"
-THREAD_DIST_SCRIPT_NAME="distribute-diretta-threads.sh"
-THREAD_DIST_SCRIPT_PATH="${LOCAL_BIN_DIR}/${THREAD_DIST_SCRIPT_NAME}"
-
-# =============================================================================
-# UTILITY FUNCTIONS
-# =============================================================================
-
-check_root() {
-    if [[ "${EUID}" -ne 0 ]]; then
-        echo "ERROR: This script must be run as root. Please use 'sudo'." >&2
-        exit 1
-    fi
-}
-
-usage() {
-    cat <<EOF
-Diretta Renderer CPU Tuner
-==========================
-
-Usage: sudo $0 [apply|revert|status|redistribute]
-
-Commands:
-  apply        - Apply CPU isolation and real-time tuning
-  revert       - Remove all tuning configurations
-  status       - Check current tuning status
-  redistribute - Manually redistribute threads now (for testing)
-
-Configuration (edit script to change):
-  HOUSEKEEPING_CPUS = ${HOUSEKEEPING_CPUS}
-  RENDERER_CPUS     = ${RENDERER_CPUS}
-
-This script isolates CPU cores for the Diretta Renderer to minimize
-audio jitter and ensure consistent low-latency playback.
-EOF
-}
-
-# Expand CPU range notation (e.g., "1-3,8" -> "1 2 3 8")
-expand_cpu_list() {
-    local input="$1"
-    local result=""
-
-    # Replace commas with spaces, then process ranges
-    for part in ${input//,/ }; do
-        if [[ "$part" == *-* ]]; then
-            local start="${part%-*}"
-            local end="${part#*-}"
-            for ((i=start; i<=end; i++)); do
-                result+="$i "
-            done
-        else
-            result+="$part "
-        fi
-    done
-
-    echo "$result"
-}
-
-# =============================================================================
-# APPLY FUNCTIONS
-# =============================================================================
-
-apply_grub_config() {
-    echo "INFO: Applying GRUB kernel parameters for CPU isolation..."
-
-    # Remove any previous instances of these parameters
-    sed -i -E 's/ (isolcpus|nohz|nohz_full|rcu_nocbs|irqaffinity)=[^"]*//g' "${GRUB_FILE}"
-
-    # Build new kernel parameters
-    local grub_cmdline="isolcpus=${RENDERER_CPUS} nohz=on nohz_full=${RENDERER_CPUS} rcu_nocbs=${RENDERER_CPUS} irqaffinity=${HOUSEKEEPING_CPUS}"
-
-    # Append to GRUB_CMDLINE_LINUX
-    sed -i "s|^\(GRUB_CMDLINE_LINUX=\".*\)\"|\1 ${grub_cmdline}\"|" "${GRUB_FILE}"
-
-    # Update GRUB
-    if command -v update-grub &> /dev/null; then
-        update-grub
-    elif command -v grub2-mkconfig &> /dev/null; then
-        grub2-mkconfig -o /boot/grub2/grub.cfg
-    else
-        echo "WARNING: Could not find update-grub or grub2-mkconfig."
-        echo "         Please update GRUB manually."
-    fi
-
-    echo "SUCCESS: GRUB configuration updated."
-}
-
-apply_systemd_slice() {
-    echo "INFO: Creating systemd slice for CPU pinning..."
-
-    cat << EOF > "${SYSTEMD_DIR}/${SLICE_NAME}"
-[Unit]
-Description=Slice for Diretta Renderer audio service
-Before=slices.target
-
-[Slice]
-# Pin to isolated audio cores
-AllowedCPUs=${RENDERER_CPUS}
-# Allow full CPU usage
-CPUQuota=100%
-EOF
-
-    echo "SUCCESS: Systemd slice created: ${SLICE_NAME}"
-}
-
-apply_service_override() {
-    echo "INFO: Creating service drop-in for real-time scheduling..."
-
-    local override_dir="${SYSTEMD_DIR}/${SERVICE_NAME}.d"
-    mkdir -p "${override_dir}"
-
-    cat << EOF > "${override_dir}/10-isolation.conf"
-[Service]
-# Use dedicated CPU slice
-Slice=${SLICE_NAME}
-
-# Real-time scheduling for audio hot path
-# FIFO is preferred for audio daemons (consistent latency)
-CPUSchedulingPolicy=fifo
-CPUSchedulingPriority=90
-
-# High process priority
-Nice=-19
-
-# I/O scheduling - realtime class
-IOSchedulingClass=realtime
-IOSchedulingPriority=0
-
-# Memory locking for Diretta SDK buffers
-LimitMEMLOCK=infinity
-
-# Real-time priority limit
-LimitRTPRIO=99
-
-# Distribute threads across cores after startup
-# This prevents all threads from piling onto one core
-ExecStartPost=${THREAD_DIST_SCRIPT_PATH} \$MAINPID
-EOF
-
-    echo "SUCCESS: Service override created: ${override_dir}/10-isolation.conf"
-}
-
-apply_irq_config() {
-    echo "INFO: Creating IRQ affinity script..."
-
-    cat << EOF > "${IRQ_SCRIPT_PATH}"
-#!/bin/bash
-# Set all IRQs to housekeeping cores to avoid interrupting audio processing
-
-HOUSEKEEPING_CPUS="${HOUSEKEEPING_CPUS}"
-LOG_FILE="/var/log/irq-affinity-diretta.log"
-
-echo "\$(date): Starting IRQ affinity setup for Diretta Renderer" | tee "\$LOG_FILE"
-
-# Set default affinity for new IRQs
-echo "\$HOUSEKEEPING_CPUS" > /proc/irq/default_smp_affinity_list 2>> "\$LOG_FILE" || true
-
-# Move all existing IRQs to housekeeping cores
-for irq_dir in /proc/irq/*; do
-    if [ -f "\$irq_dir/smp_affinity_list" ]; then
-        irq=\$(basename "\$irq_dir")
-        echo "\$HOUSEKEEPING_CPUS" > "\$irq_dir/smp_affinity_list" 2>> "\$LOG_FILE" || true
-    fi
-done
-
-echo "\$(date): IRQ affinity setup complete" | tee -a "\$LOG_FILE"
-EOF
-
-    chmod +x "${IRQ_SCRIPT_PATH}"
-
-    # Create systemd service
-    cat << EOF > "${SYSTEMD_DIR}/set-irq-affinity-diretta.service"
-[Unit]
-Description=Set IRQ affinity for Diretta Renderer audio isolation
-After=network.target
-
-[Service]
-Type=oneshot
-ExecStart=${IRQ_SCRIPT_PATH}
-RemainAfterExit=yes
-
-[Install]
-WantedBy=multi-user.target
-EOF
-
-    echo "SUCCESS: IRQ affinity configuration created."
-}
-
-apply_governor_config() {
-    echo "INFO: Creating CPU governor service..."
-
-    local expanded_cpus
-    expanded_cpus=$(expand_cpu_list "${RENDERER_CPUS}")
-
-    cat << EOF > "${SYSTEMD_DIR}/${GOVERNOR_SERVICE}"
-[Unit]
-Description=Set CPU governor to performance for Diretta Renderer cores
-After=multi-user.target
-
-[Service]
-Type=oneshot
-ExecStart=/bin/bash -c 'for cpu in ${expanded_cpus}; do \
-    if [ -f /sys/devices/system/cpu/cpu\$cpu/cpufreq/scaling_governor ]; then \
-        echo performance > /sys/devices/system/cpu/cpu\$cpu/cpufreq/scaling_governor 2>/dev/null || \
-        cpufreq-set -c \$cpu -g performance 2>/dev/null || true; \
-    fi; \
-done'
-RemainAfterExit=yes
-
-[Install]
-WantedBy=multi-user.target
-EOF
-
-    echo "SUCCESS: CPU governor service created."
-}
-
-apply_thread_distribution() {
-    echo "INFO: Creating thread distribution script..."
-
-    # Get the list of renderer CPUs as an array for round-robin
-    local expanded_cpus
-    expanded_cpus=$(expand_cpu_list "${RENDERER_CPUS}")
-
-    cat << 'SCRIPT_HEADER' > "${THREAD_DIST_SCRIPT_PATH}"
-#!/bin/bash
-#
-# distribute-diretta-threads.sh
-# Distributes DirettaRenderer threads across available cores round-robin
-#
-# Called by systemd ExecStartPost after the service starts.
-# This spreads threads to avoid all 11+ threads piling onto one core.
-#
-
-set -euo pipefail
-
-MAIN_PID="${1:-}"
-LOG_FILE="/var/log/diretta-thread-distribution.log"
-
-log() {
-    echo "$(date '+%Y-%m-%d %H:%M:%S'): $*" | tee -a "$LOG_FILE"
-}
-
-if [[ -z "$MAIN_PID" ]]; then
-    log "ERROR: No PID provided"
-    exit 1
-fi
-
-# Wait for threads to spawn (the service needs a moment to initialize)
-sleep 1.0
-
-# Check if process still exists
-if ! ps -p "$MAIN_PID" > /dev/null 2>&1; then
-    log "WARNING: Process $MAIN_PID no longer exists, skipping"
-    exit 0
-fi
-
-SCRIPT_HEADER
-
-    # Now add the CPU array (this part uses the expanded variable)
-    cat << SCRIPT_CPUS >> "${THREAD_DIST_SCRIPT_PATH}"
-# Available renderer CPUs (from tuner configuration)
-RENDERER_CPUS_ARRAY=(${expanded_cpus})
-NUM_CPUS=\${#RENDERER_CPUS_ARRAY[@]}
-
-SCRIPT_CPUS
-
-    cat << 'SCRIPT_BODY' >> "${THREAD_DIST_SCRIPT_PATH}"
-log "Starting thread distribution for PID $MAIN_PID"
-log "Available CPUs: ${RENDERER_CPUS_ARRAY[*]} ($NUM_CPUS cores)"
-
-# Get all thread IDs for this process
-TIDS=$(ps -T -o tid= -p "$MAIN_PID" 2>/dev/null | tr -d ' ')
-
-if [[ -z "$TIDS" ]]; then
-    log "WARNING: No threads found for PID $MAIN_PID"
-    exit 0
-fi
-
-# Count threads
-THREAD_COUNT=$(echo "$TIDS" | wc -l)
-log "Found $THREAD_COUNT threads to distribute"
-
-# Distribute threads round-robin across available CPUs
-i=0
-while read -r tid; do
-    if [[ -n "$tid" ]]; then
-        cpu_index=$(( i % NUM_CPUS ))
-        target_cpu=${RENDERER_CPUS_ARRAY[$cpu_index]}
-
-        if taskset -pc "$target_cpu" "$tid" > /dev/null 2>&1; then
-            log "  Thread $tid -> CPU $target_cpu"
-        else
-            log "  Thread $tid -> CPU $target_cpu (failed, may have exited)"
-        fi
-
-        i=$(( i + 1 ))
-    fi
-done <<< "$TIDS"
-
-log "Thread distribution complete: $i threads distributed across $NUM_CPUS CPUs"
-
-# Show final distribution
-log "Final thread layout:"
-ps -T -o tid=,psr=,comm= -p "$MAIN_PID" 2>/dev/null | while read -r line; do
-    log "  $line"
-done
-
-exit 0
-SCRIPT_BODY
-
-    chmod +x "${THREAD_DIST_SCRIPT_PATH}"
-    echo "SUCCESS: Thread distribution script created: ${THREAD_DIST_SCRIPT_PATH}"
-}
-
-# =============================================================================
-# REVERT FUNCTIONS
-# =============================================================================
-
-revert_grub_config() {
-    echo "INFO: Reverting GRUB kernel parameters..."
-
-    sed -i -E 's/ (isolcpus|nohz|nohz_full|rcu_nocbs|irqaffinity)=[^"]*//g' "${GRUB_FILE}"
-
-    if command -v update-grub &> /dev/null; then
-        update-grub
-    elif command -v grub2-mkconfig &> /dev/null; then
-        grub2-mkconfig -o /boot/grub2/grub.cfg
-    fi
-
-    echo "SUCCESS: GRUB configuration reverted."
-}
-
-revert_systemd_config() {
-    echo "INFO: Removing systemd configurations..."
-
-    # Remove slice
-    rm -f "${SYSTEMD_DIR}/${SLICE_NAME}"
-
-    # Remove service override
-    rm -rf "${SYSTEMD_DIR}/${SERVICE_NAME}.d"
-
-    # Remove IRQ service and script
-    rm -f "${SYSTEMD_DIR}/set-irq-affinity-diretta.service"
-    rm -f "${IRQ_SCRIPT_PATH}"
-
-    # Remove governor service
-    rm -f "${SYSTEMD_DIR}/${GOVERNOR_SERVICE}"
-
-    # Remove thread distribution script
-    rm -f "${THREAD_DIST_SCRIPT_PATH}"
-
-    echo "SUCCESS: Systemd configurations removed."
-}
-
-# =============================================================================
-# STATUS FUNCTION
-# =============================================================================
-
-check_status() {
-    echo "=== Diretta Renderer Tuner Status ==="
-    echo ""
-
-    local has_error=0
-
-    # 1. GRUB parameters
-    echo -n "1. GRUB CPU isolation: "
-    if grep -q "isolcpus=" /proc/cmdline; then
-        echo "ACTIVE"
-        echo "   Current: $(cat /proc/cmdline | grep -oE 'isolcpus=[^ ]+')"
-    else
-        echo "NOT ACTIVE (requires reboot after apply)"
-        has_error=1
-    fi
-
-    # 2. Systemd slice
-    echo -n "2. Systemd slice (${SLICE_NAME}): "
-    if [[ -f "${SYSTEMD_DIR}/${SLICE_NAME}" ]]; then
-        echo "EXISTS"
-    else
-        echo "MISSING"
-        has_error=1
-    fi
-
-    # 3. Service override
-    echo -n "3. Service override: "
-    if [[ -f "${SYSTEMD_DIR}/${SERVICE_NAME}.d/10-isolation.conf" ]]; then
-        echo "EXISTS"
-    else
-        echo "MISSING"
-        has_error=1
-    fi
-
-    # 4. IRQ affinity
-    echo -n "4. IRQ affinity service: "
-    if [[ -f "${SYSTEMD_DIR}/set-irq-affinity-diretta.service" ]]; then
-        local irq_status
-        irq_status=$(systemctl is-active set-irq-affinity-diretta.service 2>/dev/null || echo "inactive")
-        echo "EXISTS (${irq_status})"
-    else
-        echo "MISSING"
-        has_error=1
-    fi
-
-    # 5. Governor service
-    echo -n "5. CPU governor service: "
-    if [[ -f "${SYSTEMD_DIR}/${GOVERNOR_SERVICE}" ]]; then
-        local gov_status
-        gov_status=$(systemctl is-active "${GOVERNOR_SERVICE}" 2>/dev/null || echo "inactive")
-        echo "EXISTS (${gov_status})"
-    else
-        echo "MISSING"
-        has_error=1
-    fi
-
-    # 6. Thread distribution script
-    echo -n "6. Thread distribution script: "
-    if [[ -f "${THREAD_DIST_SCRIPT_PATH}" ]]; then
-        echo "EXISTS"
-    else
-        echo "MISSING"
-        has_error=1
-    fi
-
-    echo ""
-
-    # Service status
-    echo "=== Service Status ==="
-    echo ""
-    if systemctl is-active --quiet "${SERVICE_NAME}" 2>/dev/null; then
-        echo "Service: RUNNING"
-        systemctl show "${SERVICE_NAME}" -p Slice,CPUSchedulingPolicy,Nice 2>/dev/null | sed 's/^/  /'
-
-        # Show actual CPU affinity
-        local main_pid
-        main_pid=$(systemctl show "${SERVICE_NAME}" -p MainPID --value 2>/dev/null)
-        if [[ -n "$main_pid" && "$main_pid" != "0" ]]; then
-            echo ""
-            echo "  Process affinity (allowed CPUs):"
-            taskset -pc "$main_pid" 2>/dev/null | sed 's/^/    /' || echo "    (unable to read)"
-
-            echo ""
-            echo "  Thread distribution (current):"
-            echo "    TID      CPU  COMMAND"
-            ps -T -o tid=,psr=,comm= -p "$main_pid" 2>/dev/null | while read -r tid psr comm; do
-                printf "    %-8s %-4s %s\n" "$tid" "$psr" "$comm"
-            done
-
-            # Count threads per CPU
-            echo ""
-            echo "  Threads per CPU:"
-            ps -T -o psr= -p "$main_pid" 2>/dev/null | sort | uniq -c | while read -r count cpu; do
-                printf "    CPU %s: %s threads\n" "$cpu" "$count"
-            done
-        fi
-    else
-        echo "Service: NOT RUNNING"
-    fi
-
-    echo ""
-
-    # Summary
-    if [[ $has_error -eq 0 ]]; then
-        echo "=== All configurations in place ==="
-        if ! grep -q "isolcpus=" /proc/cmdline; then
-            echo "NOTE: Reboot required for kernel parameters to take effect."
-        fi
-    else
-        echo "=== Some configurations missing - run 'apply' ==="
-    fi
-}
-
-# =============================================================================
-# MAIN
-# =============================================================================
-
-main() {
-    check_root
-
-    case "${1:-}" in
-        apply)
-            echo "=== Applying Diretta Renderer CPU Tuning ==="
-            echo ""
-            echo "Configuration:"
-            echo "  Housekeeping CPUs: ${HOUSEKEEPING_CPUS}"
-            echo "  Renderer CPUs:     ${RENDERER_CPUS}"
-            echo ""
-
-            apply_grub_config
-            apply_systemd_slice
-            apply_thread_distribution
-            apply_service_override
-            apply_irq_config
-            apply_governor_config
-
-            echo ""
-            echo "INFO: Reloading systemd daemon..."
-            systemctl daemon-reload
-
-            echo "INFO: Enabling helper services..."
-            systemctl enable set-irq-affinity-diretta.service "${GOVERNOR_SERVICE}" 2>/dev/null || true
-
-            echo ""
-            echo "=== Configuration Applied ==="
-            echo ""
-            echo "IMPORTANT: A REBOOT is required for CPU isolation to take effect."
-            echo ""
-            echo "After reboot:"
-            echo "  - Restart the service: sudo systemctl restart ${SERVICE_NAME}"
-            echo "  - Check status: sudo $0 status"
-            echo ""
-            ;;
-
-        revert)
-            echo "=== Reverting Diretta Renderer CPU Tuning ==="
-            echo ""
-
-            # Disable services first
-            systemctl disable set-irq-affinity-diretta.service "${GOVERNOR_SERVICE}" 2>/dev/null || true
-
-            revert_grub_config
-            revert_systemd_config
-
-            echo ""
-            echo "INFO: Reloading systemd daemon..."
-            systemctl daemon-reload
-
-            echo ""
-            echo "=== Configuration Reverted ==="
-            echo ""
-            echo "IMPORTANT: A REBOOT is required for kernel parameter changes."
-            echo ""
-            ;;
-
-        status)
-            check_status
-            ;;
-
-        redistribute)
-            echo "=== Manual Thread Redistribution ==="
-            echo ""
-
-            # Check if service is running
-            if ! systemctl is-active --quiet "${SERVICE_NAME}" 2>/dev/null; then
-                echo "ERROR: ${SERVICE_NAME} is not running"
-                exit 1
-            fi
-
-            # Get main PID
-            local main_pid
-            main_pid=$(systemctl show "${SERVICE_NAME}" -p MainPID --value 2>/dev/null)
-            if [[ -z "$main_pid" || "$main_pid" == "0" ]]; then
-                echo "ERROR: Could not get PID for ${SERVICE_NAME}"
-                exit 1
-            fi
-
-            echo "Service PID: $main_pid"
-            echo ""
-
-            # Check if distribution script exists
-            if [[ -f "${THREAD_DIST_SCRIPT_PATH}" ]]; then
-                echo "Running thread distribution script..."
-                "${THREAD_DIST_SCRIPT_PATH}" "$main_pid"
-            else
-                echo "Thread distribution script not found at ${THREAD_DIST_SCRIPT_PATH}"
-                echo "Run 'apply' first to create it, or distributing manually..."
-                echo ""
-
-                # Manual distribution
-                local expanded_cpus
-                expanded_cpus=$(expand_cpu_list "${RENDERER_CPUS}")
-                local -a cpu_array=($expanded_cpus)
-                local num_cpus=${#cpu_array[@]}
-
-                echo "Distributing threads across CPUs: ${cpu_array[*]}"
-                echo ""
-
-                local i=0
-                ps -T -o tid= -p "$main_pid" 2>/dev/null | tr -d ' ' | while read -r tid; do
-                    if [[ -n "$tid" ]]; then
-                        local cpu_index=$(( i % num_cpus ))
-                        local target_cpu=${cpu_array[$cpu_index]}
-                        if taskset -pc "$target_cpu" "$tid" > /dev/null 2>&1; then
-                            echo "  Thread $tid -> CPU $target_cpu"
-                        else
-                            echo "  Thread $tid -> CPU $target_cpu (failed)"
-                        fi
-                        i=$(( i + 1 ))
-                    fi
-                done
-            fi
-
-            echo ""
-            echo "=== Current Thread Layout ==="
-            echo "TID      CPU  COMMAND"
-            ps -T -o tid=,psr=,comm= -p "$main_pid" 2>/dev/null | while read -r tid psr comm; do
-                printf "%-8s %-4s %s\n" "$tid" "$psr" "$comm"
-            done
-            ;;
-
-        *)
-            usage
-            ;;
-    esac
-}
-
-main "$@"
diff --git a/docs/2026-01-13-0000-PCM_OPTIMIZATION_CHANGES.md b/docs/2026-01-13-0000-PCM_OPTIMIZATION_CHANGES.md
deleted file mode 100644
index d0a710e..0000000
--- a/docs/2026-01-13-0000-PCM_OPTIMIZATION_CHANGES.md
+++ /dev/null
@@ -1,378 +0,0 @@
-# PCM Latency and Jitter Optimization Changes
-
-**Date:** 2026-01-12
-**Version:** Post-v1.2.1 (DirettaRendererUPnP-L)
-**Goal:** Minimize latency and jitter in PCM decode/playback path
-
----
-
-## Summary
-
-This update implements a comprehensive PCM optimization targeting three areas:
-1. **Buffer tuning** - Reduced from ~1s to ~300ms for lower latency
-2. **Flow control** - Replaced 10ms blocking sleeps with 500µs micro-sleeps
-3. **Allocation elimination** - Removed per-call heap allocations in audio hot path
-
-Additionally includes Makefile enhancements for Zen4 CPU optimization.
-
----
-
-## Changes by File
-
-### 1. `src/DirettaSync.h` - Buffer Constants
-
-**Lines 76-91**
-
-| Constant | Before | After | Impact |
-|----------|--------|-------|--------|
-| `PCM_BUFFER_SECONDS` | 1.0f | 0.3f | ~700ms latency reduction |
-| `PCM_PREFILL_MS` | 50 | 30 | Faster playback start |
-| `MIN_BUFFER_BYTES` | 3,072,000 | 65,536 | Allows 300ms buffer at all rates |
-
-**Rationale:** 300ms buffer provides sufficient headroom for LAN jitter while significantly reducing end-to-end latency. The 64KB floor ensures minimum safety margin at low sample rates.
-
----
-
-### 2. `src/DirettaSync.cpp` - DSD→PCM Transition Fix
-
-**Lines 363-427** (inside `open()` method)
-
-Added special handling for DSD→PCM format transitions:
-
-```cpp
-if (wasDSD && nowPCM) {
-    // Full close/reopen for clean I2S transition
-    stop();
-    disconnect(true);
-    DIRETTA::Sync::close();
-    // ... worker thread shutdown ...
-    std::this_thread::sleep_for(std::chrono::milliseconds(800));
-    DIRETTA::Sync::open(...);
-}
-```
-
-**Rationale:** I2S targets are more timing-sensitive than USB. DSD→PCM transitions require the target to switch from DSD clock to PCM clock, which needs a clean break and 800ms settling time.
-
----
-
-### 3. `src/DirettaSync.cpp` - Enhanced Target Listing
-
-**Lines 265-318** (`listTargets()` method)
-
-Enhanced output now shows:
-- Output name (differentiates I2S vs USB)
-- Port numbers (IN/OUT) with multiport flag
-- Configuration URL
-- SDK version
-- Product ID
-
-**Before:**
-```
-[1] MyTarget
-```
-
-**After:**
-```
-[1] MyTarget
-    Output: USB Audio
-    Port: IN=1 OUT=2
-    Config: http://192.168.1.100/config
-    Version: 1.47.19
-    ProductID: 0x12345678
-```
-
----
-
-### 4. `src/DirettaRenderer.cpp` - Hybrid Flow Control
-
-**Lines 27-32** - Added FlowControl namespace:
-
-```cpp
-namespace FlowControl {
-    constexpr int MICROSLEEP_US = 500;           // Was 10,000µs (10ms)
-    constexpr int MAX_WAIT_MS = 20;              // Was 500ms (50 × 10ms)
-    constexpr int MAX_RETRIES = 40;              // 40 × 500µs = 20ms max
-    constexpr float CRITICAL_BUFFER_LEVEL = 0.10f;
-}
-```
-
-**Lines 258-290** - Replaced PCM send loop:
-
-| Scenario | Before | After |
-|----------|--------|-------|
-| Backpressure sleep | 10ms fixed | 500µs micro-sleep |
-| Max stall time | 500ms | 20ms |
-| Low buffer (<10%) | Same sleep | Immediate early-return |
-
-**Rationale:**
-- Micro-sleeps reduce jitter from coarse timing
-- Critical mode ensures buffer refill is prioritized when running low
-- 20ms max stall prevents long audio gaps
-
----
-
-### 5. `src/DirettaRenderer.cpp` - Chunk Size Reduction
-
-**Line 543-544**
-
-```cpp
-// Before
-size_t samplesPerCall = isDSD ? 32768 : 8192;
-
-// After
-size_t samplesPerCall = isDSD ? 32768 : 2048;
-```
-
-| Sample Rate | Before (8192) | After (2048) |
-|-------------|---------------|--------------|
-| 44.1kHz | ~186ms | ~46ms |
-| 96kHz | ~85ms | ~21ms |
-| 192kHz | ~43ms | ~11ms |
-| 352.8kHz | ~23ms | ~5.8ms |
-
-**Rationale:** Smaller chunks enable more responsive buffer-level flow control.
-
----
-
-### 6. `src/DirettaRenderer.cpp` - UPnP Stop Handling
-
-**Lines 419-431** (inside `onStop` callback)
-
-```cpp
-// Before: Keep connection open
-m_direttaSync->stopPlayback(true);
-// m_direttaSync->close();  // Was commented out
-
-// After: Close on Stop for clean resource release
-m_direttaSync->stopPlayback(true);
-m_direttaSync->close();
-```
-
-**Rationale:** Closing on Stop (not Pause) ensures:
-- Clean handoff when switching renderers
-- Proper resource release on Diretta target
-- Expected behavior for control points
-
----
-
-### 7. `src/AudioEngine.h` - Reusable Members
-
-**Lines 128-139**
-
-Added member variables for allocation elimination:
-
-```cpp
-AVPacket* m_packet;      // Reusable for raw packet reading (DSD and PCM)
-AVFrame* m_frame;        // Reusable for decoded frames (PCM)
-
-AudioBuffer m_resampleBuffer;
-size_t m_resampleBufferCapacity = 0;
-```
-
----
-
-### 8. `src/AudioEngine.cpp` - Allocation Elimination
-
-**Constructor (lines 73-85):**
-- Initialize `m_frame = nullptr`
-- Initialize `m_resampleBufferCapacity = 0`
-
-**close() method (lines 514-534):**
-- Free `m_frame` with `av_frame_free()`
-- Reset `m_resampleBufferCapacity = 0`
-
-**readSamples() method:**
-
-| Location | Before | After |
-|----------|--------|-------|
-| Lines 752-762 | `av_packet_alloc()` every call | Lazy init once, reuse |
-| Lines 867-875 | `AudioBuffer tempBuffer(size)` every call | Capacity-tracked member |
-| Lines 947-949 | `av_packet_free()`, `av_frame_free()` | `av_*_unref()` (no dealloc) |
-
-**Impact:** Eliminates 3-4 heap allocations per `readSamples()` call during steady-state playback.
-
----
-
-### 9. `Makefile` - Zen4 Microarchitecture Optimization
-
-**Lines 41-48** - Improved Zen4 detection:
-- Matches Ryzen 5/7/9 7000/8000/9000 series
-- Matches EPYC 9004 (Genoa)
-- Matches Threadripper 7000 series
-- Fallback: detects `avx512vbmi2` + `vaes` features
-
-**Lines 82-114** - Architecture-specific compiler flags:
-
-| Variant | Compiler Flags |
-|---------|---------------|
-| `zen4` | `-march=znver4 -mtune=znver4` |
-| `v4` | `-march=x86-64-v4 -mavx512f/bw/vl/dq` |
-| `v3` | `-march=x86-64-v3 -mavx2 -mfma` |
-| `v2` | `-march=x86-64-v2` |
-| `aarch64` | `-mcpu=native` |
-
-**Lines 150-165** - Updated SDK search paths:
-- Added `DirettaHostSDK_147_19` (newest version first)
-
-**Lines 299-334** - New helper targets:
-- `make show-arch` - Display detected architecture and flags
-- `make list-variants` - List available SDK library variants
-
-**Lines 225-230** - Conditional C sources:
-- `fastmemcpy-avx.c` only compiled on x86 (not ARM64)
-
----
-
-### 10. `src/memcpyfast_audio.h` - ARM64 Compatibility
-
-**Lines 13-17** - Architecture detection:
-
-```cpp
-#if defined(__x86_64__) || defined(_M_X64) || defined(__i386__) || defined(_M_IX86)
-    #define MEMCPY_AUDIO_X86 1
-#elif defined(__aarch64__) || defined(_M_ARM64)
-    #define MEMCPY_AUDIO_ARM64 1
-#endif
-```
-
-**Lines 19-162** - x86 implementation (wrapped in `#ifdef MEMCPY_AUDIO_X86`):
-- AVX2 optimized `memcpy_audio_fixed()` with overlapping stores
-- `prefetch_audio_buffer()` with cache hints
-- Runtime AVX-512 detection and dispatch
-- `memcpy_audio()` main dispatcher
-
-**Lines 164-203** - ARM64/Fallback implementation:
-
-```cpp
-// Prefetch - no-op on ARM64 (compiler may auto-prefetch)
-static inline void prefetch_audio_buffer(const void* src, size_t size) {
-    (void)src;
-    (void)size;
-}
-
-// Uses standard memcpy - GCC/Clang auto-vectorize with NEON
-static inline void* memcpy_audio(void *dst, const void *src, size_t len) {
-    return std::memcpy(dst, src, len);
-}
-
-static inline void memcpy_audio_fixed(void* dst, const void* src, size_t size) {
-    std::memcpy(dst, src, size);
-}
-```
-
-**Makefile integration** (lines 225-230):
-
-```makefile
-# C sources (AVX optimized memcpy - x86 only)
-ifeq ($(BASE_ARCH),x64)
-    C_SOURCES = $(SRCDIR)/fastmemcpy-avx.c
-else
-    C_SOURCES =
-endif
-```
-
-| Platform | memcpy_audio() | fastmemcpy-avx.c |
-|----------|----------------|------------------|
-| x86_64 | AVX2/AVX-512 SIMD | Compiled |
-| ARM64 | std::memcpy (NEON auto-vectorized) | Skipped |
-| RISC-V | std::memcpy | Skipped |
-
-**Rationale:** ARM64 compilers (GCC/Clang) auto-vectorize `std::memcpy` with NEON instructions, providing good performance without hand-written intrinsics. The x86-specific `fastmemcpy-avx.c` is excluded from ARM64 builds to avoid compilation errors.
-
----
-
-## Performance Impact
-
-| Metric | Before | After | Improvement |
-|--------|--------|-------|-------------|
-| PCM buffer latency | ~1000ms | ~300ms | 70% reduction |
-| Time to first audio | ~50ms prefill | ~30ms prefill | 40% faster |
-| Backpressure max stall | 500ms | 20ms | 96% reduction |
-| Heap allocs per decode | 3-4 | 0 (steady state) | Eliminated |
-| Scheduling granularity | 186ms @44.1k | 46ms @44.1k | 4x finer |
-
----
-
-## Testing Checklist
-
-### x86_64 Testing
-- [ ] PCM playback at 44.1kHz/16-bit
-- [ ] PCM playback at 96kHz/24-bit
-- [ ] PCM playback at 192kHz/24-bit
-- [ ] PCM playback at 352.8kHz/24-bit (DXD)
-- [ ] DSD64 playback
-- [ ] DSD128 playback
-- [ ] DSD→PCM transition (no clicks)
-- [ ] PCM→DSD transition
-- [ ] Gapless playback (same format)
-- [ ] Track skip/seek
-- [ ] Stop and restart
-- [ ] Network stress test (if possible)
-- [ ] Zen4 build verification (`make show-arch`)
-
-### ARM64 Testing (Raspberry Pi 4/5, etc.)
-- [ ] Build completes without errors (`make`)
-- [ ] Architecture detection correct (`make show-arch`)
-- [ ] PCM playback at 44.1kHz/16-bit
-- [ ] PCM playback at 96kHz/24-bit
-- [ ] PCM playback at 192kHz/24-bit
-- [ ] DSD64 playback
-- [ ] DSD→PCM transition (no clicks)
-- [ ] Stop and restart
-
----
-
-## Rollback
-
-To revert to previous behavior, restore these constants in `src/DirettaSync.h`:
-
-```cpp
-constexpr float PCM_BUFFER_SECONDS = 1.0f;
-constexpr size_t PCM_PREFILL_MS = 50;
-constexpr size_t MIN_BUFFER_BYTES = 3072000;
-```
-
----
-
-## Bug Fixes
-
-### 11. `src/DirettaRenderer.cpp` - Playlist End Target Release
-
-**Date:** 2026-01-13
-
-**Lines 319-335** (`trackEndCallback`)
-
-**Bug:** When a playlist ended naturally (last track finished), the Diretta target was not released. The control point received the STOPPED notification but the target remained held, making the system appear "stuck".
-
-**Before:**
-```cpp
-m_audioEngine->setTrackEndCallback([this]() {
-    std::cout << "[DirettaRenderer] Track ended naturally" << std::endl;
-    m_upnp->notifyStateChange("STOPPED");
-});
-```
-
-**After:**
-```cpp
-m_audioEngine->setTrackEndCallback([this]() {
-    std::cout << "[DirettaRenderer] Track ended naturally" << std::endl;
-
-    // Close Diretta connection to release the target
-    if (m_direttaSync) {
-        m_direttaSync->stopPlayback(true);
-        m_direttaSync->close();
-    }
-
-    m_upnp->notifyStateChange("STOPPED");
-});
-```
-
-**Rationale:** The explicit `onStop` callback (from control point Stop command) properly closed the Diretta connection, but the natural track end callback did not. This caused the target to remain held indefinitely after playlist completion.
-
----
-
-## Credits
-
-- PCM optimization design and implementation with Claude Code assistance
-- Based on patterns from MPD Diretta Output Plugin v0.4.0
-- Diretta Host SDK by Yu Harada
diff --git a/docs/2026-01-14-1000-DSD_BUFFER_OPTIMIZATION.md b/docs/2026-01-14-1000-DSD_BUFFER_OPTIMIZATION.md
deleted file mode 100644
index 89990f0..0000000
--- a/docs/2026-01-14-1000-DSD_BUFFER_OPTIMIZATION.md
+++ /dev/null
@@ -1,438 +0,0 @@
-# DSD Buffer Optimization
-
-This document describes the DSD buffer optimizations implemented on 2026-01-14, addressing two performance issues in the DSD audio processing path.
-
-## Table of Contents
-
-1. [Problem Statement](#problem-statement)
-2. [Technical Background](#technical-background)
-3. [Solution Overview](#solution-overview)
-4. [Implementation Details](#implementation-details)
-5. [Performance Analysis](#performance-analysis)
-6. [Files Modified](#files-modified)
-7. [Testing Considerations](#testing-considerations)
-
----
-
-## Problem Statement
-
-### Issue 1: Heap Allocations in Hot Path
-
-The DSD reading path in `AudioEngine::readSamples()` created two `std::vector<uint8_t>` objects on every call:
-
-```cpp
-// Previous implementation (problematic)
-std::vector<uint8_t> leftData;
-std::vector<uint8_t> rightData;
-leftData.reserve(bytesPerChannelNeeded);
-rightData.reserve(bytesPerChannelNeeded);
-```
-
-This violated the "zero heap allocations in hot path" design principle established for PCM processing, where reusable buffers (`m_packet`, `m_frame`, `m_resampleBuffer`) are used instead.
-
-**Impact:**
-- Memory allocator pressure on every audio chunk
-- Potential heap fragmentation over long playback sessions
-- Unpredictable latency spikes from allocator contention
-- Cache pollution from newly allocated memory
-
-### Issue 2: Fixed Chunk Size Regardless of DSD Rate
-
-The `samplesPerCall` value was hardcoded at 32768 for all DSD rates:
-
-```cpp
-// Previous implementation (problematic)
-size_t samplesPerCall = isDSD ? 32768 : 2048;
-```
-
-DSD sample rates vary dramatically:
-- DSD64: 2,822,400 Hz
-- DSD128: 5,644,800 Hz
-- DSD256: 11,289,600 Hz
-- DSD512: 22,579,200 Hz
-- DSD1024: 45,158,400 Hz
-
-A fixed 32768 samples produces wildly different chunk durations:
-
-| DSD Rate | Chunk Duration |
-|----------|----------------|
-| DSD64    | ~11.6 ms       |
-| DSD128   | ~5.8 ms        |
-| DSD256   | ~2.9 ms        |
-| DSD512   | ~1.45 ms       |
-| DSD1024  | ~0.73 ms       |
-
-**Impact:**
-- At DSD512/1024, the audio thread loops 8-16x more frequently than necessary
-- Increased context switching and CPU wake-ups
-- Higher power consumption
-- More frequent buffer level checks causing potential oscillation
-
----
-
-## Technical Background
-
-### DSD Data Flow
-
-```
-┌─────────────────────────────────────────────────────────────────┐
-│ AudioDecoder::readSamples() [DSD native mode]                   │
-│                                                                 │
-│   1. Calculate bytes needed: (numSamples * channels) / 8        │
-│   2. Read FFmpeg packets (DSF: [L_block][R_block] per packet)   │
-│   3. Accumulate L/R channel data separately                     │
-│   4. Output planar format: [all_L_bytes][all_R_bytes]           │
-└─────────────────────────────────────────────────────────────────┘
-                              │
-                              ▼
-┌─────────────────────────────────────────────────────────────────┐
-│ DirettaSync::sendAudio()                                        │
-│                                                                 │
-│   1. Convert samples to bytes                                   │
-│   2. Call m_ringBuffer.pushDSDPlanar()                          │
-│   3. Interleave channels, apply bit reversal/byte swap          │
-└─────────────────────────────────────────────────────────────────┘
-                              │
-                              ▼
-┌─────────────────────────────────────────────────────────────────┐
-│ DirettaRingBuffer → getNewStream() → Diretta Target             │
-└─────────────────────────────────────────────────────────────────┘
-```
-
-### DSD Sample Rate Calculation
-
-DSD is a 1-bit format. The "sample rate" represents the bit rate per channel:
-- DSD64 = 64 × 44,100 = 2,822,400 bits/second/channel
-- DSD128 = 128 × 44,100 = 5,644,800 bits/second/channel
-- etc.
-
-For stereo, bytes per second = (sample_rate × 2 channels) / 8 bits
-
-### Why PCM Didn't Have This Problem
-
-PCM already used pre-allocated buffers:
-- `m_packet` - Reusable AVPacket for reading
-- `m_frame` - Reusable AVFrame for decoding
-- `m_resampleBuffer` - Reusable buffer for resampling output
-
-PCM's `samplesPerCall` (2048) was tuned for ~46ms at 44.1kHz, providing consistent scheduling granularity across common sample rates (44.1-192kHz vary only 4x, not 16x like DSD).
-
----
-
-## Solution Overview
-
-### Part A: Pre-allocated DSD Buffers
-
-Replace per-call `std::vector` allocation with persistent `AudioBuffer` members that resize only when capacity is insufficient.
-
-**Before:**
-```cpp
-std::vector<uint8_t> leftData;      // Allocated every call
-std::vector<uint8_t> rightData;     // Allocated every call
-leftData.insert(...);               // Potential reallocation
-```
-
-**After:**
-```cpp
-// Members persist across calls
-AudioBuffer m_dsdLeftBuffer;
-AudioBuffer m_dsdRightBuffer;
-size_t m_dsdBufferCapacity = 0;
-
-// In readSamples():
-if (m_dsdBufferCapacity < bytesPerChannelNeeded) {
-    m_dsdLeftBuffer.resize(bytesPerChannelNeeded);   // Rare
-    m_dsdRightBuffer.resize(bytesPerChannelNeeded);  // Rare
-    m_dsdBufferCapacity = bytesPerChannelNeeded;
-}
-uint8_t* leftData = m_dsdLeftBuffer.data();          // Zero allocation
-memcpy(leftData + leftOffset, source, size);         // Direct copy
-```
-
-### Part B: Rate-Adaptive Chunk Sizing
-
-Calculate `samplesPerCall` dynamically to maintain consistent ~12ms chunk duration regardless of DSD rate.
-
-**Before:**
-```cpp
-size_t samplesPerCall = isDSD ? 32768 : 2048;  // Fixed
-```
-
-**After:**
-```cpp
-size_t samplesPerCall;
-if (isDSD) {
-    samplesPerCall = DirettaBuffer::calculateDsdSamplesPerCall(sampleRate);
-} else {
-    samplesPerCall = 2048;
-}
-```
-
-The calculation targets 12ms chunks with alignment and clamping:
-
-```cpp
-inline size_t calculateDsdSamplesPerCall(uint32_t dsdSampleRate) {
-    constexpr double TARGET_CHUNK_MS = 12.0;
-    constexpr size_t MIN_DSD_SAMPLES = 8192;    // Floor: ~3ms at DSD64
-    constexpr size_t MAX_DSD_SAMPLES = 131072;  // Ceiling: prevents huge buffers
-
-    size_t samplesPerCall = static_cast<size_t>(dsdSampleRate * TARGET_CHUNK_MS / 1000.0);
-    samplesPerCall = ((samplesPerCall + 255) / 256) * 256;  // Align to 256
-    samplesPerCall = std::max(samplesPerCall, MIN_DSD_SAMPLES);
-    samplesPerCall = std::min(samplesPerCall, MAX_DSD_SAMPLES);
-
-    return samplesPerCall;
-}
-```
-
----
-
-## Implementation Details
-
-### AudioEngine.h Changes
-
-Added three new members to `AudioDecoder` class:
-
-```cpp
-// Pre-allocated DSD channel buffers (eliminates per-call std::vector allocation)
-AudioBuffer m_dsdLeftBuffer;
-AudioBuffer m_dsdRightBuffer;
-size_t m_dsdBufferCapacity = 0;
-```
-
-These follow the same pattern as the existing `m_resampleBuffer` / `m_resampleBufferCapacity`.
-
-### AudioEngine.cpp Changes
-
-#### Buffer Initialization (lines 552-563)
-
-```cpp
-// Ensure pre-allocated DSD buffers are large enough (resize only if capacity insufficient)
-if (m_dsdBufferCapacity < bytesPerChannelNeeded) {
-    m_dsdLeftBuffer.resize(bytesPerChannelNeeded);
-    m_dsdRightBuffer.resize(bytesPerChannelNeeded);
-    m_dsdBufferCapacity = bytesPerChannelNeeded;
-}
-
-// Use offset tracking instead of vector operations (zero allocations)
-size_t leftOffset = 0;
-size_t rightOffset = 0;
-uint8_t* leftData = m_dsdLeftBuffer.data();
-uint8_t* rightData = m_dsdRightBuffer.data();
-```
-
-#### Data Accumulation (lines 575-578, 621-624)
-
-Replaced `vector.insert()` with `memcpy()` + offset increment:
-
-```cpp
-// Before: leftData.insert(leftData.end(), source, source + size);
-// After:
-memcpy(leftData + leftOffset, source, size);
-leftOffset += size;
-```
-
-#### Loop Condition (line 596)
-
-```cpp
-// Before: while (leftData.size() < bytesPerChannelNeeded && !m_eof)
-// After:
-while (leftOffset < bytesPerChannelNeeded && !m_eof)
-```
-
-#### Output Assembly (lines 655, 659-660)
-
-```cpp
-// Before: size_t actualPerCh = std::min(leftData.size(), rightData.size());
-// After:
-size_t actualPerCh = std::min(leftOffset, rightOffset);
-
-// Before: memcpy_audio(buffer.data(), leftData.data(), actualPerCh);
-// After:
-memcpy_audio(buffer.data(), leftData, actualPerCh);  // leftData is now uint8_t*
-```
-
-#### Cleanup in close() (line 534)
-
-```cpp
-m_dsdBufferCapacity = 0;  // Reset DSD buffer capacity tracking
-```
-
-### DirettaSync.h Changes
-
-Added `calculateDsdSamplesPerCall()` to the `DirettaBuffer` namespace (lines 109-132):
-
-```cpp
-// Calculate DSD samples per call based on rate
-// Target: ~10-12ms chunks for consistent scheduling granularity
-// Returns DSD samples (1-bit), which convert to bytes via: bytes = samples * channels / 8
-inline size_t calculateDsdSamplesPerCall(uint32_t dsdSampleRate) {
-    constexpr double TARGET_CHUNK_MS = 12.0;
-    constexpr size_t MIN_DSD_SAMPLES = 8192;
-    constexpr size_t MAX_DSD_SAMPLES = 131072;
-
-    size_t samplesPerCall = static_cast<size_t>(dsdSampleRate * TARGET_CHUNK_MS / 1000.0);
-    samplesPerCall = ((samplesPerCall + 255) / 256) * 256;
-    samplesPerCall = std::max(samplesPerCall, MIN_DSD_SAMPLES);
-    samplesPerCall = std::min(samplesPerCall, MAX_DSD_SAMPLES);
-
-    return samplesPerCall;
-}
-```
-
-### DirettaRenderer.cpp Changes
-
-Updated audio thread loop (lines 567-575):
-
-```cpp
-// Adjust samples per call based on format
-// PCM: 2048 samples = ~46ms at 44.1kHz
-// DSD: Rate-adaptive for consistent ~12ms chunks
-size_t samplesPerCall;
-if (isDSD) {
-    samplesPerCall = DirettaBuffer::calculateDsdSamplesPerCall(sampleRate);
-} else {
-    samplesPerCall = 2048;
-}
-```
-
----
-
-## Performance Analysis
-
-### Chunk Timing Comparison
-
-| DSD Rate | Sample Rate (Hz) | Before (32768) | After (calculated) | Improvement |
-|----------|------------------|----------------|--------------------|-------------|
-| DSD64    | 2,822,400        | 11.6 ms        | 12.1 ms (34,048)   | Similar |
-| DSD128   | 5,644,800        | 5.8 ms         | 12.0 ms (67,840)   | 2x fewer loops |
-| DSD256   | 11,289,600       | 2.9 ms         | 11.6 ms (131,072)  | 4x fewer loops |
-| DSD512   | 22,579,200       | 1.45 ms        | 5.8 ms (131,072)   | 4x fewer loops |
-| DSD1024  | 45,158,400       | 0.73 ms        | 2.9 ms (131,072)   | 4x fewer loops |
-
-Note: DSD256+ are clamped at MAX_DSD_SAMPLES (131,072) to prevent excessive buffer sizes.
-
-### Memory Allocation Comparison
-
-| Metric | Before | After |
-|--------|--------|-------|
-| Allocations per readSamples() | 2 (std::vector constructor) | 0 (steady state) |
-| Potential reallocations | Multiple (vector::insert) | 0 (pre-sized) |
-| Memory pattern | Alloc → use → free (every call) | Alloc once → reuse |
-| Allocator pressure | High (thousands/second at DSD512) | Near zero |
-
-### CPU Impact
-
-| Metric | Before | After |
-|--------|--------|-------|
-| Loop iterations at DSD512 | ~690/sec | ~172/sec |
-| Loop iterations at DSD1024 | ~1370/sec | ~345/sec |
-| Buffer level checks | Proportional to iterations | 4x fewer |
-| Context switch opportunities | More frequent | Reduced |
-
-### Calculated Values by Rate
-
-| DSD Rate | Raw Calculation | After Alignment | After Clamping | Bytes (stereo) |
-|----------|-----------------|-----------------|----------------|----------------|
-| DSD64    | 33,869          | 34,048          | 34,048         | 8,512          |
-| DSD128   | 67,738          | 67,840          | 67,840         | 16,960         |
-| DSD256   | 135,475         | 135,680         | 131,072        | 32,768         |
-| DSD512   | 270,950         | 271,104         | 131,072        | 32,768         |
-| DSD1024  | 541,901         | 542,208         | 131,072        | 32,768         |
-
----
-
-## Files Modified
-
-| File | Lines Changed | Description |
-|------|---------------|-------------|
-| `src/AudioEngine.h` | 141-144 | Added `m_dsdLeftBuffer`, `m_dsdRightBuffer`, `m_dsdBufferCapacity` |
-| `src/AudioEngine.cpp` | 552-661 | Replaced vectors with pre-allocated buffers and offset tracking |
-| `src/AudioEngine.cpp` | 534 | Added capacity reset in `close()` |
-| `src/DirettaSync.h` | 109-132 | Added `calculateDsdSamplesPerCall()` function |
-| `src/DirettaRenderer.cpp` | 567-575 | Updated to use rate-adaptive calculation |
-
----
-
-## Testing Considerations
-
-### Functional Testing
-
-1. **DSD64 playback** - Baseline, should behave similarly to before
-2. **DSD128 playback** - Verify 2x larger chunks work correctly
-3. **DSD256 playback** - Verify clamped chunk size works
-4. **DSD512/1024 playback** - If available, verify high-rate handling
-5. **Gapless DSD transitions** - Verify buffer reuse across tracks
-6. **DSD→PCM transitions** - Verify buffer capacity reset works
-7. **Long playback sessions** - Verify no memory growth
-
-### Performance Testing
-
-1. **Memory monitoring** - Verify no per-call allocations (use `valgrind` or similar)
-2. **CPU usage comparison** - Compare before/after at DSD256+
-3. **Latency measurement** - Verify no regression in audio latency
-
-### Edge Cases
-
-1. **Mono DSD files** - Rare but should work (different bytesPerChannel calculation)
-2. **Very short DSD files** - Verify buffer sizing doesn't over-allocate
-3. **Rapid track changes** - Verify capacity tracking handles format switches
-
-### Build Verification
-
-```bash
-# Clean build
-make clean && make ARCH_NAME=x64-linux-15v3
-
-# Run with verbose logging
-sudo ./bin/DirettaRendererUPnP --target 1 --verbose
-
-# Observe log output for samplesPerCall values
-# DSD64: ~34,048
-# DSD128: ~67,840
-# DSD256+: ~131,072
-```
-
----
-
-## Design Rationale
-
-### Why 12ms Target?
-
-- PCM uses ~46ms at 44.1kHz (2048 samples)
-- DSD64's original 32768 samples ≈ 11.6ms
-- 12ms provides similar granularity to the original DSD64 behavior
-- Not too short (excessive looping) or too long (poor responsiveness)
-
-### Why Clamp at 131,072?
-
-- 131,072 samples = 32,768 bytes per channel (stereo)
-- Matches the original fixed buffer size in bytes
-- Prevents excessive memory usage at extreme rates
-- Still provides 4x improvement over fixed 32768 samples at DSD512+
-
-### Why 256-Sample Alignment?
-
-- 256 samples = 32 bytes per channel
-- Aligns with common SIMD vector widths (AVX2 = 32 bytes)
-- Ensures clean boundaries for potential future SIMD optimization
-- Matches existing alignment patterns in the ring buffer
-
-### Why Not Dynamic Buffer Allocation?
-
-Pre-allocated buffers with capacity tracking provide:
-- Predictable memory usage
-- Zero allocations in steady state
-- Simple implementation matching existing patterns
-- No risk of allocation failure during playback
-
----
-
-## Conclusion
-
-These optimizations address two long-standing inefficiencies in the DSD processing path:
-
-1. **Memory**: Eliminated per-call heap allocations, reducing allocator pressure and improving cache behavior
-2. **CPU**: Reduced loop iterations by up to 4x for high-rate DSD formats
-
-The changes follow established patterns in the codebase (pre-allocated buffers, rate-adaptive calculations) and maintain backward compatibility with existing behavior at DSD64.
diff --git a/docs/2026-01-15-1718-PCM_FIFO_BYPASS_OPTIMIZATION.md b/docs/2026-01-15-1718-PCM_FIFO_BYPASS_OPTIMIZATION.md
deleted file mode 100644
index ecbc9ec..0000000
--- a/docs/2026-01-15-1718-PCM_FIFO_BYPASS_OPTIMIZATION.md
+++ /dev/null
@@ -1,284 +0,0 @@
-# PCM FIFO and Bypass Optimization
-
-**Date:** 2026-01-15
-**Based on:** Optimization designs from @leeeanh fork
-**Implementation:** Selective cherry-pick with preservation of existing bug fixes
-
-## Overview
-
-This document describes four interconnected optimizations to the PCM audio path that improve both performance and bit-perfect playback capability. These optimizations were adapted from design documents in the leeeanh fork, with careful preservation of bug fixes already present in the main repository.
-
-## Optimization 1: Enhanced S24 Detection
-
-### Problem
-
-The original S24 (24-bit in 32-bit container) detection had limitations:
-- Only checked LSB position, assuming MSB would be zero
-- Failed when track starts with silence (all zeros)
-- No way to provide hints from decoder metadata
-
-### Solution
-
-Implemented a hybrid detection system with three layers:
-
-1. **Sample-based detection** (highest priority)
-   - Checks both LSB (byte 0) and MSB (byte 3) positions
-   - Returns definitive result when non-zero samples found
-   - Returns `Deferred` state for silence
-
-2. **Hint from FFmpeg metadata** (fallback)
-   - Decoder provides alignment hint based on codec ID
-   - Used when sample detection sees only silence
-   - Can be overridden by subsequent sample detection
-
-3. **Timeout mechanism** (safety)
-   - After ~1 second of silence (48000 samples), defaults to LSB
-   - Prevents indefinite deferral
-
-### Code Changes
-
-**DirettaRingBuffer.h:**
-```cpp
-enum class S24PackMode { Unknown, LsbAligned, MsbAligned, Deferred };
-
-void setS24PackModeHint(S24PackMode hint);
-S24PackMode getS24PackMode() const;
-S24PackMode getS24Hint() const;
-
-// New members
-S24PackMode m_s24Hint = S24PackMode::Unknown;
-bool m_s24DetectionConfirmed = false;
-size_t m_deferredSampleCount = 0;
-static constexpr size_t DEFERRED_TIMEOUT_SAMPLES = 48000;
-```
-
-**Detection algorithm:**
-```cpp
-S24PackMode detectS24PackMode(const uint8_t* data, size_t numSamples) {
-    bool allZeroLSB = true, allZeroMSB = true;
-    for (size_t i = 0; i < checkSamples; i++) {
-        if (data[i * 4] != 0x00) allZeroLSB = false;      // LSB position
-        if (data[i * 4 + 3] != 0x00) allZeroMSB = false;  // MSB position
-    }
-
-    if (!allZeroLSB && allZeroMSB) return LsbAligned;  // Data in LSB
-    if (allZeroLSB && !allZeroMSB) return MsbAligned;  // Data in MSB
-    if (allZeroLSB && allZeroMSB) return Deferred;     // Silence
-    return LsbAligned;  // Ambiguous - default to LSB
-}
-```
-
----
-
-## Optimization 2: AVAudioFifo for PCM Overflow
-
-### Problem
-
-The original PCM overflow handling used a manual buffer with `memmove()`:
-- O(n) complexity for shifting remaining samples
-- Memory allocation on overflow
-- Shared buffer between DSD and PCM paths
-
-### Solution
-
-Replaced with FFmpeg's `AVAudioFifo`:
-- O(1) circular buffer operations
-- Pre-allocated at resampler initialization
-- Separate buffers for DSD (packet fragments) and PCM (sample overflow)
-
-### Performance Comparison
-
-| Operation | Before | After |
-|-----------|--------|-------|
-| Read overflow | `memcpy` + `memmove` O(n) | `av_audio_fifo_read` O(1) |
-| Write overflow | `memcpy` + potential realloc | `av_audio_fifo_write` O(1) |
-| Memory pattern | Dynamic resize | Pre-allocated circular |
-
-### Code Changes
-
-**AudioEngine.h:**
-```cpp
-// DSD packet remainder (separate from PCM)
-AudioBuffer m_dsdPacketRemainder;
-size_t m_dsdRemainderCount = 0;
-
-// PCM FIFO for sample overflow
-AVAudioFifo* m_pcmFifo = nullptr;
-```
-
-**FIFO sizing (dynamic based on sample rate):**
-```cpp
-// Scale with sample rate using 64-bit math to avoid overflow
-int fifoSize = static_cast<int>((static_cast<int64_t>(8192) * outputRate) / 48000);
-if (fifoSize < 4096) fifoSize = 4096;      // Minimum
-if (fifoSize > 262144) fifoSize = 262144;  // Maximum
-```
-
-| Sample Rate | FIFO Size |
-|-------------|-----------|
-| 44.1 kHz | 7,529 samples |
-| 48 kHz | 8,192 samples |
-| 96 kHz | 16,384 samples |
-| 192 kHz | 32,768 samples |
-| 384 kHz | 65,536 samples |
-| 768 kHz | 131,072 samples |
-
----
-
-## Optimization 3: PCM Bypass Mode
-
-### Problem
-
-Even when source and output formats match exactly, audio was still processed through SwrContext:
-- Unnecessary CPU overhead
-- Potential for subtle quality degradation
-- No true bit-perfect path
-
-### Solution
-
-Added bypass mode that skips SwrContext entirely when:
-- Sample rates match exactly
-- Channel counts match
-- Format is packed integer (S16 or S32)
-- Bit depth matches (or S32 container with 24-bit content)
-
-**Important:** Float formats are NEVER bypassed - they always require conversion.
-
-### Code Changes
-
-**AudioEngine.h:**
-```cpp
-bool m_bypassMode = false;
-bool m_resamplerInitialized = false;
-
-bool canBypass(uint32_t outputRate, uint32_t outputBits) const;
-```
-
-**Bypass eligibility check:**
-```cpp
-bool AudioDecoder::canBypass(uint32_t outputRate, uint32_t outputBits) const {
-    if (m_trackInfo.isDSD) return false;
-    if (m_codecContext->sample_rate != (int)outputRate) return false;
-    if (m_codecContext->ch_layout.nb_channels != (int)m_trackInfo.channels) return false;
-
-    AVSampleFormat fmt = m_codecContext->sample_fmt;
-    bool isPackedInteger = (fmt == AV_SAMPLE_FMT_S16 || fmt == AV_SAMPLE_FMT_S32);
-    if (!isPackedInteger) return false;
-
-    // Bit depth check...
-    return true;
-}
-```
-
-**Read path with bypass:**
-```cpp
-if (m_bypassMode) {
-    // BYPASS PATH: Direct copy (bit-perfect)
-    memcpy_audio(outputPtr, m_frame->data[0], bytesToCopy);
-} else if (m_swrContext) {
-    // RESAMPLING PATH
-    swr_convert(...);
-} else {
-    // FALLBACK: Direct copy
-    memcpy_audio(outputPtr, m_frame->data[0], bytesToCopy);
-}
-```
-
-### When Bypass is Enabled
-
-| Source | Target | Bypass? |
-|--------|--------|---------|
-| 44.1kHz S16 | 44.1kHz 16-bit | YES |
-| 44.1kHz S32 (24-bit) | 44.1kHz 24-bit | YES |
-| 44.1kHz S32P (planar) | 44.1kHz 24-bit | NO (planar) |
-| 44.1kHz FLTP (float) | 44.1kHz 24-bit | NO (float) |
-| 44.1kHz S16 | 48kHz 16-bit | NO (rate) |
-| 96kHz S32 | 96kHz 24-bit | YES |
-
----
-
-## Optimization 4: S24 Hint Propagation
-
-### Problem
-
-The S24 detection hint from FFmpeg metadata wasn't reaching the ring buffer.
-
-### Solution
-
-Added propagation path: `TrackInfo` → `DirettaRenderer` → `DirettaSync` → `DirettaRingBuffer`
-
-**TrackInfo (AudioEngine.h):**
-```cpp
-enum class S24Alignment { Unknown, LsbAligned, MsbAligned };
-S24Alignment s24Alignment;
-```
-
-**Detection in AudioDecoder::open():**
-```cpp
-if (realBitDepth == 24) {
-    if (codecpar->codec_id == AV_CODEC_ID_PCM_S24LE ||
-        codecpar->codec_id == AV_CODEC_ID_PCM_S24BE) {
-        m_trackInfo.s24Alignment = TrackInfo::S24Alignment::LsbAligned;
-    }
-    else if (codecpar->codec_id == AV_CODEC_ID_FLAC ||
-             codecpar->codec_id == AV_CODEC_ID_ALAC) {
-        m_trackInfo.s24Alignment = TrackInfo::S24Alignment::LsbAligned;
-    }
-    // ...
-}
-```
-
-**Propagation in DirettaRenderer.cpp:**
-```cpp
-if (!format.isDSD && bitDepth == 24 &&
-    trackInfo.s24Alignment != TrackInfo::S24Alignment::Unknown) {
-    DirettaRingBuffer::S24PackMode hint =
-        (trackInfo.s24Alignment == TrackInfo::S24Alignment::LsbAligned)
-            ? DirettaRingBuffer::S24PackMode::LsbAligned
-            : DirettaRingBuffer::S24PackMode::MsbAligned;
-    m_direttaSync->setS24PackModeHint(hint);
-}
-```
-
----
-
-## Files Modified
-
-| File | Lines Changed | Description |
-|------|---------------|-------------|
-| `src/DirettaRingBuffer.h` | ~100 | S24 detection enhancement |
-| `src/DirettaSync.h` | ~10 | `setS24PackModeHint()` method |
-| `src/AudioEngine.h` | ~25 | FIFO, bypass mode, S24Alignment |
-| `src/AudioEngine.cpp` | ~150 | All PCM optimizations |
-| `src/DirettaRenderer.cpp` | ~15 | S24 hint propagation |
-
----
-
-## Preserved Bug Fixes
-
-These optimizations were carefully integrated to preserve existing bug fixes:
-
-1. **FFmpeg ABI Compatibility** (`av_find_best_stream()`) - Preserved
-2. **ARM64 Compilation** (`DIRETTA_HAS_AVX2` guards) - Preserved
-3. **DSD Transition Silence** (`sendPreTransitionSilence()`) - Preserved
-4. **DSD Per-Channel Buffers** (`m_dsdLeftBuffer`, `m_dsdRightBuffer`) - Preserved
-5. **DSD512 Zen3 Warmup** (MTU-aware scaling) - Preserved
-
----
-
-## Testing Recommendations
-
-1. **24-bit with fade-in**: Play 24-bit FLAC starting with silence
-   - Expected: S24 detection uses hint, then confirms with samples
-
-2. **Native rate playback**: Play 44.1kHz file with 44.1kHz target
-   - Expected: Log shows "PCM BYPASS enabled - bit-perfect path"
-
-3. **High-res playback**: Play 192kHz or higher
-   - Expected: Larger FIFO allocated, no overflow issues
-
-4. **Rate conversion**: Play 44.1kHz file with 48kHz target
-   - Expected: Bypass NOT enabled, resampler used
-
-5. **DSD playback**: Play DSD64/128/256/512
-   - Expected: Unchanged behavior, uses separate remainder buffer
diff --git a/docs/2026-01-15-1810-DSD_CONVERSION_OPTIMIZATION.md b/docs/2026-01-15-1810-DSD_CONVERSION_OPTIMIZATION.md
deleted file mode 100644
index 8f2de2b..0000000
--- a/docs/2026-01-15-1810-DSD_CONVERSION_OPTIMIZATION.md
+++ /dev/null
@@ -1,292 +0,0 @@
-# DSD Conversion Function Specialization
-
-**Date:** 2026-01-15
-**Design:** `docs/plans/2026-01-15-dsd-conversion-optimization-design.md`
-**Goal:** Eliminate per-iteration branch overhead in DSD hot path
-
-## Overview
-
-This optimization eliminates runtime branch checks inside the DSD conversion hot loop by pre-selecting specialized conversion functions at track open time. At DSD512 (22.5 MHz), this removes ~176,000 branch predictions per second from the critical path.
-
-## Problem
-
-The original `convertDSDPlanar_AVX2()` function checked two conditions on every 32-byte chunk:
-
-```cpp
-for (; i + 32 <= bytesPerChannel; i += 32) {
-    __m256i left = _mm256_loadu_si256(...);
-    __m256i right = _mm256_loadu_si256(...);
-
-    if (bitReversalTable) {           // Branch #1: checked every iteration
-        left = simd_bit_reverse(left);
-        right = simd_bit_reverse(right);
-    }
-
-    // ... interleave ...
-
-    if (needByteSwap) {               // Branch #2: checked every iteration
-        interleaved_lo = _mm256_shuffle_epi8(interleaved_lo, byteswap_mask);
-        interleaved_hi = _mm256_shuffle_epi8(interleaved_hi, byteswap_mask);
-    }
-
-    // ... store results
-}
-```
-
-**Issues:**
-- These values never change during playback of a track
-- Branch prediction overhead on every iteration
-- Scalar tail had same conditional pattern
-
----
-
-## Solution
-
-### DSD Conversion Modes
-
-Pre-determine conversion mode at track open based on source format and target requirements:
-
-| Mode | Bit Reversal | Byte Swap | Use Case |
-|------|--------------|-----------|----------|
-| `Passthrough` | No | No | DSF→LSB target, DFF→MSB target (fastest) |
-| `BitReverseOnly` | Yes | No | DSF→MSB target, DFF→LSB target |
-| `ByteSwapOnly` | No | Yes | Little-endian targets |
-| `BitReverseAndSwap` | Yes | Yes | Little-endian + bit order mismatch |
-
-### Mode Selection Matrix
-
-| Source | Target Format | Mode |
-|--------|---------------|------|
-| DSF (LSB) | LSB \| BIG | Passthrough |
-| DSF (LSB) | MSB \| BIG | BitReverseOnly |
-| DSF (LSB) | LSB \| LITTLE | ByteSwapOnly |
-| DSF (LSB) | MSB \| LITTLE | BitReverseAndSwap |
-| DFF (MSB) | LSB \| BIG | BitReverseOnly |
-| DFF (MSB) | MSB \| BIG | Passthrough |
-| DFF (MSB) | LSB \| LITTLE | BitReverseAndSwap |
-| DFF (MSB) | MSB \| LITTLE | ByteSwapOnly |
-
----
-
-## Implementation
-
-### 1. Conversion Mode Enum
-
-```cpp
-// DirettaRingBuffer.h
-enum class DSDConversionMode {
-    Passthrough,       // Just interleave (fastest)
-    BitReverseOnly,    // Apply bit reversal only
-    ByteSwapOnly,      // Apply byte swap only
-    BitReverseAndSwap  // Both operations
-};
-```
-
-### 2. Specialized Conversion Functions
-
-Four functions with **no internal branches** in the hot loop:
-
-**Passthrough (fastest):**
-```cpp
-size_t convertDSD_Passthrough(uint8_t* dst, const uint8_t* src,
-                               size_t totalInputBytes, int numChannels) {
-    // ... setup ...
-    for (; i + 32 <= bytesPerChannel; i += 32) {
-        __m256i left = _mm256_loadu_si256(...);
-        __m256i right = _mm256_loadu_si256(...);
-
-        // NO bit reversal - unconditional
-        // NO byte swap - unconditional
-
-        __m256i interleaved_lo = _mm256_unpacklo_epi32(left, right);
-        __m256i interleaved_hi = _mm256_unpackhi_epi32(left, right);
-
-        // ... store ...
-    }
-    // Scalar tail - also no branches
-}
-```
-
-**BitReverse:**
-```cpp
-size_t convertDSD_BitReverse(uint8_t* dst, const uint8_t* src,
-                              size_t totalInputBytes, int numChannels) {
-    for (; i + 32 <= bytesPerChannel; i += 32) {
-        __m256i left = _mm256_loadu_si256(...);
-        __m256i right = _mm256_loadu_si256(...);
-
-        // ALWAYS apply - no check
-        left = simd_bit_reverse(left);
-        right = simd_bit_reverse(right);
-
-        // NO byte swap - unconditional
-        // ... interleave and store ...
-    }
-    // Scalar tail with embedded LUT (no pointer check)
-}
-```
-
-**ByteSwap:**
-```cpp
-size_t convertDSD_ByteSwap(uint8_t* dst, const uint8_t* src,
-                            size_t totalInputBytes, int numChannels) {
-    for (; i + 32 <= bytesPerChannel; i += 32) {
-        // NO bit reversal - unconditional
-        // ...interleave...
-
-        // ALWAYS apply - no check
-        interleaved_lo = _mm256_shuffle_epi8(interleaved_lo, byteswap_mask);
-        interleaved_hi = _mm256_shuffle_epi8(interleaved_hi, byteswap_mask);
-        // ...store...
-    }
-}
-```
-
-**BitReverseAndSwap:**
-```cpp
-size_t convertDSD_BitReverseSwap(uint8_t* dst, const uint8_t* src,
-                                  size_t totalInputBytes, int numChannels) {
-    for (; i + 32 <= bytesPerChannel; i += 32) {
-        // ALWAYS apply both - no checks
-        left = simd_bit_reverse(left);
-        right = simd_bit_reverse(right);
-        // ...interleave...
-        interleaved_lo = _mm256_shuffle_epi8(interleaved_lo, byteswap_mask);
-        interleaved_hi = _mm256_shuffle_epi8(interleaved_hi, byteswap_mask);
-        // ...store...
-    }
-}
-```
-
-### 3. Optimized Push Method
-
-```cpp
-// DirettaRingBuffer.h
-size_t pushDSDPlanarOptimized(const uint8_t* data, size_t inputSize,
-                               int numChannels, DSDConversionMode mode) {
-    // ... setup ...
-    switch (mode) {
-        case DSDConversionMode::Passthrough:
-            stagedBytes = convertDSD_Passthrough(...);
-            break;
-        case DSDConversionMode::BitReverseOnly:
-            stagedBytes = convertDSD_BitReverse(...);
-            break;
-        case DSDConversionMode::ByteSwapOnly:
-            stagedBytes = convertDSD_ByteSwap(...);
-            break;
-        case DSDConversionMode::BitReverseAndSwap:
-            stagedBytes = convertDSD_BitReverseSwap(...);
-            break;
-    }
-    return writeToRing(m_stagingDSD, stagedBytes);
-}
-```
-
-### 4. Mode Selection at Track Open
-
-```cpp
-// DirettaSync.cpp - configureSinkDSD()
-void DirettaSync::configureSinkDSD(uint32_t dsdBitRate, int channels,
-                                    const AudioFormat& format) {
-    bool sourceIsLSB = (format.dsdFormat == AudioFormat::DSDFormat::DSF);
-
-    // Try formats in order of preference...
-    if (checkSinkSupport(LSB | BIG)) {
-        m_needDsdBitReversal = !sourceIsLSB;
-        m_needDsdByteSwap = false;
-        // Set cached conversion mode
-        m_dsdConversionMode = m_needDsdBitReversal
-            ? DSDConversionMode::BitReverseOnly
-            : DSDConversionMode::Passthrough;
-    }
-    // ... other format paths ...
-}
-```
-
-### 5. Usage in sendAudio()
-
-```cpp
-// DirettaSync.cpp
-if (dsdMode) {
-    // Use optimized path with cached mode (no per-iteration branching)
-    written = m_ringBuffer.pushDSDPlanarOptimized(
-        data, totalBytes, numChannels, m_dsdConversionMode);
-}
-```
-
----
-
-## Scalar Fallbacks (ARM64)
-
-Each specialized function includes both AVX2 SIMD (for x86 stereo) and scalar fallbacks:
-
-```cpp
-size_t convertDSD_BitReverse(...) {
-#if DIRETTA_HAS_AVX2
-    if (numChannels == 2) {
-        // AVX2 path with embedded bit reversal
-        // ...
-    }
-#endif
-    // Scalar fallback with embedded LUT
-    static const uint8_t bitReverseLUT[256] = { ... };
-    for (size_t i = 0; i < bytesPerChannel; i += 4) {
-        for (int ch = 0; ch < numChannels; ch++) {
-            dst[outputBytes++] = bitReverseLUT[src[chOffset + i + 0]];
-            // ...
-        }
-    }
-}
-```
-
----
-
-## Performance Analysis
-
-### Branch Elimination
-
-| DSD Rate | Loop Iterations/sec | Branches Eliminated/sec |
-|----------|---------------------|-------------------------|
-| DSD64 | ~11,000 | ~22,000 |
-| DSD128 | ~22,000 | ~44,000 |
-| DSD256 | ~44,000 | ~88,000 |
-| DSD512 | ~88,000 | ~176,000 |
-| DSD1024 | ~176,000 | ~352,000 |
-
-### Expected Improvement
-
-- Branch misprediction: ~15 cycles each (modern x86)
-- Best case (perfect prediction): 1-2 cycles saved per check
-- Worst case (occasional mispredict): 15-30 cycles saved
-- **Estimated: 2-5% CPU reduction in DSD hot path**
-
----
-
-## Files Modified
-
-| File | Lines | Description |
-|------|-------|-------------|
-| `src/DirettaRingBuffer.h` | ~800 | Enum, 4 specialized functions, optimized push |
-| `src/DirettaSync.h` | ~5 | `m_dsdConversionMode` member |
-| `src/DirettaSync.cpp` | ~100 | Mode selection in all sink paths, usage in sendAudio |
-
----
-
-## Testing Recommendations
-
-1. **DSF → LSB target**: Verify Passthrough mode (log shows `mode=0`)
-2. **DSF → MSB target**: Verify BitReverseOnly mode (log shows `mode=1`)
-3. **DFF → LSB target**: Verify BitReverseOnly mode
-4. **DFF → MSB target**: Verify Passthrough mode
-5. **All DSD rates**: Test DSD64/128/256/512 with each mode
-6. **Gapless DSF→DFF**: Verify mode changes at track boundary
-7. **ARM64**: Verify scalar fallback works correctly
-
----
-
-## Related Documents
-
-- **Design Document:** `docs/plans/2026-01-15-dsd-conversion-optimization-design.md`
-- **DSD Buffer Optimization:** `docs/DSD_BUFFER_OPTIMIZATION.md`
-- **PCM Optimization:** `docs/PCM_FIFO_BYPASS_OPTIMIZATION.md`
diff --git a/docs/2026-01-17-1000-TECHNICAL_REVIEW_SIMPLIFICATION.md b/docs/2026-01-17-1000-TECHNICAL_REVIEW_SIMPLIFICATION.md
deleted file mode 100644
index 33f3577..0000000
--- a/docs/2026-01-17-1000-TECHNICAL_REVIEW_SIMPLIFICATION.md
+++ /dev/null
@@ -1,791 +0,0 @@
-# Technical Review: Code Simplification Opportunities
-
-**Date:** 2026-01-17 (Revision 3 - Second Pass)
-**Reviewer:** Claude (Code Review)
-**Codebase:** DirettaRendererUPnP-X
-**Goal:** Identify simplification opportunities to improve code predictability and audio quality
-
----
-
-## Execution Path Analysis
-
-### Hot Path (Continuous During Playback)
-
-```
-┌─ Audio Thread ─────────────────────────────────────────────────────┐
-│                                                                    │
-│  AudioEngine::process()                                            │
-│      └─► AudioDecoder::readSamples()                               │
-│              └─► Audio callback (DirettaRenderer.cpp:154-311)      │
-│                      ├─► m_callbackMutex.lock()      ← SYSCALL!    │
-│                      ├─► Guard destructor            ← SYSCALL!    │
-│                      ├─► Format comparison (6 checks)              │
-│                      └─► DirettaSync::sendAudio()                  │
-│                              ├─► 3 atomic loads (entry checks)     │
-│                              ├─► RingAccessGuard (2 atomics)       │
-│                              ├─► 5 atomic loads (config snapshot)  │
-│                              └─► DirettaRingBuffer::push*()        │
-│                                      └─► writeToRing()             │
-└────────────────────────────────────────────────────────────────────┘
-
-┌─ SDK Thread (Diretta callback) ────────────────────────────────────┐
-│                                                                    │
-│  DirettaSync::getNewStream()                                       │
-│      ├─► RingAccessGuard (2 atomics)                               │
-│      ├─► Multiple atomic loads                                     │
-│      ├─► std::cerr on underrun    ← I/O in hot path!              │
-│      └─► DirettaRingBuffer::pop()                                  │
-└────────────────────────────────────────────────────────────────────┘
-```
-
----
-
-## CRITICAL: Hot Path Issues (NEW in Second Pass)
-
-### C0. **Mutex Lock + Notify in Audio Callback** ⚠️ HIGHEST PRIORITY
-
-**Location:** `DirettaRenderer.cpp:159-172`
-
-**Execution frequency:** **Every audio frame** (thousands/sec)
-
-**Issue:** The audio callback takes a mutex lock and calls `notify_all()` on every single frame:
-
-```cpp
-// Constructor - runs EVERY frame
-{
-    std::lock_guard<std::mutex> lk(m_callbackMutex);
-    m_callbackRunning = true;
-}
-
-// Destructor - runs EVERY frame
-~Guard() {
-    {
-        std::lock_guard<std::mutex> lk(self->m_callbackMutex);
-        self->m_callbackRunning = false;
-    }
-    self->m_callbackCV.notify_all();  // SYSCALL on every frame!
-}
-```
-
-**Impact:**
-- `std::mutex::lock()` = potential syscall (futex on Linux)
-- `notify_all()` = **guaranteed syscall** even with no waiters
-- Memory barriers on every frame
-- This is the **single biggest source of timing variance** in the hot path
-
-**Root cause analysis:** This guard was designed to allow safe shutdown by tracking when callback is running. But the implementation pays the cost on **every frame** instead of only during shutdown.
-
-**Fix options:**
-
-1. **Atomic flag instead of mutex** (recommended):
-```cpp
-// Replace mutex+CV with:
-std::atomic<bool> m_callbackRunning{false};
-
-// In callback:
-m_callbackRunning.store(true, std::memory_order_release);
-// ... work ...
-m_callbackRunning.store(false, std::memory_order_release);
-
-// In shutdown:
-while (m_callbackRunning.load(std::memory_order_acquire)) {
-    std::this_thread::yield();
-}
-```
-
-2. **Lazy notification** - only notify if someone is waiting:
-```cpp
-~Guard() {
-    self->m_callbackRunning.store(false, std::memory_order_release);
-    if (self->m_shutdownRequested.load(std::memory_order_acquire)) {
-        self->m_callbackCV.notify_all();
-    }
-}
-```
-
-**Effort:** Medium | **Risk:** Medium (test shutdown) | **Impact:** **Very High**
-
----
-
-### C1. Modulo Operation in writeToRing
-
-**Location:** `DirettaRingBuffer.h:1071`
-
-**Execution frequency:** Every buffer write
-
-**Issue:** Uses `%` division instead of `&` bitmask:
-```cpp
-size_t newWritePos = (writePos + len) % size;  // Division: 10-20 cycles
-```
-
-**Fix:** `size_t newWritePos = (writePos + len) & mask_;`
-
-**Effort:** Trivial | **Risk:** None | **Impact:** High
-
----
-
-### C2. Excessive Atomic Loads in sendAudio
-
-**Location:** `DirettaSync.cpp:1208-1212`
-
-**Execution frequency:** Every audio frame
-
-**Issue:** 5 atomic loads for values that **never change during playback**:
-```cpp
-bool dsdMode = m_isDsdMode.load(std::memory_order_acquire);
-bool pack24bit = m_need24BitPack.load(std::memory_order_acquire);
-bool upsample16to32 = m_need16To32Upsample.load(std::memory_order_acquire);
-int numChannels = m_channels.load(std::memory_order_acquire);
-int bytesPerSample = m_bytesPerSample.load(std::memory_order_acquire);
-```
-
-These values are set in `open()` and never change until next track.
-
-**Impact:** 5 memory barriers per frame × thousands of frames/sec = significant overhead
-
-**Fix:** Cache these values in a non-atomic struct, update only in `open()`:
-```cpp
-struct PlaybackConfig {
-    bool dsdMode;
-    bool pack24bit;
-    bool upsample16to32;
-    int numChannels;
-    int bytesPerSample;
-};
-// Update atomically once in open(), read freely in sendAudio()
-```
-
-**Effort:** Medium | **Risk:** Low | **Impact:** High
-
----
-
-### C3. Format Comparison on Every Frame
-
-**Location:** `DirettaRenderer.cpp:213-216`
-
-**Execution frequency:** Every audio frame
-
-**Issue:** 6 comparisons run on every frame even though format changes are extremely rare:
-```cpp
-bool formatChanged = (currentSyncFormat.sampleRate != format.sampleRate ||
-                     currentSyncFormat.bitDepth != format.bitDepth ||
-                     currentSyncFormat.channels != format.channels ||
-                     currentSyncFormat.isDSD != format.isDSD);
-```
-
-**Impact:** Low individually, but contributes to branch misprediction and code size.
-
-**Fix:** Only check format when `needsOpen` would be true anyway, or use a single hash/version number:
-```cpp
-// In DirettaSync, maintain a format version
-std::atomic<uint32_t> m_formatVersion{0};
-
-// In callback, just compare versions:
-bool formatChanged = (m_lastFormatVersion != m_direttaSync->getFormatVersion());
-```
-
-**Effort:** Medium | **Risk:** Low | **Impact:** Medium
-
----
-
-### C4. Dual memcpy Dispatch in writeToRing
-
-**Location:** `DirettaRingBuffer.h:1056-1068`
-
-**Execution frequency:** Every buffer write
-
-**Issue:** Branch on size before memcpy:
-```cpp
-if (firstChunk >= 32) {
-    memcpy_audio_fixed(ring + writePos, staged, firstChunk);
-} else if (firstChunk > 0) {
-    std::memcpy(ring + writePos, staged, firstChunk);
-}
-```
-
-**Fix:** Remove branch, use `memcpy_audio_fixed` for all sizes.
-
-**Effort:** Trivial | **Risk:** Low | **Impact:** Medium
-
----
-
-### C5. RingAccessGuard Atomic Operations
-
-**Location:** `DirettaSync.cpp:16-27`
-
-**Execution frequency:** Every sendAudio() and getNewStream() call
-
-**Issue:** Two `fetch_add`/`fetch_sub` with `acq_rel` barriers per function call:
-```cpp
-users_.fetch_add(1, std::memory_order_acq_rel);  // Entry
-// ... work ...
-users_.fetch_sub(1, std::memory_order_acq_rel);  // Exit
-```
-
-**Impact:** Full memory barriers, even though reconfiguration is rare.
-
-**Potential fix:** Use thread-local or per-thread counters, aggregate on reconfiguration. However, this is complex and the current implementation is correct. **Lower priority** than C0-C2.
-
-**Effort:** High | **Risk:** High | **Impact:** Medium
-
----
-
-### C6. I/O on Underrun
-
-**Location:** `DirettaSync.cpp:1386-1387`
-
-**Execution frequency:** Only on underrun (rare, but when it happens, it's bad)
-
-**Issue:** `std::cerr` I/O during underrun:
-```cpp
-std::cerr << "[DirettaSync] UNDERRUN #" << count
-          << " avail=" << avail << " need=" << currentBytesPerBuffer << std::endl;
-```
-
-**Impact:** Underruns are performance problems. Adding I/O (potential syscall, buffering) makes recovery slower.
-
-**Fix:** Increment atomic counter, log asynchronously or at end of playback:
-```cpp
-m_underrunCount.fetch_add(1, std::memory_order_relaxed);
-// Log in stop() or periodically
-```
-
-**Effort:** Low | **Risk:** None | **Impact:** Medium (during underrun recovery)
-
----
-
-### C7. Bit-Reversal LUT Cache Locality
-
-**Location:** `DirettaRingBuffer.h:654, 688, 834, 868`
-
-**Execution frequency:** Every DSD sample
-
-**Issue:** 256-byte LUT defined 4 times inside functions. Should be single class-scope definition.
-
-**Effort:** Medium | **Risk:** Low | **Impact:** Medium (cache)
-
----
-
-### C8. S24 Detection Branch Complexity
-
-**Location:** `DirettaRingBuffer.h:217-234`
-
-**Execution frequency:** Every 24-bit PCM frame (but becomes predictable after confirmation)
-
-**Issue:** Complex 3-way OR condition:
-```cpp
-if (m_s24PackMode == S24PackMode::Unknown || m_s24PackMode == S24PackMode::Deferred ||
-    (m_s24PackMode == m_s24Hint && !m_s24DetectionConfirmed)) {
-```
-
-**Fix:** Simplify to single flag check:
-```cpp
-if (!m_s24DetectionConfirmed) {
-```
-
-**Effort:** Medium | **Risk:** Medium | **Impact:** Low (branch predictor handles it)
-
----
-
-## SECONDARY: Track Initialization Issues
-
-These run once per track and don't affect continuous playback.
-
-### S1. Remove Disabled Code Blocks
-
-**Location:** `DirettaSync.cpp:730-758, 1145-1193`
-
-~65 lines of `#if 0` and unreachable code.
-
----
-
-### S2. Remove Legacy pushDSDPlanar
-
-**Location:** `DirettaRingBuffer.h:290-312` + `convertDSDPlanar_AVX2`
-
-~120 lines of dead code (never called).
-
----
-
-### S3. Consolidate Format Transition Logic
-
-**Location:** `DirettaSync.cpp:335-534`
-
-~200 lines of nested conditionals in `open()`.
-
----
-
-### S4. Consolidate Retry Constants
-
-**Location:** `DirettaSync.cpp` scattered
-
-Magic numbers for retry counts and delays.
-
----
-
-### S5. Remove DSD Diagnostic Code
-
-**Location:** `AudioEngine.cpp:348-390, 666-707`
-
-Packet diagnostics with allocations at track open.
-
----
-
-## Summary: Prioritized by Impact
-
-### CRITICAL (Hot Path) - Ordered by Impact
-
-| Priority | Issue | Location | Frequency | Effort | Impact |
-|----------|-------|----------|-----------|--------|--------|
-| **C0** | **Mutex + notify_all in callback** | Renderer:159 | Every frame | Medium | **VERY HIGH** |
-| **C1** | Modulo in writeToRing | RingBuffer:1071 | Every write | Trivial | High |
-| **C2** | Excessive atomic loads | DirettaSync:1208 | Every frame | Medium | High |
-| **C3** | Format comparison every frame | Renderer:213 | Every frame | Medium | Medium |
-| **C4** | Dual memcpy dispatch | RingBuffer:1056 | Every write | Trivial | Medium |
-| **C5** | RingAccessGuard atomics | DirettaSync:16 | Every call | High | Medium |
-| **C6** | I/O on underrun | DirettaSync:1386 | On underrun | Low | Medium |
-| **C7** | LUT cache locality | RingBuffer | Every DSD sample | Medium | Medium |
-| **C8** | S24 detection branch | RingBuffer:217 | Every 24-bit frame | Medium | Low |
-
-### SECONDARY (Track Init)
-
-| # | Issue | Location | Lines |
-|---|-------|----------|-------|
-| S1 | Disabled code blocks | DirettaSync.cpp | ~65 |
-| S2 | Legacy pushDSDPlanar | RingBuffer | ~120 |
-| S3 | Format transition logic | DirettaSync.cpp | (reorganize) |
-| S4 | Retry constants | DirettaSync.cpp | (clarity) |
-| S5 | DSD diagnostics | AudioEngine.cpp | ~60 |
-
----
-
-## Recommended Implementation Order
-
-### Phase 1: Eliminate Syscalls from Hot Path (Highest Impact)
-```
-C0 (mutex/notify) → Test playback and shutdown
-```
-This single change could have the largest impact on timing consistency.
-
-### Phase 2: Hot Path Quick Wins
-```
-C1 (modulo) → C4 (memcpy branch) → Test playback
-```
-Both are trivial single-line changes.
-
-### Phase 3: Reduce Atomic Operations
-```
-C2 (config snapshot) → C3 (format check) → Test all formats
-```
-Requires caching strategy, moderate effort.
-
-### Phase 4: DSD Optimization
-```
-C7 (LUT locality) → Test DSD playback
-```
-
-### Phase 5: Cleanup
-```
-S1 → S2 → S5 → S3 → S4
-```
-
----
-
-## New Findings Summary (Second Pass)
-
-| # | Finding | Severity | Missed in First Pass Because |
-|---|---------|----------|------------------------------|
-| C0 | Mutex + notify_all every frame | **Critical** | Didn't trace into DirettaRenderer callback |
-| C2 | 5 atomic loads per frame | High | Assumed atomics were necessary |
-| C3 | Format comparison every frame | Medium | Focused on ring buffer, not callback |
-| C5 | RingAccessGuard overhead | Medium | Assumed guard was lightweight |
-| C6 | I/O during underrun | Medium | Didn't consider error paths |
-
----
-
-## Philosophy Confirmation
-
-The second pass strongly confirms the hypothesis that simpler code leads to better audio quality:
-
-1. **Syscalls are the enemy** - The mutex/notify pattern in C0 introduces kernel transitions on every audio frame
-2. **Atomics have hidden costs** - Memory barriers affect CPU pipeline and cache coherency
-3. **Branches accumulate** - Each conditional adds branch prediction pressure
-4. **Hot path should be minimal** - Only the absolutely necessary operations should run on every frame
-
-The most impactful optimization is **C0**: removing the mutex and `notify_all()` from the audio callback hot path.
-
----
-
-## Appendix A: Implementation Details
-
-This appendix provides copy-paste ready code changes for future implementation sessions.
-
----
-
-### A.1 C0: Remove Mutex/notify_all from Audio Callback
-
-**Files to modify:**
-- `src/DirettaRenderer.h`
-- `src/DirettaRenderer.cpp`
-
-**Step 1: Modify DirettaRenderer.h (lines 78-80)**
-
-BEFORE:
-```cpp
-    // Callback synchronization
-    mutable std::mutex m_callbackMutex;
-    std::condition_variable m_callbackCV;
-    bool m_callbackRunning{false};
-```
-
-AFTER:
-```cpp
-    // Callback synchronization (lock-free for hot path)
-    std::atomic<bool> m_callbackRunning{false};
-    std::atomic<bool> m_shutdownRequested{false};
-```
-
-**Step 2: Modify DirettaRenderer.cpp - waitForCallbackComplete() (lines 93-101)**
-
-BEFORE:
-```cpp
-void DirettaRenderer::waitForCallbackComplete() {
-    std::unique_lock<std::mutex> lk(m_callbackMutex);
-    bool completed = m_callbackCV.wait_for(lk, std::chrono::seconds(5),
-        [this]{ return !m_callbackRunning; });
-    if (!completed) {
-        std::cerr << "[DirettaRenderer] CRITICAL: Callback timeout!" << std::endl;
-        m_callbackRunning = false;
-    }
-}
-```
-
-AFTER:
-```cpp
-void DirettaRenderer::waitForCallbackComplete() {
-    m_shutdownRequested.store(true, std::memory_order_release);
-
-    auto start = std::chrono::steady_clock::now();
-    while (m_callbackRunning.load(std::memory_order_acquire)) {
-        std::this_thread::yield();
-        auto elapsed = std::chrono::steady_clock::now() - start;
-        if (elapsed > std::chrono::seconds(5)) {
-            std::cerr << "[DirettaRenderer] CRITICAL: Callback timeout!" << std::endl;
-            break;
-        }
-    }
-
-    m_shutdownRequested.store(false, std::memory_order_release);
-}
-```
-
-**Step 3: Modify audio callback (lines 158-172)**
-
-BEFORE:
-```cpp
-m_audioEngine->setAudioCallback(
-    [this](const AudioBuffer& buffer, size_t samples,
-           uint32_t sampleRate, uint32_t bitDepth, uint32_t channels) -> bool {
-
-        // RAII guard
-        {
-            std::lock_guard<std::mutex> lk(m_callbackMutex);
-            m_callbackRunning = true;
-        }
-        struct Guard {
-            DirettaRenderer* self;
-            ~Guard() {
-                {
-                    std::lock_guard<std::mutex> lk(self->m_callbackMutex);
-                    self->m_callbackRunning = false;
-                }
-                self->m_callbackCV.notify_all();
-            }
-        } guard{this};
-```
-
-AFTER:
-```cpp
-m_audioEngine->setAudioCallback(
-    [this](const AudioBuffer& buffer, size_t samples,
-           uint32_t sampleRate, uint32_t bitDepth, uint32_t channels) -> bool {
-
-        // Check if shutdown requested (avoid work during teardown)
-        if (m_shutdownRequested.load(std::memory_order_acquire)) {
-            return false;
-        }
-
-        // Lightweight atomic flag (no syscalls)
-        m_callbackRunning.store(true, std::memory_order_release);
-        struct Guard {
-            std::atomic<bool>& flag;
-            ~Guard() { flag.store(false, std::memory_order_release); }
-        } guard{m_callbackRunning};
-```
-
-**Testing:** Verify playback works and stop/shutdown completes without hanging.
-
----
-
-### A.2 C1: Fix Modulo Operation in writeToRing
-
-**File:** `src/DirettaRingBuffer.h`
-**Line:** 1071
-
-BEFORE:
-```cpp
-        size_t newWritePos = (writePos + len) % size;
-```
-
-AFTER:
-```cpp
-        size_t newWritePos = (writePos + len) & mask_;
-```
-
-**Note:** `mask_` is already a member variable set to `size_ - 1` in `resize()`.
-
----
-
-### A.3 C2: Cache Atomic Config Values in sendAudio
-
-**File:** `src/DirettaSync.h`
-
-ADD after other member variables (around line 150):
-```cpp
-    // Cached playback config (set in open(), read in sendAudio())
-    // Avoids atomic loads on hot path since these never change during playback
-    struct PlaybackConfig {
-        bool dsdMode = false;
-        bool pack24bit = false;
-        bool upsample16to32 = false;
-        int numChannels = 2;
-        int bytesPerSample = 4;
-    };
-    PlaybackConfig m_playbackConfig;
-    std::atomic<bool> m_configValid{false};  // Set true after open() populates config
-```
-
-**File:** `src/DirettaSync.cpp`
-
-In `open()` function, after setting the atomic values, ADD:
-```cpp
-    // Cache config for hot path (avoid atomic loads in sendAudio)
-    m_playbackConfig.dsdMode = m_isDsdMode.load(std::memory_order_relaxed);
-    m_playbackConfig.pack24bit = m_need24BitPack.load(std::memory_order_relaxed);
-    m_playbackConfig.upsample16to32 = m_need16To32Upsample.load(std::memory_order_relaxed);
-    m_playbackConfig.numChannels = m_channels.load(std::memory_order_relaxed);
-    m_playbackConfig.bytesPerSample = m_bytesPerSample.load(std::memory_order_relaxed);
-    m_configValid.store(true, std::memory_order_release);
-```
-
-In `sendAudio()` (lines 1208-1212), REPLACE:
-```cpp
-    // Snapshot config state
-    bool dsdMode = m_isDsdMode.load(std::memory_order_acquire);
-    bool pack24bit = m_need24BitPack.load(std::memory_order_acquire);
-    bool upsample16to32 = m_need16To32Upsample.load(std::memory_order_acquire);
-    int numChannels = m_channels.load(std::memory_order_acquire);
-    int bytesPerSample = m_bytesPerSample.load(std::memory_order_acquire);
-```
-
-WITH:
-```cpp
-    // Use cached config (single atomic check instead of 5)
-    if (!m_configValid.load(std::memory_order_acquire)) return 0;
-    const auto& cfg = m_playbackConfig;
-    bool dsdMode = cfg.dsdMode;
-    bool pack24bit = cfg.pack24bit;
-    bool upsample16to32 = cfg.upsample16to32;
-    int numChannels = cfg.numChannels;
-    int bytesPerSample = cfg.bytesPerSample;
-```
-
-In `close()` or `stopPlayback()`, ADD:
-```cpp
-    m_configValid.store(false, std::memory_order_release);
-```
-
----
-
-### A.4 C4: Remove Dual memcpy Dispatch
-
-**File:** `src/DirettaRingBuffer.h`
-**Lines:** 1056-1068
-
-BEFORE:
-```cpp
-        if (firstChunk >= 32) {
-            memcpy_audio_fixed(ring + writePos, staged, firstChunk);
-        } else if (firstChunk > 0) {
-            std::memcpy(ring + writePos, staged, firstChunk);
-        }
-
-        size_t secondChunk = len - firstChunk;
-        if (secondChunk > 0) {
-            if (secondChunk >= 32) {
-                memcpy_audio_fixed(ring, staged + firstChunk, secondChunk);
-            } else {
-                std::memcpy(ring, staged + firstChunk, secondChunk);
-            }
-        }
-```
-
-AFTER:
-```cpp
-        if (firstChunk > 0) {
-            memcpy_audio_fixed(ring + writePos, staged, firstChunk);
-        }
-
-        size_t secondChunk = len - firstChunk;
-        if (secondChunk > 0) {
-            memcpy_audio_fixed(ring, staged + firstChunk, secondChunk);
-        }
-```
-
-**Note:** `memcpy_audio_fixed()` in `memcpyfast_audio.h` already handles small sizes correctly (lines 96-114).
-
----
-
-### A.5 C6: Remove I/O on Underrun
-
-**File:** `src/DirettaSync.cpp`
-**Lines:** 1386-1387
-
-BEFORE:
-```cpp
-    // Underrun
-    if (avail < static_cast<size_t>(currentBytesPerBuffer)) {
-        std::cerr << "[DirettaSync] UNDERRUN #" << count
-                  << " avail=" << avail << " need=" << currentBytesPerBuffer << std::endl;
-        std::memset(dest, currentSilenceByte, currentBytesPerBuffer);
-```
-
-AFTER:
-```cpp
-    // Underrun
-    if (avail < static_cast<size_t>(currentBytesPerBuffer)) {
-        m_underrunCount.fetch_add(1, std::memory_order_relaxed);
-        std::memset(dest, currentSilenceByte, currentBytesPerBuffer);
-```
-
-ADD member variable in `DirettaSync.h`:
-```cpp
-    std::atomic<uint32_t> m_underrunCount{0};
-```
-
-ADD logging in `stop()` or `close()`:
-```cpp
-    uint32_t underruns = m_underrunCount.exchange(0, std::memory_order_relaxed);
-    if (underruns > 0) {
-        std::cerr << "[DirettaSync] Session had " << underruns << " underruns" << std::endl;
-    }
-```
-
----
-
-### A.6 C7: Consolidate Bit-Reversal LUT
-
-**File:** `src/DirettaRingBuffer.h`
-
-ADD at class scope (around line 103, after DSDConversionMode enum):
-```cpp
-private:
-    // Single bit-reversal LUT for all DSD conversion functions (cache-friendly)
-    static constexpr uint8_t kBitReverseLUT[256] = {
-        0x00,0x80,0x40,0xC0,0x20,0xA0,0x60,0xE0,0x10,0x90,0x50,0xD0,0x30,0xB0,0x70,0xF0,
-        0x08,0x88,0x48,0xC8,0x28,0xA8,0x68,0xE8,0x18,0x98,0x58,0xD8,0x38,0xB8,0x78,0xF8,
-        0x04,0x84,0x44,0xC4,0x24,0xA4,0x64,0xE4,0x14,0x94,0x54,0xD4,0x34,0xB4,0x74,0xF4,
-        0x0C,0x8C,0x4C,0xCC,0x2C,0xAC,0x6C,0xEC,0x1C,0x9C,0x5C,0xDC,0x3C,0xBC,0x7C,0xFC,
-        0x02,0x82,0x42,0xC2,0x22,0xA2,0x62,0xE2,0x12,0x92,0x52,0xD2,0x32,0xB2,0x72,0xF2,
-        0x0A,0x8A,0x4A,0xCA,0x2A,0xAA,0x6A,0xEA,0x1A,0x9A,0x5A,0xDA,0x3A,0xBA,0x7A,0xFA,
-        0x06,0x86,0x46,0xC6,0x26,0xA6,0x66,0xE6,0x16,0x96,0x56,0xD6,0x36,0xB6,0x76,0xF6,
-        0x0E,0x8E,0x4E,0xCE,0x2E,0xAE,0x6E,0xEE,0x1E,0x9E,0x5E,0xDE,0x3E,0xBE,0x7E,0xFE,
-        0x01,0x81,0x41,0xC1,0x21,0xA1,0x61,0xE1,0x11,0x91,0x51,0xD1,0x31,0xB1,0x71,0xF1,
-        0x09,0x89,0x49,0xC9,0x29,0xA9,0x69,0xE9,0x19,0x99,0x59,0xD9,0x39,0xB9,0x79,0xF9,
-        0x05,0x85,0x45,0xC5,0x25,0xA5,0x65,0xE5,0x15,0x95,0x55,0xD5,0x35,0xB5,0x75,0xF5,
-        0x0D,0x8D,0x4D,0xCD,0x2D,0xAD,0x6D,0xED,0x1D,0x9D,0x5D,0xDD,0x3D,0xBD,0x7D,0xFD,
-        0x03,0x83,0x43,0xC3,0x23,0xA3,0x63,0xE3,0x13,0x93,0x53,0xD3,0x33,0xB3,0x73,0xF3,
-        0x0B,0x8B,0x4B,0xCB,0x2B,0xAB,0x6B,0xEB,0x1B,0x9B,0x5B,0xDB,0x3B,0xBB,0x7B,0xFB,
-        0x07,0x87,0x47,0xC7,0x27,0xA7,0x67,0xE7,0x17,0x97,0x57,0xD7,0x37,0xB7,0x77,0xF7,
-        0x0F,0x8F,0x4F,0xCF,0x2F,0xAF,0x6F,0xEF,0x1F,0x9F,0x5F,0xDF,0x3F,0xBF,0x7F,0xFF
-    };
-```
-
-REMOVE the `static const uint8_t bitReverseLUT[256]` definitions at lines:
-- 654-671 (in `convertDSD_BitReverse` scalar tail)
-- 688-705 (in `convertDSD_BitReverse` scalar fallback)
-- 834-851 (in `convertDSD_BitReverseSwap` scalar tail)
-- 868-885 (in `convertDSD_BitReverseSwap` scalar fallback)
-
-REPLACE all references from `bitReverseLUT[...]` to `kBitReverseLUT[...]`.
-
-**File:** `src/DirettaSync.cpp`
-
-REMOVE lines 47-64 (the unused `bitReverseTable` array) - it's only used by the legacy path.
-
----
-
-### A.7 S1: Remove Disabled Code Blocks
-
-**File:** `src/DirettaSync.cpp`
-
-DELETE `sendPreTransitionSilence()` function body after `return;` (lines ~1150-1193):
-```cpp
-void DirettaSync::sendPreTransitionSilence() {
-    DIRETTA_LOG("sendPreTransitionSilence: DISABLED FOR TESTING");
-    return;
-    // DELETE everything from here to end of function
-}
-```
-
-DELETE `#if 0` block in `reopenForFormatChange()` (lines ~730-758).
-
----
-
-### A.8 S2: Remove Legacy pushDSDPlanar
-
-**File:** `src/DirettaRingBuffer.h`
-
-DELETE function `pushDSDPlanar()` (lines 290-312).
-
-DELETE function `convertDSDPlanar_AVX2()` (lines 903-1002).
-
-DELETE function `convertDSDPlanar_Scalar()` (lines 1077-1112).
-
-**Verification:** Grep for `pushDSDPlanar` - should have zero callers.
-
----
-
-## Appendix B: Testing Checklist
-
-After implementing changes, test the following:
-
-### Basic Playback
-- [ ] PCM 16-bit/44.1kHz (CD quality)
-- [ ] PCM 24-bit/96kHz (high-res)
-- [ ] PCM 24-bit/192kHz
-- [ ] DSD64
-- [ ] DSD128 (if supported by target)
-
-### Format Transitions
-- [ ] PCM → PCM (same rate)
-- [ ] PCM → PCM (different rate)
-- [ ] PCM → DSD
-- [ ] DSD → PCM
-- [ ] DSD → DSD (different rate)
-
-### Shutdown/Control
-- [ ] Stop during playback
-- [ ] Pause/Resume
-- [ ] Seek during playback
-- [ ] Rapid play/stop cycles
-- [ ] Clean shutdown (no hangs)
-
-### Stress Tests
-- [ ] Long playback (1+ hour)
-- [ ] Gapless playback (multiple tracks)
-- [ ] Check for underruns in log
-
----
-
-**End of Report**
diff --git a/docs/2026-01-17-1020-HOT PATH SIMPLIFICATION REPORT.md b/docs/2026-01-17-1020-HOT PATH SIMPLIFICATION REPORT.md
deleted file mode 100644
index 05e1cc7..0000000
--- a/docs/2026-01-17-1020-HOT PATH SIMPLIFICATION REPORT.md	
+++ /dev/null
@@ -1,322 +0,0 @@
-# Hot Path Simplification Report
-
-**Date:** 2026-01-17
-**Version:** Post-implementation
-**Scope:** Audio callback hot path and track initialization code simplification
-
-## Executive Summary
-
-This report documents the systematic simplification of the DirettaRendererUPnP-X codebase, focusing on reducing timing variance in the audio callback hot path. The hypothesis driving this work is that simpler, more predictable code execution leads to better audio quality through reduced jitter.
-
-Seven optimizations were implemented:
-- **5 Critical (Hot Path):** Executed continuously during playback
-- **2 Secondary (Track Initialization):** Executed once per track
-
-Total lines removed: ~200
-Files modified: 5 (`DirettaRingBuffer.h`, `DirettaSync.cpp`, `DirettaSync.h`, `DirettaRenderer.cpp`, `DirettaRenderer.h`)
-
----
-
-## Critical Optimizations (Hot Path)
-
-### C0: Remove Mutex/Notify from Audio Callback
-
-**Problem:**
-The audio callback in `DirettaRenderer.cpp` used a mutex and condition variable for shutdown synchronization:
-```cpp
-// BEFORE - in audio callback (called every ~10ms)
-{
-    std::lock_guard<std::mutex> lock(m_callbackMutex);
-    if (m_callbackShutdown) return false;
-}
-// ... do work ...
-{
-    std::lock_guard<std::mutex> lock(m_callbackMutex);
-    m_callbackComplete = true;
-}
-m_callbackCV.notify_all();  // SYSCALL on every iteration
-```
-
-Each `notify_all()` triggers a kernel syscall, adding ~1-5us of latency variance per audio frame.
-
-**Solution:**
-Replaced with lock-free atomics:
-```cpp
-// AFTER - zero syscalls in hot path
-if (m_shutdownRequested.load(std::memory_order_acquire)) {
-    return false;
-}
-m_callbackRunning.store(true, std::memory_order_release);
-struct Guard {
-    std::atomic<bool>& flag;
-    ~Guard() { flag.store(false, std::memory_order_release); }
-} guard{m_callbackRunning};
-```
-
-Shutdown waiting now uses spin-wait with timeout:
-```cpp
-void DirettaRenderer::waitForCallbackComplete() {
-    m_shutdownRequested.store(true, std::memory_order_release);
-    auto start = std::chrono::steady_clock::now();
-    while (m_callbackRunning.load(std::memory_order_acquire)) {
-        std::this_thread::yield();
-        if (elapsed > std::chrono::seconds(5)) break;  // Safety timeout
-    }
-    m_shutdownRequested.store(false, std::memory_order_release);
-}
-```
-
-**Files Modified:**
-- `DirettaRenderer.h`: Lines 78-79 (replaced mutex/CV members with atomics)
-- `DirettaRenderer.cpp`: `waitForCallbackComplete()`, callback entry guard, removed mutex locks before `stop()` calls
-
-**Impact:** Eliminates 1 syscall per audio frame (~44,100/sec at CD quality)
-
----
-
-### C1: Fix Modulo Operation in writeToRing
-
-**Problem:**
-Ring buffer write position calculation used modulo operator:
-```cpp
-size_t newWritePos = (writePos + len) % size;  // Division instruction
-```
-
-The `%` operator compiles to a division instruction (DIV/IDIV on x86), which has variable latency (20-100 cycles depending on operands).
-
-**Solution:**
-Since buffer size is always power-of-2, use bitmask:
-```cpp
-size_t newWritePos = (writePos + len) & mask_;  // Single AND instruction
-```
-
-**Files Modified:**
-- `DirettaRingBuffer.h`: Line 1013
-
-**Impact:** Reduces instruction latency from 20-100 cycles to 1 cycle
-
----
-
-### C4: Remove Dual Memcpy Dispatch
-
-**Problem:**
-`writeToRing()` had conditional dispatch based on copy type:
-```cpp
-// BEFORE - branch on every call
-if (useFastPath) {
-    memcpy_audio_fixed(ring + writePos, staged, firstChunk);
-} else {
-    memcpy_audio(ring + writePos, staged, firstChunk);
-}
-```
-
-**Solution:**
-Unified to single function with consistent timing:
-```cpp
-// AFTER - no branch
-if (firstChunk > 0) {
-    memcpy_audio_fixed(ring + writePos, staged, firstChunk);
-}
-size_t secondChunk = len - firstChunk;
-if (secondChunk > 0) {
-    memcpy_audio_fixed(ring, staged + firstChunk, secondChunk);
-}
-```
-
-**Files Modified:**
-- `DirettaRingBuffer.h`: Lines 1004-1011
-
-**Impact:** Eliminates branch misprediction (~15-20 cycles when mispredicted)
-
----
-
-### C6: Remove I/O on Underrun
-
-**Problem:**
-Underrun detection triggered `std::cerr` output in the hot path:
-```cpp
-// BEFORE - in getNewStream() hot path
-if (avail < currentBytesPerBuffer) {
-    std::cerr << "[DirettaSync] UNDERRUN..." << std::endl;  // BLOCKING I/O
-    // ...
-}
-```
-
-`std::cerr` can block for milliseconds, causing cascading underruns.
-
-**Solution:**
-Count underruns with atomic, log at session end:
-```cpp
-// AFTER - in getNewStream()
-if (avail < static_cast<size_t>(currentBytesPerBuffer)) {
-    m_underrunCount.fetch_add(1, std::memory_order_relaxed);
-    std::memset(dest, currentSilenceByte, currentBytesPerBuffer);
-    // ...
-}
-
-// In stopPlayback() - cold path
-uint32_t underruns = m_underrunCount.exchange(0, std::memory_order_relaxed);
-if (underruns > 0) {
-    std::cerr << "[DirettaSync] Session had " << underruns << " underrun(s)" << std::endl;
-}
-```
-
-**Files Modified:**
-- `DirettaSync.h`: Line 401 (added `m_underrunCount` atomic)
-- `DirettaSync.cpp`: `getNewStream()` and `stopPlayback()`
-
-**Impact:** Eliminates blocking I/O from hot path entirely
-
----
-
-### C7: Consolidate Bit-Reversal LUT
-
-**Problem:**
-Four identical 256-byte lookup tables were defined in different DSD conversion functions:
-```cpp
-// Each function had its own copy
-static constexpr uint8_t bitReverseLUT[256] = { ... };
-```
-
-Multiple copies can cause cache thrashing if they land in different cache lines.
-
-**Solution:**
-Single class-scope LUT shared by all functions:
-```cpp
-class DirettaRingBuffer {
-public:
-    // Single LUT for all DSD conversion functions (cache-friendly)
-    static constexpr uint8_t kBitReverseLUT[256] = {
-        0x00,0x80,0x40,0xC0,0x20,0xA0,0x60,0xE0,0x10,0x90,0x50,0xD0,0x30,0xB0,0x70,0xF0,
-        // ... full table ...
-    };
-```
-
-**Files Modified:**
-- `DirettaRingBuffer.h`: Lines 113-130 (added class-scope LUT), removed 4 duplicate definitions
-
-**Impact:** Improves cache locality, reduces code size by ~768 bytes
-
----
-
-## Secondary Optimizations (Track Initialization)
-
-### S1: Remove Disabled Code Blocks
-
-**Problem:**
-Dead code remained from previous iterations:
-1. `sendPreTransitionSilence()` had ~45 lines of commented/disabled logic
-2. `reopenForFormatChange()` contained a `#if 0` block (~30 lines)
-
-**Solution:**
-Removed all disabled code. `sendPreTransitionSilence()` now contains only a comment explaining why it's empty:
-```cpp
-void DirettaSync::sendPreTransitionSilence() {
-    // Pre-transition silence disabled - was causing issues during format switching
-    // The stopPlayback() silence mechanism handles this case adequately
-}
-```
-
-**Files Modified:**
-- `DirettaSync.cpp`: `sendPreTransitionSilence()`, `reopenForFormatChange()`
-
-**Impact:** Reduces cognitive load, eliminates ~75 lines of dead code
-
----
-
-### S2: Remove Legacy pushDSDPlanar Path
-
-**Problem:**
-The original DSD conversion path used runtime parameters with per-iteration branching:
-```cpp
-// BEFORE - runtime decisions on every iteration
-size_t pushDSDPlanar(const uint8_t* data, size_t inputSize, int numChannels,
-                     const uint8_t* bitReverseTable, bool byteSwap) {
-    // ...
-    stagedBytes = convertDSDPlanar_AVX2(dst, src, size, ch, bitReverseTable, byteSwap);
-}
-
-size_t convertDSDPlanar_AVX2(..., const uint8_t* bitReversalTable, bool needByteSwap) {
-    // Per-iteration branches:
-    if (bitReversalTable) { ... }  // Branch 1
-    if (needByteSwap) { ... }      // Branch 2
-}
-```
-
-**Solution:**
-Conversion mode is now determined once at track open and cached:
-```cpp
-// At track open (cold path)
-m_dsdConversionMode = DirettaRingBuffer::DSDConversionMode::BitReverseOnly;
-
-// In hot path - mode-selected function, zero branches
-size_t pushDSDPlanarOptimized(data, size, channels, m_dsdConversionMode) {
-    switch (mode) {
-        case Passthrough:      return convertDSD_Passthrough(...);
-        case BitReverseOnly:   return convertDSD_BitReverse(...);
-        case ByteSwapOnly:     return convertDSD_ByteSwap(...);
-        case BitReverseAndSwap: return convertDSD_BitReverseSwap(...);
-    }
-}
-```
-
-Each specialized function has zero internal branches - the operations are unconditional.
-
-**Removed Functions:**
-- `pushDSDPlanar()` - replaced by `pushDSDPlanarOptimized()`
-- `convertDSDPlanar_AVX2()` - replaced by specialized `convertDSD_*` functions
-- `convertDSDPlanar_Scalar()` - replaced by scalar paths in each specialized function
-- `bitReverseTable[256]` in DirettaSync.cpp - now uses `kBitReverseLUT` in ring buffer
-
-**Files Modified:**
-- `DirettaRingBuffer.h`: Removed ~100 lines
-- `DirettaSync.cpp`: Removed ~20 lines (LUT)
-
-**Impact:** Eliminates 2 branches per DSD sample group in hot path
-
----
-
-## Summary of Changes by File
-
-| File | Lines Removed | Lines Added | Net Change |
-|------|---------------|-------------|------------|
-| `DirettaRingBuffer.h` | ~140 | 20 | -120 |
-| `DirettaSync.cpp` | ~95 | 10 | -85 |
-| `DirettaSync.h` | 0 | 2 | +2 |
-| `DirettaRenderer.cpp` | ~25 | 20 | -5 |
-| `DirettaRenderer.h` | 4 | 3 | -1 |
-| **Total** | **~264** | **~55** | **~-209** |
-
----
-
-## Testing Recommendations
-
-### Functional Testing
-- [ ] PCM playback at 44.1kHz, 96kHz, 192kHz, 384kHz
-- [ ] DSD64, DSD128, DSD256, DSD512 playback
-- [ ] Format transitions: PCM→DSD, DSD→PCM, DSD rate changes
-- [ ] Pause/resume functionality
-- [ ] Track-to-track gapless transitions
-- [ ] Underrun recovery (simulate by CPU load)
-
-### Performance Testing
-- [ ] Measure callback timing variance before/after
-- [ ] Verify no new underruns introduced
-- [ ] Check memory usage (should be slightly lower)
-
-### Stress Testing
-- [ ] Extended playback (>1 hour) at various formats
-- [ ] Rapid track skipping
-- [ ] Format change stress test (rapid PCM↔DSD switching)
-
----
-
-## Future Considerations
-
-The following items were identified but not implemented in this pass:
-
-1. **C2: Cache atomic loads in sendAudio()** - 5 atomic loads for values that never change during playback could be cached at track open
-2. **C3: Reduce memory order strength** - Some `memory_order_acquire/release` could potentially be relaxed to `memory_order_relaxed`
-3. **C5: Consider SIMD memcpy for small fixed sizes** - The ~176-byte buffer copies could use explicit SIMD
-
-These are lower priority as their impact is less certain without profiling data.
diff --git a/docs/2026-01-17-1407-TIMING_VARIANCE_OPTIMIZATION_REPORT.md b/docs/2026-01-17-1407-TIMING_VARIANCE_OPTIMIZATION_REPORT.md
deleted file mode 100644
index 029be86..0000000
--- a/docs/2026-01-17-1407-TIMING_VARIANCE_OPTIMIZATION_REPORT.md
+++ /dev/null
@@ -1,302 +0,0 @@
-# Timing Variance Optimization Report
-
-**Date:** 2026-01-17
-**Based on:** [Optimisation Methodology](plans/2026-01-17-Optimisation_Methodology.md) and [Optimisation Opportunities](plans/2026-01-17-Optimisation_Opportunities.md)
-
-## Executive Summary
-
-This optimization pass focused on **reducing timing variance** in the audio hot path rather than raw throughput. The core insight is that in high-resolution audio rendering, consistent timing is more valuable than average-case speed improvements. Jitter in execution time translates to audible artifacts.
-
-All Phase 1 (Quick Wins) and Phase 2 (Moderate Effort) optimizations have been implemented, plus key Phase 3 items.
-
-## Optimization Philosophy
-
-From the methodology document:
-
-> "For audio, consistency matters more than speed. A function that takes 100μs ± 2μs is better than one averaging 80μs with occasional 500μs spikes."
-
-The optimizations target:
-1. **Eliminating per-call overhead** - Move decisions to format-change time
-2. **Reducing atomic operations** - Cache values that rarely change
-3. **Consistent code paths** - Avoid branches with timing variance
-
----
-
-## Implemented Optimizations
-
-### Phase 1: Quick Wins
-
-#### N3: Consolidated Bit Reversal LUT
-
-**Problem:** Duplicate 256-byte lookup tables in AudioEngine.cpp and DirettaRingBuffer.h
-
-**Solution:** AudioEngine now references the shared `DirettaRingBuffer::kBitReverseLUT`
-
-**Files Changed:**
-- `src/AudioEngine.cpp:7` - Added `#include "DirettaRingBuffer.h"`
-- `src/AudioEngine.cpp:711-717` - Replaced local `rev[256]` array with pointer to shared LUT
-
-**Impact:**
-- Single LUT copy in memory → better L1 cache utilization
-- 256 bytes saved in binary size
-- Consistent cache behavior across DSD operations
-
----
-
-#### S4: Consolidated Retry Constants
-
-**Problem:** Magic numbers scattered throughout DirettaSync.cpp for retry counts and delays
-
-**Solution:** Added `DirettaRetry` namespace with named constants
-
-**New Constants (DirettaSync.h:76-98):**
-```cpp
-namespace DirettaRetry {
-    // Connection establishment (DIRETTA::Sync::open)
-    constexpr int OPEN_RETRIES = 3;
-    constexpr int OPEN_DELAY_MS = 500;
-
-    // setSink configuration
-    constexpr int SETSINK_RETRIES_FULL = 20;      // After disconnect
-    constexpr int SETSINK_RETRIES_QUICK = 15;     // Quick reconfigure
-    constexpr int SETSINK_DELAY_FULL_MS = 500;
-    constexpr int SETSINK_DELAY_QUICK_MS = 300;
-
-    // connect() call
-    constexpr int CONNECT_RETRIES = 3;
-    constexpr int CONNECT_DELAY_MS = 500;
-
-    // Format change reopen
-    constexpr int REOPEN_SINK_RETRIES = 10;
-    constexpr int REOPEN_SINK_DELAY_MS = 500;
-}
-```
-
-**Files Changed:**
-- `src/DirettaSync.h:76-98` - Added namespace
-- `src/DirettaSync.cpp:116,119` - OPEN_RETRIES, OPEN_DELAY_MS
-- `src/DirettaSync.cpp:556-557` - SETSINK_RETRIES_*, SETSINK_DELAY_*
-- `src/DirettaSync.cpp:581,584` - CONNECT_RETRIES, CONNECT_DELAY_MS
-- `src/DirettaSync.cpp:733,736` - REOPEN_SINK_RETRIES, REOPEN_SINK_DELAY_MS
-
-**Impact:**
-- Easier tuning of retry behavior
-- Self-documenting code
-- Consistent retry patterns
-
----
-
-#### S5: DSD Diagnostics Compile Flag
-
-**Problem:** Heavy DSD diagnostic code (~45 lines) always compiled, even in production builds
-
-**Solution:** Wrapped in `#ifdef DIRETTA_DSD_DIAGNOSTICS`
-
-**Files Changed:**
-- `src/AudioEngine.cpp:349-393` - Conditional compilation block
-- `Makefile:130-135` - Added `DSD_DIAG=1` build option
-
-**Usage:**
-```bash
-# Normal build (no diagnostics)
-make
-
-# Debug build with DSD diagnostics
-make DSD_DIAG=1
-```
-
-**Impact:**
-- Zero overhead in production builds
-- Eliminates ~45 lines of diagnostic code from hot path
-- Available when needed for debugging
-
----
-
-### Phase 2: Moderate Effort
-
-#### R1+R2: Format Generation Counter
-
-**Problem:** `sendAudio()` loaded 5-6 atomic variables on every call, even though format rarely changes during playback
-
-**Before (per-call in hot path):**
-```cpp
-bool dsdMode = m_isDsdMode.load(std::memory_order_acquire);
-bool pack24bit = m_need24BitPack.load(std::memory_order_acquire);
-bool upsample16to32 = m_need16To32Upsample.load(std::memory_order_acquire);
-int numChannels = m_channels.load(std::memory_order_acquire);
-int bytesPerSample = m_bytesPerSample.load(std::memory_order_acquire);
-// 5 atomic loads × ~10-20ns each = 50-100ns overhead per call
-```
-
-**Solution:** Generation counter pattern - single atomic comparison in common case
-
-**New Members (DirettaSync.h:415-427):**
-```cpp
-// Format generation counter - incremented on ANY format change
-std::atomic<uint32_t> m_formatGeneration{0};
-
-// Cached format values for sendAudio fast path
-uint32_t m_cachedFormatGen{0};
-bool m_cachedDsdMode{false};
-bool m_cachedPack24bit{false};
-bool m_cachedUpsample16to32{false};
-int m_cachedChannels{2};
-int m_cachedBytesPerSample{2};
-DirettaRingBuffer::DSDConversionMode m_cachedDsdConversionMode;
-```
-
-**After (DirettaSync.cpp:1118-1136):**
-```cpp
-// Generation counter optimization: single atomic load vs 5-6 loads
-uint32_t gen = m_formatGeneration.load(std::memory_order_acquire);
-if (gen != m_cachedFormatGen) {
-    // Only reload when format actually changed (rare)
-    m_cachedDsdMode = m_isDsdMode.load(std::memory_order_acquire);
-    // ... load all atomics ...
-    m_cachedFormatGen = gen;
-}
-// Use cached values (no atomic loads in hot path)
-bool dsdMode = m_cachedDsdMode;
-```
-
-**Files Changed:**
-- `src/DirettaSync.h:415-427` - Added generation counter and cached values
-- `src/DirettaSync.cpp:968-969` - Increment in configureRingPCM()
-- `src/DirettaSync.cpp:999-1000` - Increment in configureRingDSD()
-- `src/DirettaSync.cpp:1118-1136` - Generation check in sendAudio()
-- `src/DirettaSync.cpp:1149-1150` - Use cached DSD conversion mode
-
-**Impact:**
-- Hot path: 1 atomic load + comparison (cache hit ~99.9% of time)
-- Cold path: 6 atomic loads (only on format change)
-- Estimated savings: ~200-300ns per sendAudio() call
-- At 44.1kHz/16-bit stereo with 4KB buffers: ~11,000 calls/second → 2-3ms/second saved
-
----
-
-### Phase 3: Significant Effort
-
-#### N1: Direct Write API
-
-**Problem:** Ring buffer push operations always checked for wraparound, even when contiguous space was available
-
-**Solution:** Added direct write API for zero-copy fast path
-
-**New Methods (DirettaRingBuffer.h:186-284):**
-```cpp
-/**
- * Get direct write pointer for zero-copy writes
- * Returns true if contiguous space >= needed available
- */
-bool getDirectWriteRegion(size_t needed, uint8_t*& region, size_t& available);
-
-/**
- * Commit a direct write, advancing the write pointer
- */
-void commitDirectWrite(size_t written);
-
-/**
- * Get staging buffer for format conversion
- */
-uint8_t* getStagingForConversion(int stagingType);
-
-/**
- * Expose staging buffer size
- */
-static constexpr size_t getStagingBufferSize();
-```
-
-**Optimized push() (DirettaRingBuffer.h:293-319):**
-```cpp
-size_t push(const uint8_t* data, size_t len) {
-    // Fast path: try direct write (no wraparound)
-    uint8_t* region;
-    size_t available;
-    if (getDirectWriteRegion(len, region, available)) {
-        memcpy_audio(region, data, len);
-        commitDirectWrite(len);
-        return len;
-    }
-    // Slow path: handle wraparound
-    // ... existing wraparound code ...
-}
-```
-
-**Files Changed:**
-- `src/DirettaRingBuffer.h:186-284` - New API methods
-- `src/DirettaRingBuffer.h:293-319` - Optimized push()
-
-**Impact:**
-- Fast path (common): Single contiguous memcpy, no wraparound check overhead
-- Slow path (rare): Falls back to existing two-chunk copy
-- Wraparound occurs only at buffer boundary (~0.01% of operations)
-
----
-
-#### N4: SIMD memcpy Assessment
-
-**Status:** Evaluated - current implementation optimal
-
-The existing `memcpy_audio_fixed` in `memcpyfast_audio.h` already provides:
-- AVX2 128-byte unrolled loops
-- Overlapping store technique for consistent timing
-- Proper handling of all size ranges (4 bytes to multi-MB)
-
-Template specializations for fixed sizes were considered but deemed unnecessary because:
-1. Actual copy sizes vary at runtime (depend on buffer fill level)
-2. Current AVX2 implementation already eliminates size branching in the hot loop
-3. Marginal benefit (~2-3%) doesn't justify code complexity
-
----
-
-## Files Modified Summary
-
-| File | Changes |
-|------|---------|
-| `src/AudioEngine.cpp` | LUT consolidation, DSD diagnostics flag |
-| `src/DirettaSync.h` | Retry namespace, generation counter, cached format values |
-| `src/DirettaSync.cpp` | Use retry constants, increment generation, use cached values |
-| `src/DirettaRingBuffer.h` | Direct write API, optimized push() |
-| `Makefile` | DSD_DIAG=1 build option |
-
----
-
-## Performance Estimates
-
-| Optimization | Savings per call | Calls/second (44.1kHz) | Total savings |
-|--------------|------------------|------------------------|---------------|
-| Generation counter | ~200-300ns | ~11,000 | 2-3ms/sec |
-| Direct write API | ~50-100ns | ~11,000 | 0.5-1ms/sec |
-| LUT consolidation | L1 cache hit improvement | N/A | Reduced variance |
-| DSD diagnostics removal | ~0 (compile-time) | N/A | Cleaner binary |
-
-**Note:** These are estimates. Actual impact depends on CPU, memory subsystem, and workload.
-
----
-
-## Testing Recommendations
-
-1. **Regression testing:**
-   - PCM playback (16/24/32-bit, various sample rates)
-   - DSD playback (DSF and DFF, DSD64 through DSD512)
-   - Format transitions (PCM↔DSD, rate changes)
-
-2. **Timing variance measurement:**
-   - Profile `sendAudio()` call duration distribution
-   - Look for reduction in outliers, not just average
-
-3. **Cache behavior (if tools available):**
-   - L1 cache miss rate during DSD playback
-   - Should show improvement from LUT consolidation
-
----
-
-## Future Considerations
-
-The following optimizations were identified but deferred:
-
-1. **RingAccessGuard optimization** (R3) - Replace with try-lock or lock-free spinlock
-2. **Raw PCM fast path** (N2) - Bypass format detection for known-format streams
-3. **getNewStream() optimization** - Apply generation counter pattern to worker thread
-
-These require more invasive changes and should be evaluated based on profiling data from the current optimizations.
diff --git a/docs/CLAUDE.md b/docs/CLAUDE.md
deleted file mode 100644
index 94fb77c..0000000
--- a/docs/CLAUDE.md
+++ /dev/null
@@ -1,456 +0,0 @@
-# CLAUDE.md - DirettaRendererUPnP-L Project Brief
-
-## Overview
-
-DirettaRendererUPnP-L is the **low-latency optimized** fork of DirettaRendererUPnP - a native UPnP/DLNA audio renderer that streams high-resolution audio (up to DSD1024/PCM 1536kHz) using the Diretta protocol for bit-perfect playback.
-
-**Key differentiation from upstream (v1.2.1):**
-- Inherits `DIRETTA::Sync` directly (vs `DIRETTA::SyncBuffer`) for finer timing control
-- `getNewStream()` callback (pull model) vs SDK-managed push model
-- Extracted `DirettaRingBuffer` class for lock-free SPSC operations
-- Lock-free audio hot path with `RingAccessGuard` pattern
-- Full format transition control with silence buffers and reopening
-- DSD byte swap support for little-endian targets
-
-**Low-latency optimizations (L variant):**
-- Reduced PCM buffer from ~1s to ~300ms (70% latency reduction)
-- 500µs micro-sleeps vs 10ms blocking sleeps (96% jitter reduction)
-- AVX2/AVX-512 SIMD format conversions (8-32x throughput)
-- Zero heap allocations in audio hot path
-- Power-of-2 ring buffer with bitmask modulo (1 cycle vs 10-20)
-
-## Architecture
-
-```
-┌─────────────────────────────┐
-│  UPnP Control Point         │  (JPlay, BubbleUPnP, Roon, etc.)
-└─────────────┬───────────────┘
-              │ UPnP/DLNA Protocol (HTTP/SOAP/SSDP)
-              ▼
-┌───────────────────────────────────────────────────────────────┐
-│  DirettaRendererUPnP-X                                        │
-│  ┌─────────────────┐  ┌─────────────────┐  ┌───────────────┐  │
-│  │   UPnPDevice    │─▶│ DirettaRenderer │─▶│  AudioEngine  │  │
-│  │ (discovery,     │  │ (orchestrator,  │  │ (FFmpeg       │  │
-│  │  transport)     │  │  threading)     │  │  decode)      │  │
-│  └─────────────────┘  └────────┬────────┘  └───────┬───────┘  │
-│                                │                   │          │
-│                                ▼                   ▼          │
-│                  ┌─────────────────────────────────────────┐  │
-│                  │           DirettaSync                   │  │
-│                  │  ┌───────────────────────────────────┐  │  │
-│                  │  │       DirettaRingBuffer           │  │  │
-│                  │  │  (lock-free SPSC, format conv.)   │  │  │
-│                  │  └───────────────────────────────────┘  │  │
-│                  │              │                          │  │
-│                  │              ▼ getNewStream() callback  │  │
-│                  │  ┌───────────────────────────────────┐  │  │
-│                  │  │      DIRETTA::Sync (SDK)          │  │  │
-│                  │  └───────────────────────────────────┘  │  │
-│                  └─────────────────────────────────────────┘  │
-└───────────────────────────────────────────────────────────────┘
-              │ Diretta Protocol (UDP/Ethernet)
-              ▼
-┌─────────────────────────────┐
-│      Diretta TARGET         │  (Memory Play, GentooPlayer, etc.)
-└─────────────┬───────────────┘
-              ▼
-┌─────────────────────────────┐
-│            DAC              │
-└─────────────────────────────┘
-```
-
-## Key Files
-
-| File | Purpose | Hot Path? |
-|------|---------|-----------|
-| `src/DirettaSync.cpp/h` | Inherits `DIRETTA::Sync`, manages ring buffer, format config | Yes |
-| `src/DirettaRingBuffer.h` | Lock-free SPSC ring buffer with AVX2 format conversion | **Critical** |
-| `src/DirettaRenderer.cpp/h` | Orchestrates playback, UPnP callbacks, threading | Partial |
-| `src/AudioEngine.cpp/h` | FFmpeg decode, format detection, sample reading | No |
-| `src/UPnPDevice.cpp/hpp` | UPnP/DLNA protocol, SSDP discovery, HTTP server | No |
-| `src/ProtocolInfoBuilder.h` | UPnP protocol info generation | No |
-| `src/main.cpp` | CLI parsing, initialization, signal handling | No |
-| `src/memcpyfast_audio.h` | AVX2/AVX-512 optimized memcpy dispatcher | **Critical** |
-| `src/fastmemcpy-avx.c` | C AVX implementation (x86 only) | **Critical** |
-
-## Diretta SDK Reference
-
-**SDK Location:** `../DirettaHostSDK_147_19/` (v1.47.19)
-
-### Key SDK Headers
-
-| Header | Purpose |
-|--------|---------|
-| `Host/Sync.hpp` | Base class `DIRETTA::Sync` - stream transmission, thread modes |
-| `Host/Format.hpp` | `FormatID`, `FormatConfigure` - 64-bit format bitmasks |
-| `Host/Find.hpp` | Target discovery |
-| `Host/Stream.hpp` | `DIRETTA::Stream` data structure |
-| `Host/Profile.hpp` | Transmission profiles |
-| `Host/Connection.hpp` | Base connection class |
-
-### SDK Thread Modes (`DIRETTA::Sync::THRED_MODE`)
-
-```cpp
-CRITICAL = 1       // High priority sending thread
-NOSHORTSLEEP = 2   // Busy loop for short waits
-NOSLEEP4CORE = 4   // Disable busy loop if <4 cores
-OCCUPIED = 16      // Pin thread to CPU
-NOSLEEPFORCE = 2048// Force busy loop
-NOJUMBOFRAME = 8192// Disable jumbo frames
-```
-
-### SDK Format Bitmasks (from `Format.hpp`)
-
-```cpp
-// Channels
-CHA_2 = 0x02  // Stereo
-
-// PCM formats
-FMT_PCM_SIGNED_16 = 0x0200
-FMT_PCM_SIGNED_24 = 0x0400
-FMT_PCM_SIGNED_32 = 0x0800
-
-// DSD formats
-FMT_DSD1 = 0x010000      // DSD 1-bit
-FMT_DSD_LSB = 0x100000   // DSF (LSB first)
-FMT_DSD_MSB = 0x200000   // DFF (MSB first)
-FMT_DSD_LITTLE = 0x400000
-FMT_DSD_BIG = 0x800000
-FMT_DSD_SIZ_32 = 0x02000000  // 32-bit grouping
-
-// Sample rates (multipliers of 44.1k/48k base)
-RAT_44100 = 0x0200_00000000
-RAT_48000 = 0x0400_00000000
-RAT_MP2 = 0x1000_00000000    // 2x (88.2/96k)
-RAT_MP4 = 0x2000_00000000    // 4x (176.4/192k)
-// ... up to RAT_MP4096 for DSD1024
-```
-
-## Audio Hot Path
-
-The following functions are in the critical audio path:
-
-```
-AudioEngine::readSamples()
-    └─▶ DirettaSync::sendAudio()
-            └─▶ RingAccessGuard (atomic increment)
-            └─▶ DirettaRingBuffer::push*() or pushDSDPlanarOptimized()
-                    └─▶ AVX2 format conversion (staging buffer)
-                    └─▶ For DSD: switch(m_dsdConversionMode) - no per-iteration branches
-                    └─▶ memcpy_audio_fixed() to ring
-
-DirettaSync::getNewStream()  [SDK callback, runs in SDK thread]
-    └─▶ DirettaRingBuffer::pop()
-            └─▶ memcpy_audio() to DIRETTA::Stream
-```
-
-### DSD Conversion Mode Selection
-
-Mode is determined once at track open in `configureSinkDSD()`:
-
-| Mode | Bit Reverse | Byte Swap | Use Case |
-|------|-------------|-----------|----------|
-| `Passthrough` | No | No | DSF→LSB target, DFF→MSB target |
-| `BitReverseOnly` | Yes | No | DSF→MSB target, DFF→LSB target |
-| `ByteSwapOnly` | No | Yes | Little-endian targets |
-| `BitReverseAndSwap` | Yes | Yes | Little-endian + bit mismatch |
-
-**Rules for hot path code:**
-- No heap allocations (reuse `m_packet`, `m_frame`, staging buffers)
-- No mutex locks (use atomics via `RingAccessGuard`)
-- Bitmask modulo (power-of-2 buffer size: `pos & mask_`)
-- Predictable branch patterns
-- Use `memcpy_audio()` instead of `std::memcpy`
-- 64-byte alignment for SIMD buffers (`alignas(64)`)
-
-## Lock-Free Patterns
-
-### Ring Buffer Access (readers - `sendAudio()`)
-```cpp
-// From DirettaSync.cpp
-class RingAccessGuard {
-    RingAccessGuard(std::atomic<int>& users, const std::atomic<bool>& reconfiguring)
-        : users_(users), active_(false) {
-        if (reconfiguring.load(std::memory_order_acquire)) return;
-        users_.fetch_add(1, std::memory_order_acq_rel);
-        if (reconfiguring.load(std::memory_order_acquire)) {
-            users_.fetch_sub(1, std::memory_order_acq_rel);
-            return;
-        }
-        active_ = true;
-    }
-    ~RingAccessGuard() {
-        if (active_) users_.fetch_sub(1, std::memory_order_acq_rel);
-    }
-    bool active() const { return active_; }
-};
-```
-
-### Reconfiguration (writer - format changes)
-```cpp
-class ReconfigureGuard {
-    explicit ReconfigureGuard(DirettaSync& sync) : sync_(sync) {
-        sync_.beginReconfigure();  // Sets m_reconfiguring = true, waits for m_ringUsers == 0
-    }
-    ~ReconfigureGuard() { sync_.endReconfigure(); }
-};
-```
-
-## Format Support
-
-| Format | Bit Depth | Sample Rates | Ring Buffer Method | SIMD |
-|--------|-----------|--------------|-------------------|------|
-| PCM | 16-bit | 44.1kHz - 384kHz | `push16To32()` | AVX2 16x |
-| PCM | 24-bit | 44.1kHz - 384kHz | `push24BitPacked()` | AVX2 8x |
-| PCM | 32-bit | 44.1kHz - 384kHz | `push()` | memcpy |
-| DSD | 1-bit | DSD64 - DSD512 | `pushDSDPlanarOptimized()` | AVX2 32x |
-
-### S24 Format Auto-Detection
-
-The ring buffer auto-detects 24-bit sample alignment on first push:
-- **LSB-aligned**: bytes 0-2 contain data (standard S24_LE) → `convert24BitPacked_AVX2()`
-- **MSB-aligned**: bytes 1-3 contain data (S24_32BE-style) → `convert24BitPackedShifted_AVX2()`
-
-### SIMD Format Conversions
-
-All format conversions use 64-byte aligned staging buffers before writing to the ring:
-
-| Conversion | Function | Throughput |
-|------------|----------|------------|
-| 24-bit pack (LSB) | `convert24BitPacked_AVX2()` | 8 samples/instruction |
-| 24-bit pack (MSB) | `convert24BitPackedShifted_AVX2()` | 8 samples/instruction |
-| 16→32 upsample | `convert16To32_AVX2()` | 16 samples/instruction |
-| DSD planar→interleaved | `convertDSD_Passthrough()` | 32 bytes/instruction |
-| DSD bit reversal | `convertDSD_BitReverse()` | 32 bytes/instruction |
-| DSD byte swap | `convertDSD_ByteSwap()` | 32 bytes/instruction |
-| DSD bit reverse + swap | `convertDSD_BitReverseSwap()` | 32 bytes/instruction |
-
-## Buffer Configuration
-
-From `DirettaSync.h` (low-latency tuned):
-
-```cpp
-namespace DirettaBuffer {
-    constexpr float DSD_BUFFER_SECONDS = 0.8f;
-    constexpr float PCM_BUFFER_SECONDS = 0.3f;   // Was 1.0f - 70% latency reduction
-
-    constexpr size_t DSD_PREFILL_MS = 200;
-    constexpr size_t PCM_PREFILL_MS = 30;        // Was 50ms - faster start
-    constexpr size_t PCM_LOWRATE_PREFILL_MS = 100;
-
-    constexpr unsigned int DAC_STABILIZATION_MS = 100;
-    constexpr unsigned int ONLINE_WAIT_MS = 2000;
-    constexpr unsigned int FORMAT_SWITCH_DELAY_MS = 800;
-    constexpr unsigned int POST_ONLINE_SILENCE_BUFFERS = 50;
-
-    constexpr size_t MIN_BUFFER_BYTES = 65536;   // Was 3072000 - allows 300ms at all rates
-    constexpr size_t MAX_BUFFER_BYTES = 16777216; // 16MB
-}
-```
-
-### Flow Control Constants
-
-From `DirettaRenderer.cpp`:
-
-```cpp
-namespace FlowControl {
-    constexpr int MICROSLEEP_US = 500;           // Was 10,000µs (10ms)
-    constexpr int MAX_WAIT_MS = 20;              // Was 500ms
-    constexpr float CRITICAL_BUFFER_LEVEL = 0.10f; // Early-return below 10%
-}
-```
-
-## Performance Summary
-
-| Metric | Before | After | Improvement |
-|--------|--------|-------|-------------|
-| PCM buffer latency | ~1000ms | ~300ms | 70% reduction |
-| Time to first audio | ~50ms prefill | ~30ms prefill | 40% faster |
-| Backpressure max stall | 500ms | 20ms | 96% reduction |
-| Heap allocs per decode | 3-4 | 0 (steady state) | Eliminated |
-| Scheduling granularity | 186ms @44.1k | 46ms @44.1k | 4x finer |
-| Ring buffer modulo | 10-20 cycles | 1 cycle | 10-20x faster |
-| 24-bit conversion | ~1 sample/cycle | ~8 samples/cycle | 8x faster |
-| DSD interleave | ~1 byte/cycle | ~32 bytes/cycle | 32x faster |
-
-## Coding Conventions
-
-- **Language:** C++17
-- **Member prefix:** `m_` for instance members
-- **Constants:** `constexpr` in namespace or `static constexpr` in class
-- **Atomics:** Use `std::memory_order_acquire`/`release` appropriately
-- **Alignment:** `alignas(64)` for cache-line separation on atomics
-- **Indentation:** 4 spaces
-- **Line length:** max 120 characters
-- **Logging format:** `[ComponentName] Message`
-
-### Commit Messages
-
-```
-type: short description
-
-Longer explanation if needed.
-
-Co-Authored-By: Claude <noreply@anthropic.com>
-```
-
-Types: `feat`, `fix`, `perf`, `refactor`, `test`, `chore`, `docs`
-
-## Build & Run
-
-```bash
-# Build (auto-detects architecture)
-make
-
-# Build with specific variant
-make ARCH_NAME=x64-linux-15zen4   # AMD Zen 4
-make ARCH_NAME=x64-linux-15v3     # x64 with AVX2 (most common)
-make ARCH_NAME=aarch64-linux-15   # Raspberry Pi 4 (4KB pages)
-make ARCH_NAME=aarch64-linux-15k16 # Raspberry Pi 5 (16KB pages)
-
-# Production build (disables SDK logging)
-make NOLOG=1
-
-# Clean and rebuild
-make clean && make
-
-# Show build info
-make info
-
-# Run with target selection
-sudo ./bin/DirettaRendererUPnP --list-targets
-sudo ./bin/DirettaRendererUPnP --target 1 --verbose
-```
-
-**Note:** Building requires Linux. macOS builds are not supported due to missing FFmpeg/libupnp compatibility.
-
-## SDK Library Variants
-
-Located in `../DirettaHostSDK_147_19/lib/`:
-
-| Pattern | Description |
-|---------|-------------|
-| `x64-linux-15v2` | x86-64 baseline |
-| `x64-linux-15v3` | x86-64 with AVX2 |
-| `x64-linux-15v4` | x86-64 with AVX-512 |
-| `x64-linux-15zen4` | AMD Zen 4 optimized |
-| `aarch64-linux-15` | ARM64 (4KB pages) |
-| `aarch64-linux-15k16` | ARM64 (16KB pages, Pi 5) |
-| `riscv64-linux-15` | RISC-V 64-bit |
-| `*-musl*` | musl libc variants |
-| `*-nolog` | Logging disabled |
-
-## Dependencies
-
-- **Diretta Host SDK v1.47** - Proprietary (personal use only)
-- **FFmpeg** - libavformat, libavcodec, libavutil, libswresample
-- **libupnp** - UPnP/DLNA implementation
-- **pthread** - Threading
-
-Install on Fedora:
-```bash
-sudo dnf install gcc-c++ make ffmpeg-free-devel libupnp-devel
-```
-
-Install on Ubuntu/Debian:
-```bash
-sudo apt install build-essential libavformat-dev libavcodec-dev libavutil-dev libswresample-dev libupnp-dev
-```
-
-## Current Work & Plans
-
-### Completed
-- [x] Lock-free audio path with `RingAccessGuard`
-- [x] Power-of-2 bitmask modulo in ring buffer (`mask_ = size_ - 1`)
-- [x] Cache-line separated atomics (`alignas(64)`)
-- [x] S24 pack mode auto-detection with hint propagation
-- [x] DSD byte swap for little-endian targets
-- [x] Full format transition with `reopenForFormatChange()`
-- [x] DSD→PCM transition fix (800ms settling for I2S targets)
-- [x] DSD rate change transition fix (full close/reopen)
-- [x] PCM rate change transition fix (full close/reopen with 200ms delay)
-- [x] AVX2 SIMD format conversions (24-bit pack, 16→32, DSD interleave)
-- [x] Low-latency buffer mode (~300ms PCM)
-- [x] 500µs micro-sleep flow control
-- [x] Zero heap allocations in hot path (reusable `m_packet`, `m_frame`)
-- [x] ARM64 compatibility (auto-vectorized `std::memcpy`)
-- [x] Playlist end target release fix
-- [x] UPnP Stop closes Diretta connection properly
-- [x] PCM FIFO with AVAudioFifo (O(1) circular buffer)
-- [x] PCM bypass mode for bit-perfect playback
-- [x] FLAC bypass bug fix (compressed formats never bypass)
-- [x] DSD conversion function specialization (4 modes, no per-iteration branches)
-- [x] Pre-transition silence for DSD format changes
-- [x] DSD512 Zen3 warmup fix (MTU-aware buffer scaling)
-
-### Potential Future Work
-- [ ] AVX-512 format conversions (currently only memcpy uses AVX-512)
-- [ ] ARM NEON hand-optimized format conversions
-- [ ] Multi-producer ring buffer for multiple audio sources
-- [ ] Adaptive prefetch tuning based on cache behavior
-
-## Format Transition Handling
-
-| From | To | Handling | Delay |
-|------|-----|----------|-------|
-| PCM | Same PCM (same rate) | Quick resume (buffer clear) | None |
-| PCM | PCM (rate change) | Full `close()` + fresh `open()` | 200ms |
-| PCM | DSD | `reopenForFormatChange()` | 800ms |
-| DSD | Same DSD (same rate) | Quick resume (buffer clear) | None |
-| DSD | DSD (rate change) | Full `close()` + fresh `open()` | 400ms |
-| **DSD** | **PCM** | **Full `close()` + fresh `open()`** | **800ms** |
-
-**Pre-transition silence:** Before stopping DSD playback, `sendPreTransitionSilence()` sends rate-scaled silence buffers (100 × rate_multiplier) to flush the Diretta pipeline.
-
-## Troubleshooting
-
-| Symptom | Likely Cause | Check |
-|---------|--------------|-------|
-| No audio | Target not running | `--list-targets` |
-| Dropouts | Buffer underrun | Increase buffer, check network |
-| Pink noise (DSD) | Bit reversal wrong | Check DSF vs DFF detection |
-| Gapless gaps | Format change | Expected for sample rate changes |
-| DSD→PCM clicks | I2S target sensitivity | See `PLAN-DSD-PCM-TRANSITION.md` |
-| Target stuck after playlist | Old bug (fixed) | `trackEndCallback` now closes connection |
-
-## Key Constraints
-
-1. **No commercial use** - Diretta SDK is personal use only
-2. **Linux only** - No Windows/macOS support
-3. **Root required** - Network operations need elevated privileges
-4. **Jumbo frames recommended** - 9000+ MTU for hi-res audio
-
-## Working with This Codebase
-
-When modifying this codebase:
-
-1. **Check if hot path** - `DirettaRingBuffer`, `sendAudio()`, `getNewStream()` need extra scrutiny
-2. **Test with DSD** - DSD is more timing-sensitive than PCM
-3. **Verify lock-free** - No mutex in audio path
-4. **Check alignment** - New buffers should be `alignas(64)` if atomics are involved
-5. **Test format transitions** - PCM↔DSD transitions are most problematic
-
-## Reference Documents
-
-| Document | Purpose |
-|----------|---------|
-| `docs/PCM_FIFO_BYPASS_OPTIMIZATION.md` | PCM FIFO, bypass mode, S24 detection |
-| `docs/DSD_CONVERSION_OPTIMIZATION.md` | DSD conversion specialization (4 modes) |
-| `docs/DSD_BUFFER_OPTIMIZATION.md` | DSD buffer pre-allocation, rate-adaptive chunks |
-| `docs/PCM_OPTIMIZATION_CHANGES.md` | Low-latency PCM optimizations, buffer tuning |
-| `docs/SIMD_OPTIMIZATION_CHANGES.md` | AVX2/AVX-512 SIMD, lock-free patterns |
-| `docs/FORK_CHANGES.md` | Detailed diff from original v1.2.1 |
-| `docs/plans/` | Design documents for each optimization |
-| `CHANGELOG.md` | Chronological change history |
-| `README.md` | User documentation |
-| `docs/TROUBLESHOOTING.md` | User troubleshooting guide |
-| `docs/CONFIGURATION.md` | Configuration reference |
-
-## Credits
-
-- Original DirettaRendererUPnP by Dominique COMET (cometdom)
-- MPD Diretta Output Plugin v0.4.0 for `DIRETTA::Sync` API patterns (swissmountainsbear)
-- leeeanh for their brilliant optimisation strategies
-- Diretta Host SDK by Yu Harada
-- Claude Code for refactoring assistance
diff --git a/docs/2026-01-11-1855-CONFIGURATION.md b/docs/CONFIGURATION.md
similarity index 100%
rename from docs/2026-01-11-1855-CONFIGURATION.md
rename to docs/CONFIGURATION.md
diff --git a/docs/plans/2026-01-12-PCM Latency and Jitter Optimization Design.md b/docs/plans/2026-01-12-pcm-latency-jitter-design.md
similarity index 83%
rename from docs/plans/2026-01-12-PCM Latency and Jitter Optimization Design.md
rename to docs/plans/2026-01-12-pcm-latency-jitter-design.md
index b8c4e01..174f073 100644
--- a/docs/plans/2026-01-12-PCM Latency and Jitter Optimization Design.md	
+++ b/docs/plans/2026-01-12-pcm-latency-jitter-design.md
@@ -146,10 +146,10 @@ while (remainingSamples > 0 && retryCount < MAX_RETRIES) {
 
 **Behavior summary:**
 
-| Buffer Level | Backpressure Response               | Max Stall |
-| ------------ | ----------------------------------- | --------- |
-| ≥10%         | Micro-sleep 500µs, up to 40 retries | 20ms      |
-| <10%         | Immediate early-return              | 0ms       |
+| Buffer Level | Backpressure Response | Max Stall |
+|--------------|----------------------|-----------|
+| ≥10% | Micro-sleep 500µs, up to 40 retries | 20ms |
+| <10% | Immediate early-return | 0ms |
 
 **Why 10% threshold?** At 300ms buffer, 10% = 30ms of audio remaining. Early-return ensures `audioThreadFunc` can refill before underrun.
 
@@ -178,11 +178,11 @@ namespace DirettaBuffer {
 
 Note: 24-bit audio uses 4 bytes/sample internally (`AV_SAMPLE_FMT_S32`), not 3 bytes packed.
 
-| Sample Rate | Bit Depth | Internal Bytes/Sample | Bytes/sec | 300ms Buffer  |
-| ----------- | --------- | --------------------- | --------- | ------------- |
-| 44.1kHz     | 16-bit    | 2                     | 176,400   | 52,920 bytes  |
-| 96kHz       | 24-bit    | 4                     | 768,000   | 230,400 bytes |
-| 192kHz      | 32-bit    | 4                     | 1,536,000 | 460,800 bytes |
+| Sample Rate | Bit Depth | Internal Bytes/Sample | Bytes/sec | 300ms Buffer |
+|-------------|-----------|----------------------|-----------|--------------|
+| 44.1kHz | 16-bit | 2 | 176,400 | 52,920 bytes |
+| 96kHz | 24-bit | 4 | 768,000 | 230,400 bytes |
+| 192kHz | 32-bit | 4 | 1,536,000 | 460,800 bytes |
 
 With `PCM_BUFFER_SECONDS = 0.3f` and `MIN_BUFFER_BYTES = 65536`, the buffer achieves ~300ms for most formats. The 64KB floor causes ~370ms at 44.1kHz/16-bit, but higher sample rates are unaffected.
 
@@ -206,22 +206,22 @@ size_t samplesPerCall = isDSD ? 32768 : 2048;  // Was 8192 for PCM
 
 **Files to modify:**
 
-| File                      | Changes                                               |
-| ------------------------- | ----------------------------------------------------- |
-| `src/DirettaSync.h`       | Update buffer constants for low-latency               |
-| `src/DirettaRenderer.cpp` | Change chunk size; implement hybrid flow control      |
-| `src/AudioEngine.h`       | Add `m_packet`, `m_frame`, `m_resampleBuffer` members |
-| `src/AudioEngine.cpp`     | Refactor `readSamples()` to use reusable members      |
+| File | Changes |
+|------|---------|
+| `src/DirettaSync.h` | Update buffer constants for low-latency |
+| `src/DirettaRenderer.cpp` | Change chunk size; implement hybrid flow control |
+| `src/AudioEngine.h` | Add `m_packet`, `m_frame`, `m_resampleBuffer` members |
+| `src/AudioEngine.cpp` | Refactor `readSamples()` to use reusable members |
 
 **Implementation order:**
 
-| Step | Task                            | File                              | Risk       |
-| ---- | ------------------------------- | --------------------------------- | ---------- |
-| 1    | Update buffer constants         | `src/DirettaSync.h`               | Low        |
-| 2    | Change chunk size               | `src/DirettaRenderer.cpp:540`     | Low        |
-| 3    | Hybrid flow control             | `src/DirettaRenderer.cpp:257-269` | Medium     |
-| 4    | Per-call allocation elimination | `src/AudioEngine.cpp`             | Medium     |
-| 5    | Integration test                | -                                 | Validation |
+| Step | Task | File | Risk |
+|------|------|------|------|
+| 1 | Update buffer constants | `src/DirettaSync.h` | Low |
+| 2 | Change chunk size | `src/DirettaRenderer.cpp:540` | Low |
+| 3 | Hybrid flow control | `src/DirettaRenderer.cpp:257-269` | Medium |
+| 4 | Per-call allocation elimination | `src/AudioEngine.cpp` | Medium |
+| 5 | Integration test | - | Validation |
 
 **Testing strategy:**
 - Integration: Playback test, verify no underruns at 300ms buffer
@@ -242,4 +242,4 @@ size_t samplesPerCall = isDSD ? 32768 : 2048;  // Was 8192 for PCM
 - AVX2 micro-optimizations (zero hoist)
 - `memcpy_audio_fixed` for PCM ring writes (covered in memory optimization design)
 - Config file changes
-- Runtime toggle (UPnP/D-Bus)
\ No newline at end of file
+- Runtime toggle (UPnP/D-Bus)
diff --git a/docs/plans/2026-01-12-PCM Latency and Jitter Optimization Implementation Plan.md b/docs/plans/2026-01-12-pcm-latency-jitter-implementation.md
similarity index 93%
rename from docs/plans/2026-01-12-PCM Latency and Jitter Optimization Implementation Plan.md
rename to docs/plans/2026-01-12-pcm-latency-jitter-implementation.md
index ffea96e..e382c19 100644
--- a/docs/plans/2026-01-12-PCM Latency and Jitter Optimization Implementation Plan.md	
+++ b/docs/plans/2026-01-12-pcm-latency-jitter-implementation.md
@@ -484,15 +484,15 @@ EOF
 
 ## Summary
 
-| Task | Description                     | Risk       | Estimated Changes |
-| ---- | ------------------------------- | ---------- | ----------------- |
-| 1    | Buffer constants                | Low        | 3 lines           |
-| 2    | Chunk size                      | Low        | 1 line            |
-| 3    | Hybrid flow control             | Medium     | ~25 lines         |
-| 4    | Add reusable members (header)   | Low        | 3 lines           |
-| 5    | Initialize/cleanup members      | Low        | ~10 lines         |
-| 6    | Eliminate packet/frame allocs   | Medium     | ~15 lines         |
-| 7    | Eliminate resample buffer alloc | Medium     | ~10 lines         |
-| 8    | Integration test                | Validation | 0 lines           |
-
-**Total changes:** ~67 lines across 3 files
\ No newline at end of file
+| Task | Description | Risk | Estimated Changes |
+|------|-------------|------|-------------------|
+| 1 | Buffer constants | Low | 3 lines |
+| 2 | Chunk size | Low | 1 line |
+| 3 | Hybrid flow control | Medium | ~25 lines |
+| 4 | Add reusable members (header) | Low | 3 lines |
+| 5 | Initialize/cleanup members | Low | ~10 lines |
+| 6 | Eliminate packet/frame allocs | Medium | ~15 lines |
+| 7 | Eliminate resample buffer alloc | Medium | ~10 lines |
+| 8 | Integration test | Validation | 0 lines |
+
+**Total changes:** ~67 lines across 3 files
diff --git a/docs/plans/2026-01-15-dsd-conversion-optimization-design.md b/docs/plans/2026-01-15-dsd-conversion-optimization-design.md
deleted file mode 100644
index 8c3ca09..0000000
--- a/docs/plans/2026-01-15-dsd-conversion-optimization-design.md
+++ /dev/null
@@ -1,426 +0,0 @@
-# DSD Conversion Function Specialization Design
-
-**Date:** 2026-01-15
-**Status:** Implemented
-**Goal:** Eliminate per-iteration branch overhead in DSD hot path for improved performance at high DSD rates
-
-## Implementation Summary
-
-**Completed:** 2026-01-15
-
-All phases implemented:
-- Phase 1: `DSDConversionMode` enum added to DirettaRingBuffer.h (lines 104-110)
-- Phase 2-3: Four specialized AVX2 conversion functions (lines 557-896)
-- Phase 4: `pushDSDPlanarOptimized()` method with switch-case dispatch (lines 326-364)
-- Phase 5: Scalar fallbacks embedded in each specialized function
-- Phase 6: DirettaSync integration - mode set in `configureSinkDSD()`, used in `sendAudio()`
-
-**Key changes:**
-- `DirettaSync.cpp`: Each sink format path sets `m_dsdConversionMode`
-- `DirettaSync::sendAudio()`: Uses `pushDSDPlanarOptimized()` with cached mode
-- Hot loop now has zero per-iteration branches for conversion decisions
-
-## Overview
-
-This design implements optimizations to the DSD conversion path, analogous to the PCM bypass optimizations. The primary focus is eliminating conditional branches inside the innermost processing loop by pre-selecting specialized conversion functions at track open time.
-
-## Current Implementation Analysis
-
-### DSD Processing Chain
-
-```
-AudioDecoder::readSamples()     [Raw DSD packet reading]
-    ↓ planar L/R separation
-DirettaSync::sendAudio()        [Receives planar DSD]
-    ↓
-DirettaRingBuffer::pushDSDPlanar()
-    ↓
-convertDSDPlanar_AVX2()         [Hot path - bit reversal, byte swap, interleave]
-    ↓
-writeToRing()                   [Ring buffer write]
-```
-
-### Current Hot Loop (DirettaRingBuffer.h:513-537)
-
-```cpp
-for (; i + 32 <= bytesPerChannel; i += 32) {
-    __m256i left = _mm256_loadu_si256(...);
-    __m256i right = _mm256_loadu_si256(...);
-
-    if (bitReversalTable) {           // Branch #1: checked every iteration
-        left = simd_bit_reverse(left);
-        right = simd_bit_reverse(right);
-    }
-
-    __m256i interleaved_lo = _mm256_unpacklo_epi32(left, right);
-    __m256i interleaved_hi = _mm256_unpackhi_epi32(left, right);
-
-    if (needByteSwap) {               // Branch #2: checked every iteration
-        interleaved_lo = _mm256_shuffle_epi8(interleaved_lo, byteswap_mask);
-        interleaved_hi = _mm256_shuffle_epi8(interleaved_hi, byteswap_mask);
-    }
-
-    // ... store results
-}
-```
-
-### Problem Statement
-
-1. **Per-iteration branches:** `if (bitReversalTable)` and `if (needByteSwap)` are evaluated on every 32-byte chunk
-2. **Branch prediction overhead:** Even with good prediction, this adds cycles in the hottest loop
-3. **DSD512/1024 impact:** At DSD512 (22.5 MHz), this loop runs ~700,000 times/second per channel
-4. **Scalar tail:** Same pattern repeated in scalar fallback (lines 540-575)
-
-### DSD Conversion Modes
-
-| Source Format | Target Endianness | Bit Reversal | Byte Swap | Mode |
-|---------------|-------------------|--------------|-----------|------|
-| DSF (LSB) | LSB target | No | No | **Passthrough** |
-| DSF (LSB) | MSB target | Yes | No | BitReverse |
-| DFF (MSB) | LSB target | Yes | No | BitReverse |
-| DFF (MSB) | MSB target | No | No | **Passthrough** |
-| Any | Little-endian | Maybe | Yes | +ByteSwap |
-
-**Key insight:** The conversion mode is determined at track open and never changes during playback.
-
-## Optimizations
-
-### 1. DSD Conversion Function Specialization
-
-**Problem:** Runtime branch checks inside hot loop for operations that are constant per-track.
-
-**Solution:** Create 4 specialized conversion functions with no internal branches:
-
-```cpp
-enum class DSDConversionMode {
-    Passthrough,       // Just interleave (fastest path)
-    BitReverseOnly,    // DSF→MSB or DFF→LSB
-    ByteSwapOnly,      // Endianness conversion only
-    BitReverseAndSwap  // Both operations
-};
-
-// Specialized functions - NO branches in hot path:
-size_t convertDSD_Passthrough_AVX2(uint8_t* dst, const uint8_t* src,
-                                    size_t totalBytes, int channels);
-size_t convertDSD_BitReverse_AVX2(uint8_t* dst, const uint8_t* src,
-                                   size_t totalBytes, int channels);
-size_t convertDSD_ByteSwap_AVX2(uint8_t* dst, const uint8_t* src,
-                                 size_t totalBytes, int channels);
-size_t convertDSD_BitReverseSwap_AVX2(uint8_t* dst, const uint8_t* src,
-                                       size_t totalBytes, int channels);
-```
-
-**Passthrough implementation (fastest):**
-
-```cpp
-size_t convertDSD_Passthrough_AVX2(uint8_t* dst, const uint8_t* src,
-                                    size_t totalBytes, int channels) {
-    size_t bytesPerChannel = totalBytes / channels;
-    size_t outputBytes = 0;
-
-    if (channels == 2) {
-        const uint8_t* srcL = src;
-        const uint8_t* srcR = src + bytesPerChannel;
-
-        size_t i = 0;
-        for (; i + 32 <= bytesPerChannel; i += 32) {
-            __m256i left = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(srcL + i));
-            __m256i right = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(srcR + i));
-
-            // NO bit reversal check
-            // NO byte swap check
-
-            __m256i interleaved_lo = _mm256_unpacklo_epi32(left, right);
-            __m256i interleaved_hi = _mm256_unpackhi_epi32(left, right);
-
-            __m256i out0 = _mm256_permute2x128_si256(interleaved_lo, interleaved_hi, 0x20);
-            __m256i out1 = _mm256_permute2x128_si256(interleaved_lo, interleaved_hi, 0x31);
-
-            _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + outputBytes), out0);
-            outputBytes += 32;
-            _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + outputBytes), out1);
-            outputBytes += 32;
-        }
-
-        // Scalar tail - also no branches
-        for (; i + 4 <= bytesPerChannel; i += 4) {
-            dst[outputBytes++] = srcL[i + 0];
-            dst[outputBytes++] = srcL[i + 1];
-            dst[outputBytes++] = srcL[i + 2];
-            dst[outputBytes++] = srcL[i + 3];
-            dst[outputBytes++] = srcR[i + 0];
-            dst[outputBytes++] = srcR[i + 1];
-            dst[outputBytes++] = srcR[i + 2];
-            dst[outputBytes++] = srcR[i + 3];
-        }
-    }
-
-    _mm256_zeroupper();
-    return outputBytes;
-}
-```
-
-**BitReverse implementation:**
-
-```cpp
-size_t convertDSD_BitReverse_AVX2(uint8_t* dst, const uint8_t* src,
-                                   size_t totalBytes, int channels) {
-    // Same structure but ALWAYS applies bit reversal - no check
-    // ...
-    for (; i + 32 <= bytesPerChannel; i += 32) {
-        __m256i left = _mm256_loadu_si256(...);
-        __m256i right = _mm256_loadu_si256(...);
-
-        left = simd_bit_reverse(left);   // Always applied
-        right = simd_bit_reverse(right); // Always applied
-
-        // ... interleave and store
-    }
-    // ...
-}
-```
-
-### 2. Conversion Mode Selection at Track Open
-
-**Problem:** Conversion parameters are re-evaluated or passed on every buffer.
-
-**Solution:** Determine mode once at track open, cache in DirettaSync:
-
-```cpp
-// In DirettaSync.h
-class DirettaSync {
-private:
-    DSDConversionMode m_dsdConversionMode = DSDConversionMode::Passthrough;
-
-    // Function pointer for current mode (optional optimization)
-    using DSDConvertFunc = size_t(*)(uint8_t*, const uint8_t*, size_t, int);
-    DSDConvertFunc m_dsdConvertFunc = nullptr;
-
-public:
-    void setDSDConversionMode(DSDConversionMode mode);
-    DSDConversionMode getDSDConversionMode() const { return m_dsdConversionMode; }
-};
-```
-
-**Mode selection in configureSinkDSD():**
-
-```cpp
-void DirettaSync::configureSinkDSD(uint32_t dsdBitRate, int channels,
-                                    const AudioFormat& format) {
-    // ... existing sink configuration ...
-
-    // Determine conversion mode based on source format and target requirements
-    bool sourceIsLSB = (format.dsdFormat == AudioFormat::DSDFormat::DSF);
-    bool targetNeedsMSB = /* query from sink info */;
-    bool targetNeedsSwap = /* query from sink info */;
-
-    bool needBitReverse = (sourceIsLSB != targetNeedsMSB);
-
-    if (!needBitReverse && !targetNeedsSwap) {
-        m_dsdConversionMode = DSDConversionMode::Passthrough;
-    } else if (needBitReverse && !targetNeedsSwap) {
-        m_dsdConversionMode = DSDConversionMode::BitReverseOnly;
-    } else if (!needBitReverse && targetNeedsSwap) {
-        m_dsdConversionMode = DSDConversionMode::ByteSwapOnly;
-    } else {
-        m_dsdConversionMode = DSDConversionMode::BitReverseAndSwap;
-    }
-
-    DIRETTA_LOG("DSD conversion mode: " << static_cast<int>(m_dsdConversionMode));
-}
-```
-
-### 3. Ring Buffer Mode-Aware Push
-
-**Problem:** `pushDSDPlanar()` receives parameters it shouldn't need to evaluate.
-
-**Solution:** New push method that uses pre-selected mode:
-
-```cpp
-// In DirettaRingBuffer.h
-size_t pushDSDPlanarOptimized(const uint8_t* data, size_t inputSize,
-                               int numChannels, DSDConversionMode mode) {
-    if (size_ == 0 || numChannels == 0) return 0;
-
-    size_t maxBytes = std::min(inputSize, STAGING_SIZE);
-    size_t free = getFreeSpace();
-    if (maxBytes > free) maxBytes = free;
-
-    size_t bytesPerChannel = maxBytes / static_cast<size_t>(numChannels);
-    size_t completeGroups = bytesPerChannel / 4;
-    size_t usableInput = completeGroups * 4 * static_cast<size_t>(numChannels);
-    if (usableInput == 0) return 0;
-
-    prefetch_audio_buffer(data, usableInput);
-
-    size_t stagedBytes;
-    switch (mode) {
-        case DSDConversionMode::Passthrough:
-            stagedBytes = convertDSD_Passthrough_AVX2(m_stagingDSD, data,
-                                                       usableInput, numChannels);
-            break;
-        case DSDConversionMode::BitReverseOnly:
-            stagedBytes = convertDSD_BitReverse_AVX2(m_stagingDSD, data,
-                                                      usableInput, numChannels);
-            break;
-        case DSDConversionMode::ByteSwapOnly:
-            stagedBytes = convertDSD_ByteSwap_AVX2(m_stagingDSD, data,
-                                                    usableInput, numChannels);
-            break;
-        case DSDConversionMode::BitReverseAndSwap:
-            stagedBytes = convertDSD_BitReverseSwap_AVX2(m_stagingDSD, data,
-                                                          usableInput, numChannels);
-            break;
-    }
-
-    return writeToRing(m_stagingDSD, stagedBytes);
-}
-```
-
-### 4. Scalar Fallback Specialization (ARM64)
-
-**Problem:** ARM64 uses scalar path which also has per-iteration branches.
-
-**Solution:** Same 4-function specialization for scalar code:
-
-```cpp
-// Scalar versions for ARM64 and other non-AVX2 architectures
-size_t convertDSD_Passthrough_Scalar(uint8_t* dst, const uint8_t* src,
-                                      size_t totalBytes, int channels);
-size_t convertDSD_BitReverse_Scalar(uint8_t* dst, const uint8_t* src,
-                                     size_t totalBytes, int channels);
-size_t convertDSD_ByteSwap_Scalar(uint8_t* dst, const uint8_t* src,
-                                   size_t totalBytes, int channels);
-size_t convertDSD_BitReverseSwap_Scalar(uint8_t* dst, const uint8_t* src,
-                                         size_t totalBytes, int channels);
-```
-
-**Passthrough scalar (no lookup table access):**
-
-```cpp
-size_t convertDSD_Passthrough_Scalar(uint8_t* dst, const uint8_t* src,
-                                      size_t totalBytes, int channels) {
-    size_t bytesPerChannel = totalBytes / channels;
-    size_t outputBytes = 0;
-
-    for (size_t i = 0; i < bytesPerChannel; i += 4) {
-        for (int ch = 0; ch < channels; ch++) {
-            // Direct copy - no bitReversalTable lookup
-            dst[outputBytes++] = src[ch * bytesPerChannel + i + 0];
-            dst[outputBytes++] = src[ch * bytesPerChannel + i + 1];
-            dst[outputBytes++] = src[ch * bytesPerChannel + i + 2];
-            dst[outputBytes++] = src[ch * bytesPerChannel + i + 3];
-        }
-    }
-
-    return outputBytes;
-}
-```
-
-## Integration
-
-**Initialization flow:**
-
-1. `DirettaSync::open()` called with `AudioFormat`
-2. `configureSinkDSD()` queries sink capabilities
-3. Mode determined: `m_dsdConversionMode` set based on source format + sink requirements
-4. `sendAudio()` calls `pushDSDPlanarOptimized()` with cached mode
-5. Ring buffer dispatches to specialized function - no per-iteration checks
-
-**Call site in DirettaSync::sendAudio():**
-
-```cpp
-// Current:
-written = m_ringBuffer.pushDSDPlanar(
-    data, len, channels,
-    m_needDsdBitReversal ? getBitReversalTable() : nullptr,
-    m_needDsdByteSwap);
-
-// Proposed:
-written = m_ringBuffer.pushDSDPlanarOptimized(
-    data, len, channels,
-    m_dsdConversionMode);
-```
-
-## Files Modified
-
-| File | Changes |
-|------|---------|
-| `src/DirettaRingBuffer.h` | Add `DSDConversionMode` enum; add 4 specialized AVX2 functions; add 4 specialized scalar functions; add `pushDSDPlanarOptimized()` method |
-| `src/DirettaSync.h` | Add `m_dsdConversionMode` member; add `setDSDConversionMode()` / `getDSDConversionMode()` |
-| `src/DirettaSync.cpp` | Set conversion mode in `configureSinkDSD()`; update `sendAudio()` to use optimized push |
-
-**Lines of code estimate:**
-- 4 AVX2 functions: ~200 lines (extracted from existing, branches removed)
-- 4 scalar functions: ~120 lines (extracted from existing, branches removed)
-- Mode selection: ~30 lines
-- Integration: ~20 lines
-
-## Edge Cases
-
-| Scenario | Behavior |
-|----------|----------|
-| DSF file → LSB target | Passthrough mode (fastest) |
-| DSF file → MSB target | BitReverseOnly mode |
-| DFF file → LSB target | BitReverseOnly mode |
-| DFF file → MSB target | Passthrough mode (fastest) |
-| Unknown source format | Default to BitReverseOnly (safe) |
-| Mid-stream format change | Re-determine mode on next `open()` |
-| Mono DSD (rare) | Scalar fallback handles any channel count |
-| Gapless DSD transition (same format) | Mode unchanged, no overhead |
-| Gapless DSD transition (DSF→DFF) | Mode re-evaluated at track boundary |
-
-## Risk Assessment
-
-| Risk | Mitigation |
-|------|------------|
-| Code duplication (4 functions) | Extract common setup/teardown; only loop body differs |
-| Wrong mode selected | Validate against current behavior in tests |
-| Regression in existing path | Keep original `pushDSDPlanar()` as fallback |
-| ARM64 scalar performance | Measure before/after; scalar branches cheaper than x86 |
-| Multi-channel DSD (>2ch) | Scalar fallback handles; AVX2 path for stereo only |
-
-## Performance Estimate
-
-**DSD512 (22.5 MHz bit rate):**
-- Bytes per second: 22,579,200 / 8 = 2,822,400 bytes/channel
-- Loop iterations (32 bytes/iter): ~88,200/second per channel
-- Branch checks eliminated: 176,400/second (2 checks × 88,200)
-
-**Expected improvement:**
-- Branch misprediction: ~15 cycles each (modern x86)
-- Best case (perfect prediction): ~1-2 cycles saved per check
-- Worst case (occasional mispredict): 15-30 cycles saved
-- Estimated: 2-5% CPU reduction in DSD hot path
-
-## Testing
-
-1. **Bit-perfect verification:** Compare output of Passthrough vs original with `bitReversalTable=nullptr, byteSwap=false`
-2. **Mode selection:** Verify correct mode logged for DSF and DFF files
-3. **DSD64 through DSD512:** Test all rates with new path
-4. **DSF→MSB target:** Verify BitReverseOnly mode activates
-5. **DFF→LSB target:** Verify BitReverseOnly mode activates
-6. **Gapless DSF→DFF:** Verify mode changes at track boundary
-7. **ARM64 scalar:** Test on Raspberry Pi to verify scalar specialization
-8. **Performance measurement:** Profile CPU usage before/after on DSD512
-
-## Implementation Order
-
-1. **Phase 1:** Add `DSDConversionMode` enum and mode selection logic
-2. **Phase 2:** Implement `convertDSD_Passthrough_AVX2()` (extract from existing)
-3. **Phase 3:** Implement remaining 3 AVX2 specialized functions
-4. **Phase 4:** Add `pushDSDPlanarOptimized()` and wire to DirettaSync
-5. **Phase 5:** Implement 4 scalar specialized functions for ARM64
-6. **Phase 6:** Performance testing and validation
-
-## Appendix: Current Code Locations
-
-| Component | File | Line |
-|-----------|------|------|
-| `convertDSDPlanar_AVX2` | DirettaRingBuffer.h | 491-590 |
-| `convertDSDPlanar_Scalar` | DirettaRingBuffer.h | 665-700 |
-| `pushDSDPlanar` | DirettaRingBuffer.h | 281-303 |
-| `simd_bit_reverse` | DirettaRingBuffer.h | 703-719 |
-| `configureSinkDSD` | DirettaSync.cpp | ~870-920 |
-| `sendAudio` (DSD path) | DirettaSync.cpp | ~1180-1190 |
-| DSD source format detection | AudioEngine.cpp | ~330-350 |
diff --git a/docs/plans/2026-01-17-Optimisation_Methodology.md b/docs/plans/2026-01-17-Optimisation_Methodology.md
deleted file mode 100644
index b6c578c..0000000
--- a/docs/plans/2026-01-17-Optimisation_Methodology.md
+++ /dev/null
@@ -1,187 +0,0 @@
-# Optimisation Methodology
-
-**Date:** 2026-01-17
-**Source:** Analysis of docs/plans/ design documents
-**Context:** Collaboration with high-level expert on audio rendering quality
-
-## Overview
-
-This document captures the optimisation patterns identified in the DirettaRendererUPnP-X codebase improvements. Beyond the two primary techniques (hot path simplification and SIMD/hardware delegation), several additional patterns emerged that contribute to improved audio reproduction quality.
-
-The underlying philosophy: **minimise variance in execution time, not just average execution time**. In audio rendering, jitter (timing variance) directly affects perceived quality.
-
----
-
-## Pattern 1: Memory Allocation Elimination
-
-**Principle:** Pre-allocate objects and reuse them across iterations rather than allocating per-call.
-
-**Examples:**
-- `m_packet` and `m_frame` allocated once in `AudioDecoder::open()`, reused for all reads
-- Staging buffers allocated per-format at track open, reused for all conversions
-- `m_pcmRemainder` vector pre-sized to avoid reallocation during playback
-
-**Rationale:** Memory allocation involves syscalls and has highly variable latency. Pre-allocation moves this cost to the cold path (track open) rather than the hot path (per-sample processing).
-
----
-
-## Pattern 2: Processing Layer Bypass
-
-**Principle:** Skip entire processing stages when the data already matches the target format.
-
-**Examples:**
-- PCM bypass: skip `SwrContext` entirely when input/output formats match
-- Raw PCM mode: bypass `avcodec_send_packet()`/`avcodec_receive_frame()` for uncompressed WAV files
-- S24→S24_P32: request packed format from FFmpeg to avoid unnecessary unpacking/repacking
-
-**Rationale:** The fastest code is code that doesn't run. Format-matching detection at track open allows entire processing stages to be skipped.
-
----
-
-## Pattern 3: Decision Point Relocation
-
-**Principle:** Move format decisions from per-sample (hot path) to per-track (cold path).
-
-**Examples:**
-- DSD conversion mode: determined once at track open, cached in `m_dsdConversionMode`
-- S24 pack mode: detected at track open with metadata hint, not per-iteration detection
-- Function pointer selection: choose specialised function once, call without branching
-
-**Key Insight:** "The conversion mode is determined at track open and never changes during playback."
-
-**Rationale:** Conditional branches have variable timing due to branch prediction. Moving decisions to track open eliminates per-sample branching entirely.
-
----
-
-## Pattern 4: O(1) Data Structures
-
-**Principle:** Replace O(n) operations with O(1) alternatives.
-
-**Examples:**
-- `AVAudioFifo` for circular buffer: O(1) read/write vs `memmove` O(n)
-- Power-of-2 bitmask modulo: `& mask_` (1 cycle) vs `% size_` (20-100 cycles)
-- Ring buffer with separate read/write positions vs shifting array
-
-**Rationale:** O(n) operations have data-dependent timing. O(1) operations execute in constant time regardless of data size.
-
----
-
-## Pattern 5: Timing Variance Reduction
-
-**Principle:** Ensure code paths execute in predictable, consistent time.
-
-**Examples:**
-- Overlapping stores: write fixed iteration count regardless of actual data size
-- Fixed staging buffer size: same cache footprint every iteration
-- Consistent-timing memcpy: identical instruction sequence regardless of length
-- Avoid early-exit optimisations that create timing differences
-
-**Rationale:** Even if an optimisation reduces average time, if it increases variance, it may degrade audio quality. Predictable timing is preferred over faster-but-variable timing.
-
----
-
-## Pattern 6: Cache Locality Optimisation
-
-**Principle:** Keep frequently-accessed data in fast cache levels.
-
-**Examples:**
-- Staging buffers sized to fit L2 cache (~64KB)
-- `alignas(64)` for cache-line separation of read/write positions (prevents false sharing)
-- Single consolidated bit-reversal LUT vs 4 copies in different functions
-- Zen 4-specific prefetch tuning for streaming data
-
-**Rationale:** Cache misses have highly variable latency (L1: ~4 cycles, L2: ~12 cycles, L3: ~40 cycles, RAM: ~200+ cycles). Keeping hot data in cache reduces both latency and variance.
-
----
-
-## Pattern 7: Flow Control Tuning
-
-**Principle:** Adaptive scheduling based on buffer state.
-
-**Examples:**
-- Micro-sleep (500µs) when buffer is healthy vs 10ms blocking when nearly empty
-- Early return on critical buffer levels
-- Adaptive chunk sizing: smaller chunks when buffer is low, larger when healthy
-
-**Rationale:** Aggressive sleeping saves CPU but risks underruns. Adaptive flow control maintains buffer health while minimising CPU usage during steady-state playback.
-
----
-
-## Pattern 8: Direct Write APIs
-
-**Principle:** Eliminate intermediate buffer copies by writing directly to destination.
-
-**Examples:**
-- `getWriteSpan()`/`commitWrite()`: expose ring buffer memory for zero-copy writes
-- `swr_convert()` output directly to FIFO when sample counts align
-- Target: reduce copies from 2-3 to 0-1 for 32-bit WAV playback
-
-**Rationale:** Each memory copy adds latency and cache pressure. Direct writes eliminate intermediate buffers entirely.
-
----
-
-## Pattern 9: Syscall Elimination
-
-**Principle:** Remove kernel transitions from the audio path.
-
-**Examples:**
-- Replace mutex/condition variable with lock-free atomics
-- Count underruns with atomic increment, log at session end (not in hot path)
-- Spin-wait with `std::this_thread::yield()` vs `notify_all()` syscall
-- Deferred I/O: accumulate statistics, write once at session end
-
-**Rationale:** Syscalls involve context switches with highly variable latency (1-10µs typical, but can spike to milliseconds under load). Lock-free primitives keep execution entirely in userspace.
-
----
-
-## Pattern Taxonomy
-
-| Category | Pattern | Primary Benefit |
-|----------|---------|-----------------|
-| **Temporal** | Decision relocation | Eliminates per-sample branching |
-| **Spatial** | Cache locality | Reduces memory access variance |
-| **Structural** | Layer bypass | Eliminates unnecessary processing |
-| **Algorithmic** | O(1) structures | Constant-time operations |
-| **Timing** | Variance reduction | Predictable execution time |
-| **System** | Syscall elimination | Avoids kernel transitions |
-| **Memory** | Allocation elimination | Moves allocation to cold path |
-| **Data Flow** | Direct write APIs | Reduces copy count |
-| **Scheduling** | Flow control tuning | Balances latency vs CPU usage |
-
----
-
-## Application Guidelines
-
-### When to Apply Each Pattern
-
-1. **Memory Allocation Elimination** - Apply to any object created per-iteration in the hot path
-2. **Processing Layer Bypass** - Apply when format detection can identify no-op cases
-3. **Decision Point Relocation** - Apply to any conditional that depends on track-level (not sample-level) data
-4. **O(1) Data Structures** - Apply when data size varies and affects operation count
-5. **Timing Variance Reduction** - Apply to innermost loops where consistency matters most
-6. **Cache Locality Optimisation** - Apply to frequently-accessed data structures
-7. **Flow Control Tuning** - Apply to producer/consumer boundaries
-8. **Direct Write APIs** - Apply when intermediate buffers serve no transformation purpose
-9. **Syscall Elimination** - Apply to any synchronisation or I/O in the hot path
-
-### Measurement Approach
-
-When evaluating optimisations, measure:
-- **Mean latency** - Average execution time
-- **P99 latency** - 99th percentile (captures variance)
-- **Jitter** - Standard deviation of execution time
-- **Cache miss rate** - Via hardware performance counters
-
-An optimisation that reduces mean latency but increases P99 or jitter may degrade audio quality.
-
----
-
-## References
-
-- `docs/plans/2026-01-11-audio-memory-optimization-design.md` - Staging buffers, SIMD conversions
-- `docs/plans/2026-01-12-PCM Latency and Jitter Optimization Design.md` - Allocation elimination, flow control
-- `docs/plans/2026-01-14-resample-memcpy-optimization-design.md` - Direct write path, AVAudioFifo
-- `docs/plans/2026-01-15-pcm-bypass-optimization-design.md` - PCM bypass, S24 detection
-- `docs/plans/2026-01-15-dsd-conversion-optimization-design.md` - Function specialisation
-- `docs/plans/2026-01-16-direct-pcm-fast-path-design.md` - Ring buffer direct write
-- `docs/Hot Path Simplification Report.md` - Implementation summary
diff --git a/docs/plans/2026-01-17-Optimisation_Opportunities.md b/docs/plans/2026-01-17-Optimisation_Opportunities.md
deleted file mode 100644
index 65c3888..0000000
--- a/docs/plans/2026-01-17-Optimisation_Opportunities.md
+++ /dev/null
@@ -1,816 +0,0 @@
-# Optimisation Opportunities
-
-**Date:** 2026-01-17
-**Scope:** Consolidated codebase review and action plan
-**Status:** Analysis complete - ready for implementation planning
-
----
-
-## Executive Summary
-
-This document consolidates findings from:
-1. **Technical Review (Second Pass)** - Hot path analysis with execution frequency mapping
-2. **Pattern-Based Review** - Application of 9 optimisation patterns from Optimisation_Methodology.md
-
-### Implementation Status
-
-| Category | Total Issues | Implemented | Remaining |
-|----------|--------------|-------------|-----------|
-| Critical (Hot Path) | 8 | 5 | 3 |
-| Secondary (Track Init) | 5 | 2 | 3 |
-| New Opportunities | 4 | 0 | 4 |
-
----
-
-## Execution Path Analysis
-
-```
-┌─ Audio Thread ─────────────────────────────────────────────────────┐
-│                                                                    │
-│  AudioEngine::process()                                            │
-│      └─► AudioDecoder::readSamples()                               │
-│              └─► Audio callback (DirettaRenderer.cpp:154-311)      │
-│                      ├─► m_shutdownRequested check  ✓ FIXED        │
-│                      ├─► Atomic guard (no syscall)  ✓ FIXED        │
-│                      ├─► Format comparison (6 checks) ← REMAINING  │
-│                      └─► DirettaSync::sendAudio()                  │
-│                              ├─► RingAccessGuard (2 atomics)       │
-│                              ├─► 5 atomic loads     ← REMAINING    │
-│                              └─► DirettaRingBuffer::push*()        │
-│                                      └─► writeToRing() ✓ FIXED     │
-└────────────────────────────────────────────────────────────────────┘
-
-┌─ SDK Thread (Diretta callback) ────────────────────────────────────┐
-│                                                                    │
-│  DirettaSync::getNewStream()                                       │
-│      ├─► RingAccessGuard (2 atomics)                               │
-│      ├─► Underrun counter (no I/O)  ✓ FIXED                        │
-│      └─► DirettaRingBuffer::pop()                                  │
-└────────────────────────────────────────────────────────────────────┘
-```
-
----
-
-## IMPLEMENTED: Hot Path Simplifications
-
-These items from the Technical Review have been completed (see `Hot Path Simplification Report.md`):
-
-| ID | Issue | Fix Applied |
-|----|-------|-------------|
-| C0 | Mutex + notify_all in callback | Replaced with lock-free atomics |
-| C1 | Modulo in writeToRing | Changed `% size` to `& mask_` |
-| C4 | Dual memcpy dispatch | Unified to single `memcpy_audio_fixed` |
-| C6 | I/O on underrun | Deferred to atomic counter + session-end log |
-| C7 | Bit-reversal LUT duplication | Consolidated to `kBitReverseLUT` |
-| S1 | Disabled code blocks | Removed ~75 lines |
-| S2 | Legacy pushDSDPlanar | Replaced with `pushDSDPlanarOptimized` |
-
----
-
-## REMAINING: Critical Hot Path Issues
-
-### R1: Cache Atomic Loads in sendAudio (was C2)
-
-**Pattern:** #3 (Decision Point Relocation)
-**Location:** `DirettaSync.cpp` sendAudio()
-**Frequency:** Every audio frame
-
-**Issue:** 5 atomic loads for values that never change during playback:
-```cpp
-bool dsdMode = m_isDsdMode.load(std::memory_order_acquire);
-bool pack24bit = m_need24BitPack.load(std::memory_order_acquire);
-bool upsample16to32 = m_need16To32Upsample.load(std::memory_order_acquire);
-int numChannels = m_channels.load(std::memory_order_acquire);
-int bytesPerSample = m_bytesPerSample.load(std::memory_order_acquire);
-```
-
-**Impact:** 5 memory barriers × thousands of frames/sec
-
-**Fix:** Cache in struct at track open (see Appendix A.3)
-
-**Effort:** Medium | **Risk:** Low | **Impact:** High
-
----
-
-### R2: Format Comparison Every Frame (was C3)
-
-**Pattern:** #3 (Decision Point Relocation)
-**Location:** `DirettaRenderer.cpp:213-216`
-**Frequency:** Every audio frame
-
-**Issue:** 4 comparisons on every frame:
-```cpp
-bool formatChanged = (currentSyncFormat.sampleRate != format.sampleRate ||
-                     currentSyncFormat.bitDepth != format.bitDepth ||
-                     currentSyncFormat.channels != format.channels ||
-                     currentSyncFormat.isDSD != format.isDSD);
-```
-
-**Fix:** Use format generation counter - single integer comparison
-
-**Effort:** Medium | **Risk:** Low | **Impact:** Medium
-
----
-
-### R3: RingAccessGuard Atomic Operations (was C5)
-
-**Pattern:** #9 (Syscall Elimination) - partial
-**Location:** `DirettaSync.cpp:16-27`
-**Frequency:** Every sendAudio() and getNewStream() call
-
-**Issue:** Two `fetch_add`/`fetch_sub` with `acq_rel` barriers per function:
-```cpp
-users_.fetch_add(1, std::memory_order_acq_rel);  // Entry
-users_.fetch_sub(1, std::memory_order_acq_rel);  // Exit
-```
-
-**Impact:** Full memory barriers even though reconfiguration is rare.
-
-**Fix:** Consider relaxed memory ordering for statistics, or thread-local counters.
-
-**Effort:** High | **Risk:** High | **Impact:** Medium
-
----
-
-## NEW: Additional Opportunities
-
-### N1: Direct Write API for Ring Buffer
-
-**Pattern:** #8 (Direct Write APIs)
-**Location:** `DirettaRingBuffer.h`
-**Status:** Designed in `2026-01-16-direct-pcm-fast-path-design.md`, not implemented
-
-**Proposed API:**
-```cpp
-struct WriteSpan {
-    uint8_t* ptr;
-    size_t maxBytes;
-};
-
-WriteSpan getWriteSpan() const;
-void commitWrite(size_t bytes);
-```
-
-**Benefit:** Zero-copy writes for 32-bit PCM when contiguous space available.
-
-| Input Format | Current | With Direct Write |
-|--------------|---------|-------------------|
-| S32LE WAV | 1 copy | 0 copies |
-| S16LE | 1 copy | 0 copies |
-
-**Effort:** Medium | **Impact:** High for WAV playback
-
----
-
-### N2: Raw PCM Fast Path (FFmpeg Bypass)
-
-**Pattern:** #2 (Processing Layer Bypass)
-**Location:** `AudioEngine.cpp`
-**Status:** Designed in `2026-01-16-direct-pcm-fast-path-design.md`, not implemented
-
-For uncompressed WAV (PCM_S16LE, PCM_S24LE, PCM_S32LE), bypass FFmpeg decode:
-
-**Current:**
-```
-av_read_frame() → avcodec_send_packet() → avcodec_receive_frame() → AudioBuffer
-```
-
-**Proposed:**
-```
-av_read_frame() → packet.data direct → AudioBuffer
-```
-
-**Benefit:** Eliminates 2 FFmpeg API calls + 1 memcpy per frame for WAV.
-
-**Effort:** High | **Impact:** High for WAV playback
-
----
-
-### N3: Consolidate Duplicate Bit Reversal LUT in AudioEngine
-
-**Pattern:** #6 (Cache Locality)
-**Location:** `AudioEngine.cpp:711-728`
-
-AudioEngine has its own 256-byte bit reversal table, identical to `DirettaRingBuffer::kBitReverseLUT`.
-
-**Fix:** Reference shared LUT:
-```cpp
-const uint8_t* rev = DirettaRingBuffer::kBitReverseLUT;
-```
-
-**Effort:** Trivial | **Impact:** Low (code size, cache)
-
----
-
-### N4: SIMD Memcpy for Fixed Sizes
-
-**Pattern:** #5 (Timing Variance Reduction)
-**Location:** `DirettaRingBuffer.h` writeToRing
-
-The ~176-byte buffer copies (stereo 44.1kHz) could use explicit SIMD for consistent timing:
-
-```cpp
-// For 176-byte stereo frames (11 × 16 bytes)
-inline void memcpy_176(uint8_t* dst, const uint8_t* src) {
-    __m128i* d = reinterpret_cast<__m128i*>(dst);
-    const __m128i* s = reinterpret_cast<const __m128i*>(src);
-    for (int i = 0; i < 11; i++) {
-        _mm_store_si128(d + i, _mm_load_si128(s + i));
-    }
-}
-```
-
-**Effort:** Medium | **Impact:** Low-Medium
-
----
-
-## REMAINING: Secondary (Track Initialization)
-
-### S3: Consolidate Format Transition Logic
-
-**Location:** `DirettaSync.cpp:335-534`
-
-~200 lines of nested conditionals in `open()`. Could be refactored for clarity.
-
-**Effort:** High | **Impact:** Maintainability only
-
----
-
-### S4: Consolidate Retry Constants
-
-**Location:** `DirettaSync.cpp` scattered
-
-Magic numbers for retry counts and delays should be named constants.
-
-**Effort:** Low | **Impact:** Maintainability only
-
----
-
-### S5: Remove DSD Diagnostic Code
-
-**Location:** `AudioEngine.cpp:348-390, 666-707`
-
-Packet diagnostics with allocations at track open. Consider compile-time flag.
-
-**Effort:** Low | **Impact:** Cold path only
-
----
-
-## Implementation Roadmap
-
-### Phase 1: Quick Wins (Trivial/Low effort)
-
-| Item | Effort | Files |
-|------|--------|-------|
-| N3: Consolidate AudioEngine LUT | Trivial | AudioEngine.cpp |
-| S4: Retry constants | Low | DirettaSync.cpp |
-| S5: DSD diagnostics flag | Low | AudioEngine.cpp |
-
-### Phase 2: Moderate Effort
-
-| Item | Effort | Files |
-|------|--------|-------|
-| R1: Cache atomic loads | Medium | DirettaSync.h/cpp |
-| R2: Format generation counter | Medium | DirettaRenderer.cpp, DirettaSync.h |
-
-### Phase 3: Significant Effort
-
-| Item | Effort | Files |
-|------|--------|-------|
-| N1: Direct Write API | Medium | DirettaRingBuffer.h, DirettaSync.cpp |
-| N2: Raw PCM Fast Path | High | AudioEngine.cpp/h |
-| N4: SIMD memcpy | Medium | DirettaRingBuffer.h |
-| R3: RingAccessGuard | High | DirettaSync.cpp |
-
----
-
-## Appendix A: Implementation Details
-
-### A.3 R1: Cache Atomic Config Values in sendAudio
-
-**File:** `src/DirettaSync.h`
-
-ADD after other member variables:
-```cpp
-    // Cached playback config (set in open(), read in sendAudio())
-    struct PlaybackConfig {
-        bool dsdMode = false;
-        bool pack24bit = false;
-        bool upsample16to32 = false;
-        int numChannels = 2;
-        int bytesPerSample = 4;
-    };
-    PlaybackConfig m_playbackConfig;
-    std::atomic<bool> m_configValid{false};
-```
-
-**File:** `src/DirettaSync.cpp`
-
-In `open()`, after setting atomics:
-```cpp
-    // Cache config for hot path
-    m_playbackConfig.dsdMode = m_isDsdMode.load(std::memory_order_relaxed);
-    m_playbackConfig.pack24bit = m_need24BitPack.load(std::memory_order_relaxed);
-    m_playbackConfig.upsample16to32 = m_need16To32Upsample.load(std::memory_order_relaxed);
-    m_playbackConfig.numChannels = m_channels.load(std::memory_order_relaxed);
-    m_playbackConfig.bytesPerSample = m_bytesPerSample.load(std::memory_order_relaxed);
-    m_configValid.store(true, std::memory_order_release);
-```
-
-In `sendAudio()`, REPLACE 5 atomic loads WITH:
-```cpp
-    if (!m_configValid.load(std::memory_order_acquire)) return 0;
-    const auto& cfg = m_playbackConfig;
-    bool dsdMode = cfg.dsdMode;
-    bool pack24bit = cfg.pack24bit;
-    bool upsample16to32 = cfg.upsample16to32;
-    int numChannels = cfg.numChannels;
-    int bytesPerSample = cfg.bytesPerSample;
-```
-
-In `close()` or `stopPlayback()`:
-```cpp
-    m_configValid.store(false, std::memory_order_release);
-```
-
----
-
-### A.4 R2: Format Generation Counter
-
-**File:** `src/DirettaSync.h`
-
-ADD:
-```cpp
-    std::atomic<uint32_t> m_formatGeneration{0};
-```
-
-**File:** `src/DirettaSync.cpp`
-
-In `open()`, after format is configured:
-```cpp
-    m_formatGeneration.fetch_add(1, std::memory_order_release);
-```
-
-**File:** `src/DirettaRenderer.cpp`
-
-ADD member:
-```cpp
-    uint32_t m_lastFormatGeneration{0};
-```
-
-In callback, REPLACE format comparison WITH:
-```cpp
-    uint32_t currentGen = m_direttaSync->getFormatGeneration();
-    bool formatChanged = (m_lastFormatGeneration != currentGen);
-    if (formatChanged) {
-        m_lastFormatGeneration = currentGen;
-        // Handle format change...
-    }
-```
-
----
-
-### A.5 N3: Consolidate AudioEngine LUT
-
-**File:** `src/AudioEngine.cpp`
-
-REPLACE lines 711-728:
-```cpp
-static const uint8_t rev[256] = { ... };
-```
-
-WITH:
-```cpp
-// Use shared LUT from ring buffer
-const uint8_t* rev = DirettaRingBuffer::kBitReverseLUT;
-```
-
-ADD include if needed:
-```cpp
-#include "DirettaRingBuffer.h"
-```
-
----
-
-### A.11 R3: RingAccessGuard Relaxation (High Risk)
-
-**File:** `src/DirettaSync.cpp`
-
-**Current implementation (lines 16-27):**
-```cpp
-class RingAccessGuard {
-public:
-    explicit RingAccessGuard(std::atomic<int>& users, std::atomic<bool>& reconfiguring)
-        : users_(users), reconfiguring_(reconfiguring) {
-        users_.fetch_add(1, std::memory_order_acq_rel);  // Full barrier
-    }
-    ~RingAccessGuard() {
-        users_.fetch_sub(1, std::memory_order_acq_rel);  // Full barrier
-    }
-    bool isReconfiguring() const {
-        return reconfiguring_.load(std::memory_order_acquire);
-    }
-private:
-    std::atomic<int>& users_;
-    std::atomic<bool>& reconfiguring_;
-};
-```
-
-**Option 1: Relaxed entry, release exit (Lower risk)**
-
-The entry barrier is only needed to see prior reconfiguration state. The exit barrier ensures reconfiguration sees completed work.
-
-```cpp
-explicit RingAccessGuard(std::atomic<int>& users, std::atomic<bool>& reconfiguring)
-    : users_(users), reconfiguring_(reconfiguring) {
-    users_.fetch_add(1, std::memory_order_acquire);  // See prior reconfig
-}
-~RingAccessGuard() {
-    users_.fetch_sub(1, std::memory_order_release);  // Make work visible
-}
-```
-
-**Option 2: Thread-local tracking (Higher complexity)**
-
-Track per-thread access, aggregate only during reconfiguration:
-```cpp
-thread_local bool t_inRingAccess = false;
-
-class RingAccessGuard {
-public:
-    explicit RingAccessGuard(DirettaSync& sync) : sync_(sync) {
-        t_inRingAccess = true;
-        std::atomic_thread_fence(std::memory_order_seq_cst);
-    }
-    ~RingAccessGuard() {
-        std::atomic_thread_fence(std::memory_order_seq_cst);
-        t_inRingAccess = false;
-    }
-    // ...
-};
-
-// In beginReconfigure():
-void DirettaSync::beginReconfigure() {
-    m_reconfiguring.store(true, std::memory_order_seq_cst);
-    // Spin until no thread is in access
-    while (anyThreadInAccess()) {
-        std::this_thread::yield();
-    }
-}
-```
-
-**Recommendation:** Start with Option 1 (lower risk). Only pursue Option 2 if profiling shows Option 1 insufficient.
-
-**Testing required:** Stress test format transitions (DSD↔PCM) while playing to verify no corruption.
-
----
-
-### A.6 N1: Direct Write API for Ring Buffer
-
-**File:** `src/DirettaRingBuffer.h`
-
-ADD struct and methods (around line 100, in public section):
-```cpp
-public:
-    /**
-     * @brief Contiguous write region for zero-copy writes
-     */
-    struct WriteSpan {
-        uint8_t* ptr;       // Pointer to write location (nullptr if no space)
-        size_t maxBytes;    // Contiguous bytes available (up to wrap point)
-    };
-
-    /**
-     * @brief Get contiguous writable region without wrap-around
-     *
-     * Returns a span where the caller can write directly. The span ends
-     * at either the buffer wrap point or the read position, whichever is closer.
-     * After writing, call commitWrite() to advance the write pointer.
-     */
-    WriteSpan getWriteSpan() const {
-        if (size_ == 0) return { nullptr, 0 };
-
-        size_t wp = writePos_.load(std::memory_order_acquire);
-        size_t rp = readPos_.load(std::memory_order_acquire);
-
-        // Total free space (leave 1 byte to distinguish full from empty)
-        size_t totalFree = (rp - wp - 1) & mask_;
-        if (totalFree == 0) return { nullptr, 0 };
-
-        // Contiguous space from write position to end of buffer
-        size_t toEnd = size_ - wp;
-
-        // Return the smaller of contiguous space or total free space
-        size_t contiguous = std::min(toEnd, totalFree);
-
-        return { buffer_.data() + wp, contiguous };
-    }
-
-    /**
-     * @brief Commit bytes after direct write
-     *
-     * Call this after writing to the span returned by getWriteSpan().
-     * Only call with bytes <= the maxBytes returned by getWriteSpan().
-     */
-    void commitWrite(size_t bytes) {
-        if (bytes == 0) return;
-        size_t wp = writePos_.load(std::memory_order_relaxed);
-        writePos_.store((wp + bytes) & mask_, std::memory_order_release);
-    }
-```
-
-**File:** `src/DirettaSync.cpp`
-
-In `sendAudio()`, ADD fast path before existing conversion logic:
-```cpp
-size_t DirettaSync::sendAudio(const uint8_t* data, size_t numSamples) {
-    // ... existing entry checks ...
-
-    // Fast path: 32-bit PCM with no conversion needed
-    if (!cfg.dsdMode && !cfg.pack24bit && !cfg.upsample16to32) {
-        size_t inputBytes = numSamples * cfg.bytesPerSample * cfg.numChannels;
-
-        auto span = m_ringBuffer.getWriteSpan();
-        if (span.maxBytes > 0) {
-            size_t toCopy = std::min(inputBytes, span.maxBytes);
-            // Align to frame boundary
-            size_t frameSize = cfg.bytesPerSample * cfg.numChannels;
-            toCopy = (toCopy / frameSize) * frameSize;
-
-            if (toCopy > 0) {
-                memcpy_audio_fixed(span.ptr, data, toCopy);
-                m_ringBuffer.commitWrite(toCopy);
-                return toCopy;
-            }
-        }
-
-        // Fall back to push() if contiguous space unavailable
-        return m_ringBuffer.push(data, inputBytes);
-    }
-
-    // ... existing conversion paths ...
-}
-```
-
----
-
-### A.7 N2: Raw PCM Fast Path (FFmpeg Bypass)
-
-**Note:** Full implementation is in `docs/plans/2026-01-16-direct-pcm-fast-path-design.md`
-
-**File:** `src/AudioEngine.h` (in AudioDecoder class)
-
-ADD member variables:
-```cpp
-private:
-    // Raw PCM mode (WAV direct read without FFmpeg decode)
-    bool m_rawPCM = false;
-    int m_pcmPackedBits = 0;              // 24 if S24LE (3-byte packed), else 0
-    std::vector<uint8_t> m_pcmRemainder;  // Partial packet buffer
-    size_t m_pcmRemainderCount = 0;
-```
-
-**File:** `src/AudioEngine.cpp`
-
-In `AudioDecoder::open()`, ADD detection before codec open:
-```cpp
-    // Detect raw PCM codecs - bypass FFmpeg decode
-    bool isRawPCM = (
-        codecpar->codec_id == AV_CODEC_ID_PCM_S16LE ||
-        codecpar->codec_id == AV_CODEC_ID_PCM_S24LE ||
-        codecpar->codec_id == AV_CODEC_ID_PCM_S32LE
-    );
-
-    if (isRawPCM) {
-        m_rawPCM = true;
-        m_pcmPackedBits = (codecpar->codec_id == AV_CODEC_ID_PCM_S24LE) ? 24 : 0;
-
-        // Extract format info from codecpar (don't need codec context)
-        m_trackInfo.sampleRate = codecpar->sample_rate;
-        m_trackInfo.channels = codecpar->ch_layout.nb_channels;
-        m_trackInfo.bitDepth = (codecpar->codec_id == AV_CODEC_ID_PCM_S16LE) ? 16 :
-                               (codecpar->codec_id == AV_CODEC_ID_PCM_S24LE) ? 24 : 32;
-
-        DEBUG_LOG("[AudioDecoder] Raw PCM mode: " << m_trackInfo.bitDepth << "-bit LE");
-        return true;  // Skip codec open
-    }
-```
-
-In `AudioDecoder::readSamples()`, ADD at start:
-```cpp
-    if (m_rawPCM) {
-        return readSamplesRawPCM(buffer, numSamples);  // New method
-    }
-```
-
-ADD helper for S24 expansion:
-```cpp
-// Expand packed 24-bit (3 bytes) to S32 (4 bytes, sign-extended)
-void AudioDecoder::expand24To32(uint8_t* dst, const uint8_t* src, size_t numSamples) {
-    for (size_t i = 0; i < numSamples; i++) {
-        dst[i * 4 + 0] = src[i * 3 + 0];  // LSB
-        dst[i * 4 + 1] = src[i * 3 + 1];
-        dst[i * 4 + 2] = src[i * 3 + 2];  // MSB of 24-bit
-        // Sign extend: replicate bit 23 into the top byte
-        dst[i * 4 + 3] = (src[i * 3 + 2] & 0x80) ? 0xFF : 0x00;
-    }
-}
-```
-
-In `AudioDecoder::seek()`, ADD:
-```cpp
-    if (m_rawPCM) {
-        m_pcmRemainderCount = 0;
-        m_eof = false;
-    }
-```
-
----
-
-### A.8 N4: SIMD Memcpy for Fixed Sizes
-
-**File:** `src/DirettaRingBuffer.h`
-
-ADD specialised functions (near memcpy_audio_fixed):
-```cpp
-// Fixed-size SIMD copies for common audio frame sizes
-// These eliminate memcpy's internal size branching
-
-#ifdef __AVX2__
-// 176 bytes = stereo 44.1kHz frame (11 × 16 bytes, fits in 3 AVX registers with overlap)
-inline void memcpy_176_avx(uint8_t* __restrict dst, const uint8_t* __restrict src) {
-    __m256i v0 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(src));
-    __m256i v1 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(src + 32));
-    __m256i v2 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(src + 64));
-    __m256i v3 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(src + 96));
-    __m256i v4 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(src + 128));
-    // Last 16 bytes (176 - 160 = 16)
-    __m128i v5 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(src + 160));
-
-    _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst), v0);
-    _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + 32), v1);
-    _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + 64), v2);
-    _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + 96), v3);
-    _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + 128), v4);
-    _mm_storeu_si128(reinterpret_cast<__m128i*>(dst + 160), v5);
-}
-
-// 384 bytes = stereo 96kHz frame (12 × 32 bytes)
-inline void memcpy_384_avx(uint8_t* __restrict dst, const uint8_t* __restrict src) {
-    for (size_t i = 0; i < 384; i += 32) {
-        __m256i v = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(src + i));
-        _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + i), v);
-    }
-}
-#endif
-
-// Dispatch based on known sizes
-inline void memcpy_audio_sized(uint8_t* dst, const uint8_t* src, size_t len) {
-#ifdef __AVX2__
-    if (len == 176) { memcpy_176_avx(dst, src); return; }
-    if (len == 384) { memcpy_384_avx(dst, src); return; }
-#endif
-    memcpy_audio_fixed(dst, src, len);
-}
-```
-
-In `writeToRing()`, REPLACE memcpy calls:
-```cpp
-    if (firstChunk > 0) {
-        memcpy_audio_sized(ring + writePos, staged, firstChunk);
-    }
-    if (secondChunk > 0) {
-        memcpy_audio_sized(ring, staged + firstChunk, secondChunk);
-    }
-```
-
----
-
-### A.9 S4: Consolidate Retry Constants
-
-**File:** `src/DirettaSync.h`
-
-ADD namespace after DirettaBuffer namespace:
-```cpp
-namespace DirettaRetry {
-    // Connection establishment
-    constexpr int ONLINE_WAIT_RETRIES = 20;
-    constexpr int ONLINE_WAIT_DELAY_MS = 100;
-
-    // Format switching
-    constexpr int FORMAT_SWITCH_RETRIES = 10;
-    constexpr int FORMAT_SWITCH_DELAY_MS = 50;
-
-    // Playback start
-    constexpr int START_PLAYBACK_RETRIES = 50;
-    constexpr int START_PLAYBACK_DELAY_MS = 10;
-
-    // Audio send
-    constexpr int SEND_AUDIO_RETRIES = 100;
-    constexpr int SEND_AUDIO_DELAY_MS = 5;
-}
-```
-
-**File:** `src/DirettaSync.cpp`
-
-REPLACE magic numbers with constants:
-```cpp
-// BEFORE
-for (int i = 0; i < 20; i++) { ... std::this_thread::sleep_for(std::chrono::milliseconds(100)); }
-
-// AFTER
-for (int i = 0; i < DirettaRetry::ONLINE_WAIT_RETRIES; i++) {
-    std::this_thread::sleep_for(std::chrono::milliseconds(DirettaRetry::ONLINE_WAIT_DELAY_MS));
-}
-```
-
----
-
-### A.10 S5: DSD Diagnostic Code Compile Flag
-
-**File:** `src/AudioEngine.cpp`
-
-WRAP diagnostic code in compile-time flag:
-```cpp
-#ifdef DIRETTA_DSD_DIAGNOSTICS
-    // Packet diagnostics (lines 348-390)
-    if (m_trackInfo.isDSD) {
-        DEBUG_LOG("[DSD] First packet analysis:");
-        // ... existing diagnostic code ...
-    }
-#endif
-```
-
-**File:** `Makefile`
-
-ADD optional flag:
-```makefile
-# Enable DSD packet diagnostics (debug builds only)
-ifdef DSD_DIAG
-    CXXFLAGS += -DDIRETTA_DSD_DIAGNOSTICS
-endif
-```
-
-Usage: `make DSD_DIAG=1`
-
----
-
-## Appendix B: Testing Checklist
-
-### Basic Playback
-- [ ] PCM 16-bit/44.1kHz (CD quality)
-- [ ] PCM 24-bit/96kHz (high-res)
-- [ ] PCM 24-bit/192kHz
-- [ ] PCM 32-bit/384kHz
-- [ ] DSD64
-- [ ] DSD128
-
-### Format Transitions
-- [ ] PCM → PCM (same rate)
-- [ ] PCM → PCM (different rate)
-- [ ] PCM → DSD
-- [ ] DSD → PCM
-- [ ] DSD → DSD (different rate)
-
-### Control
-- [ ] Stop during playback
-- [ ] Pause/Resume
-- [ ] Seek during playback
-- [ ] Rapid play/stop cycles
-- [ ] Clean shutdown (no hangs)
-
-### Stress Tests
-- [ ] Long playback (1+ hour)
-- [ ] Gapless playback (multiple tracks)
-- [ ] Check underrun count at session end
-
----
-
-## Appendix C: Measurement Recommendations
-
-Before implementing, establish baselines:
-
-1. **Callback timing variance:** Measure P99 latency of audio callback
-2. **CPU usage:** Profile sendAudio() and readSamples()
-3. **Cache miss rate:** Use perf counters for L1/L2/L3 misses
-4. **Underrun count:** Track m_underrunCount across test runs
-
-After each optimisation, re-measure to validate impact.
-
----
-
-## Patterns Already Well-Applied
-
-| Pattern | Where Applied |
-|---------|---------------|
-| Memory Allocation Elimination | m_packet, m_frame reuse |
-| Processing Layer Bypass | PCM bypass in AudioDecoder |
-| O(1) Data Structures | AVAudioFifo, power-of-2 ring buffer |
-| Cache Locality | alignas(64) on ring positions |
-| Syscall Elimination | Lock-free callback sync |
-| Flow Control Tuning | 500µs micro-sleep |
-| Function Specialisation | DSD conversion modes |
-
----
-
-**End of Report**
diff --git a/docs/plans/2026-01-18-hot-path-generation-counters-design.md b/docs/plans/2026-01-18-hot-path-generation-counters-design.md
new file mode 100644
index 0000000..0d05299
--- /dev/null
+++ b/docs/plans/2026-01-18-hot-path-generation-counters-design.md
@@ -0,0 +1,369 @@
+# Hot Path Generation Counters Design
+
+**Date:** 2026-01-18
+**Status:** Ready for implementation
+**Scope:** PCM and DSD hot paths (producer and consumer)
+
+## Objective
+
+Reduce per-call overhead in both producer (`sendAudio`) and consumer (`getNewStream`) hot paths by consolidating atomic operations and eliminating redundant loads. Build performance headroom for high sample rate playback.
+
+## Optimizations
+
+| ID | Optimization | Location | Impact |
+|----|--------------|----------|--------|
+| P1 | Format generation counter | sendAudio | 7 atomics → 1 |
+| P2 | Direct write API | ring buffer push | Skip wraparound check ~99% |
+| P3 | Inline position loads | ring buffer | 2 redundant loads eliminated |
+| C1 | State generation counter | getNewStream | 5 atomics → 1 |
+| C2 | Relaxed ordering in guard | RingAccessGuard | Lighter atomic ops |
+
+---
+
+## P1: Format Generation Counter (Producer Side)
+
+### Problem
+
+`sendAudio()` loads 7 atomics on every call (DirettaSync.cpp:942-948):
+
+```cpp
+bool dsdMode = m_isDsdMode.load(std::memory_order_acquire);
+bool pack24bit = m_need24BitPack.load(std::memory_order_acquire);
+bool upsample16to32 = m_need16To32Upsample.load(std::memory_order_acquire);
+bool needBitReversal = m_needDsdBitReversal.load(std::memory_order_acquire);
+bool needByteSwap = m_needDsdByteSwap.load(std::memory_order_acquire);
+int numChannels = m_channels.load(std::memory_order_acquire);
+int bytesPerSample = m_bytesPerSample.load(std::memory_order_acquire);
+```
+
+Format rarely changes during playback (~0.1% of calls), yet we pay for 7 atomic loads every time.
+
+### Solution
+
+Add generation counter + cached values. Single atomic comparison in common case.
+
+**New members (DirettaSync.h):**
+
+```cpp
+// Format generation - incremented in configureRingPCM/configureRingDSD
+std::atomic<uint32_t> m_formatGeneration{0};
+
+// Cached format values (non-atomic, only accessed by producer thread)
+uint32_t m_cachedFormatGen{0};
+bool m_cachedDsdMode{false};
+bool m_cachedPack24bit{false};
+bool m_cachedUpsample16to32{false};
+bool m_cachedNeedBitReversal{false};
+bool m_cachedNeedByteSwap{false};
+int m_cachedChannels{2};
+int m_cachedBytesPerSample{2};
+```
+
+**sendAudio() change:**
+
+```cpp
+uint32_t gen = m_formatGeneration.load(std::memory_order_acquire);
+if (gen != m_cachedFormatGen) {
+    // Cold path: reload all (only on format change)
+    m_cachedDsdMode = m_isDsdMode.load(std::memory_order_acquire);
+    m_cachedPack24bit = m_need24BitPack.load(std::memory_order_acquire);
+    m_cachedUpsample16to32 = m_need16To32Upsample.load(std::memory_order_acquire);
+    m_cachedNeedBitReversal = m_needDsdBitReversal.load(std::memory_order_acquire);
+    m_cachedNeedByteSwap = m_needDsdByteSwap.load(std::memory_order_acquire);
+    m_cachedChannels = m_channels.load(std::memory_order_acquire);
+    m_cachedBytesPerSample = m_bytesPerSample.load(std::memory_order_acquire);
+    m_cachedFormatGen = gen;
+}
+
+// Hot path: use cached values directly
+bool dsdMode = m_cachedDsdMode;
+bool pack24bit = m_cachedPack24bit;
+// ... etc
+```
+
+**Increment points:**
+
+- `configureRingPCM()` - at end of function
+- `configureRingDSD()` - at end of function
+
+---
+
+## P2: Direct Write API (Ring Buffer)
+
+### Problem
+
+Every `push()` and `writeToRing()` checks for wraparound, even though contiguous space is available ~99% of the time (wraparound only at buffer boundary).
+
+### Solution
+
+Add direct write API that returns a contiguous region when available.
+
+**New methods (DirettaRingBuffer.h):**
+
+```cpp
+/**
+ * Get direct write pointer for zero-copy writes.
+ * Returns true if contiguous space >= needed is available.
+ */
+bool getDirectWriteRegion(size_t needed, uint8_t*& region, size_t& available) {
+    if (size_ == 0) return false;
+
+    size_t wp = writePos_.load(std::memory_order_acquire);
+    size_t rp = readPos_.load(std::memory_order_acquire);
+
+    // Contiguous space from writePos to either readPos or end of buffer
+    size_t toEnd = size_ - wp;
+    size_t toRead = ((rp - wp - 1) & mask_);  // total free
+    size_t contiguous = std::min(toEnd, toRead);
+
+    if (contiguous >= needed) {
+        region = buffer_.data() + wp;
+        available = contiguous;
+        return true;
+    }
+    return false;
+}
+
+/**
+ * Commit a direct write, advancing write pointer.
+ */
+void commitDirectWrite(size_t written) {
+    size_t wp = writePos_.load(std::memory_order_relaxed);
+    writePos_.store((wp + written) & mask_, std::memory_order_release);
+}
+```
+
+**Optimized push():**
+
+```cpp
+size_t push(const uint8_t* data, size_t len) {
+    uint8_t* region;
+    size_t available;
+    if (getDirectWriteRegion(len, region, available)) {
+        // Fast path: single contiguous memcpy
+        memcpy_audio(region, data, len);
+        commitDirectWrite(len);
+        return len;
+    }
+    // Slow path: existing wraparound handling
+    if (size_ == 0) return 0;
+
+    size_t wp = writePos_.load(std::memory_order_acquire);
+    size_t rp = readPos_.load(std::memory_order_acquire);
+    size_t free = (rp - wp - 1) & mask_;
+
+    if (len > free) len = free;
+    if (len == 0) return 0;
+
+    size_t firstChunk = std::min(len, size_ - wp);
+    memcpy_audio(buffer_.data() + wp, data, firstChunk);
+    if (firstChunk < len) {
+        memcpy_audio(buffer_.data(), data + firstChunk, len - firstChunk);
+    }
+
+    writePos_.store((wp + len) & mask_, std::memory_order_release);
+    return len;
+}
+```
+
+Same pattern applies to `writeToRing()` used by conversion methods.
+
+---
+
+## P3: Inline Position Loads (Ring Buffer)
+
+### Problem
+
+Current `push()` and `pop()` load atomic positions twice:
+
+```cpp
+// push() current:
+size_t free = getFreeSpace();        // loads writePos_ AND readPos_
+size_t wp = writePos_.load(...);     // loads writePos_ AGAIN
+
+// pop() current:
+size_t avail = getAvailable();       // loads writePos_ AND readPos_
+size_t rp = readPos_.load(...);      // loads readPos_ AGAIN
+```
+
+### Solution
+
+Inline the calculations and reuse loaded values (shown in P2 above for push).
+
+**Optimized pop():**
+
+```cpp
+size_t pop(uint8_t* dest, size_t len) {
+    if (size_ == 0) return 0;
+
+    size_t wp = writePos_.load(std::memory_order_acquire);
+    size_t rp = readPos_.load(std::memory_order_acquire);
+    size_t avail = (wp - rp) & mask_;  // inline getAvailable logic
+
+    if (len > avail) len = avail;
+    if (len == 0) return 0;
+
+    // rp already loaded, use directly
+    size_t firstChunk = std::min(len, size_ - rp);
+
+    memcpy_audio(dest, buffer_.data() + rp, firstChunk);
+    if (firstChunk < len) {
+        memcpy_audio(dest + firstChunk, buffer_.data(), len - firstChunk);
+    }
+
+    readPos_.store((rp + len) & mask_, std::memory_order_release);
+    return len;
+}
+```
+
+**Note:** `getAvailable()` and `getFreeSpace()` remain as public methods for external callers (like `getBufferLevel()`).
+
+---
+
+## C1: State Generation Counter (Consumer Side)
+
+### Problem
+
+`getNewStream()` loads 5+ state atomics on every call:
+
+```cpp
+int currentBytesPerBuffer = m_bytesPerBuffer.load(...);
+uint32_t remainder = m_framesPerBufferRemainder.load(...);
+int bytesPerFrame = m_bytesPerFrame.load(...);
+bool currentIsDsd = m_isDsdMode.load(...);
+// Plus silenceByte from ring buffer
+```
+
+### Solution
+
+Similar generation counter pattern. Batch stable configuration; check volatile state fresh.
+
+**New members (DirettaSync.h):**
+
+```cpp
+// Consumer state generation - incremented on config changes
+std::atomic<uint32_t> m_consumerStateGen{0};
+
+// Cached consumer state (only accessed by worker thread)
+uint32_t m_cachedConsumerGen{0};
+int m_cachedBytesPerBuffer{176};
+uint32_t m_cachedFramesRemainder{0};
+int m_cachedBytesPerFrame{0};
+bool m_cachedConsumerIsDsd{false};
+uint8_t m_cachedSilenceByte{0};
+```
+
+**getNewStream() change:**
+
+```cpp
+uint32_t gen = m_consumerStateGen.load(std::memory_order_acquire);
+if (gen != m_cachedConsumerGen) {
+    m_cachedBytesPerBuffer = m_bytesPerBuffer.load(std::memory_order_acquire);
+    m_cachedFramesRemainder = m_framesPerBufferRemainder.load(std::memory_order_acquire);
+    m_cachedBytesPerFrame = m_bytesPerFrame.load(std::memory_order_acquire);
+    m_cachedConsumerIsDsd = m_isDsdMode.load(std::memory_order_acquire);
+    m_cachedSilenceByte = m_ringBuffer.silenceByte();
+    m_cachedConsumerGen = gen;
+}
+
+int currentBytesPerBuffer = m_cachedBytesPerBuffer;
+// ... use cached values
+
+// Still check volatile state fresh (can change mid-playback)
+if (m_stopRequested.load(std::memory_order_acquire)) { ... }
+if (m_silenceBuffersRemaining.load(std::memory_order_acquire) > 0) { ... }
+```
+
+**Increment points:** Same as P1 - `configureRingPCM()` and `configureRingDSD()`.
+
+---
+
+## C2: Lighter Ordering in RingAccessGuard
+
+### Problem
+
+Current guard does 2 atomic RMW operations with acq_rel ordering per hot path call:
+
+```cpp
+users_.fetch_add(1, std::memory_order_acq_rel);  // constructor
+users_.fetch_sub(1, std::memory_order_acq_rel);  // destructor
+```
+
+### Solution
+
+Use minimal ordering that preserves correctness:
+
+- **Increment must stay acquire** (or acq_rel): Ensures the increment is visible to `beginReconfigure()` before any ring buffer operations. Without this, `beginReconfigure()` could see `m_ringUsers == 0` and proceed to resize/clear the buffer while a thread is already inside the guarded section.
+
+- **Decrement can use release**: The release ensures all ring buffer operations complete before the count decrements, which is sufficient for `beginReconfigure()` to safely proceed after seeing zero.
+
+- **Bail-out decrement can use relaxed**: If we fail the second reconfiguring check, we never entered the guarded section, so no ordering is needed.
+
+**Updated RingAccessGuard:**
+
+```cpp
+class RingAccessGuard {
+public:
+    RingAccessGuard(std::atomic<int>& users, const std::atomic<bool>& reconfiguring)
+        : users_(users), active_(false) {
+        if (reconfiguring.load(std::memory_order_acquire)) {
+            return;
+        }
+        users_.fetch_add(1, std::memory_order_acquire);  // MUST stay acquire
+        if (reconfiguring.load(std::memory_order_acquire)) {
+            users_.fetch_sub(1, std::memory_order_relaxed);  // bail-out, no ordering needed
+            return;
+        }
+        active_ = true;
+    }
+
+    ~RingAccessGuard() {
+        if (active_) {
+            users_.fetch_sub(1, std::memory_order_release);  // release sufficient
+        }
+    }
+
+    bool active() const { return active_; }
+
+private:
+    std::atomic<int>& users_;
+    bool active_;
+};
+```
+
+**Net savings:** Decrement goes from acq_rel to release (lighter on some architectures), bail-out decrement uses relaxed. Increment stays acquire for correctness.
+
+---
+
+## Files Modified
+
+| File | Changes |
+|------|---------|
+| `src/DirettaSync.h` | Add generation counters and cached value members |
+| `src/DirettaSync.cpp` | Generation checks in sendAudio/getNewStream, increments in configure functions, lighter guard ordering |
+| `src/DirettaRingBuffer.h` | Add getDirectWriteRegion/commitDirectWrite, inline position loads in push/pop |
+
+---
+
+## Testing
+
+### Functional (after each phase)
+
+- [ ] PCM 16-bit/44.1kHz playback
+- [ ] PCM 24-bit/96kHz playback
+- [ ] PCM 24-bit/192kHz playback
+- [ ] DSD64/DSD128 playback
+- [ ] Format changes mid-stream (verify generation increment)
+- [ ] Start/stop cycles (no hangs)
+- [ ] Gapless track transitions
+
+### Stress Testing
+
+- [ ] Rapid format switching
+- [ ] High CPU load during playback
+- [ ] Extended playback sessions (memory stability)
+
+### Listening
+
+- [ ] A/B comparison with previous build
+- [ ] Focus: timing, clarity, background noise
diff --git a/docs/plans/2026-01-18-hot-path-generation-counters-impl.md b/docs/plans/2026-01-18-hot-path-generation-counters-impl.md
new file mode 100644
index 0000000..e4e0e1c
--- /dev/null
+++ b/docs/plans/2026-01-18-hot-path-generation-counters-impl.md
@@ -0,0 +1,738 @@
+# Hot Path Generation Counters Implementation Plan
+
+> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.
+
+**Goal:** Reduce per-call atomic load overhead in producer and consumer hot paths using generation counters and ring buffer optimizations.
+
+**Architecture:** Add generation counters to batch stable configuration loads (format on producer, state on consumer). Optimize ring buffer with direct write API and inlined position loads. Lighter memory ordering in RingAccessGuard where safe.
+
+**Tech Stack:** C++17, std::atomic, lock-free patterns
+
+---
+
+## Task 1: Add Format Generation Counter Members (P1 - Part 1)
+
+**Files:**
+- Modify: `src/DirettaSync.h:323` (after m_underrunCount)
+
+**Step 1: Add generation counter and cached format members**
+
+In `src/DirettaSync.h`, after line 323 (`std::atomic<uint32_t> m_underrunCount{0};`), add:
+
+```cpp
+    // Format generation counter - incremented on ANY format change
+    std::atomic<uint32_t> m_formatGeneration{0};
+
+    // Cached format values for sendAudio fast path (producer thread only)
+    uint32_t m_cachedFormatGen{0};
+    bool m_cachedDsdMode{false};
+    bool m_cachedPack24bit{false};
+    bool m_cachedUpsample16to32{false};
+    bool m_cachedNeedBitReversal{false};
+    bool m_cachedNeedByteSwap{false};
+    int m_cachedChannels{2};
+    int m_cachedBytesPerSample{2};
+```
+
+**Step 2: Verify compilation**
+
+Run: `make -j4 2>&1 | head -20`
+Expected: BUILD SUCCESS (new members unused yet)
+
+**Step 3: Commit**
+
+```bash
+git add src/DirettaSync.h
+git commit -m "$(cat <<'EOF'
+refactor(P1): add format generation counter members
+
+Add m_formatGeneration atomic and cached format values for sendAudio
+fast path optimization. Members are added but not yet used.
+
+Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
+EOF
+)"
+```
+
+---
+
+## Task 2: Increment Format Generation in Configure Functions (P1 - Part 2)
+
+**Files:**
+- Modify: `src/DirettaSync.cpp:815` (end of configureRingPCM)
+- Modify: `src/DirettaSync.cpp:848` (end of configureRingDSD)
+
+**Step 1: Add increment at end of configureRingPCM**
+
+In `src/DirettaSync.cpp`, find line 815 (the closing brace of configureRingPCM after the DIRETTA_LOG). Add before the closing brace:
+
+```cpp
+    // Increment format generation to invalidate cached values
+    m_formatGeneration.fetch_add(1, std::memory_order_release);
+```
+
+**Step 2: Add increment at end of configureRingDSD**
+
+In `src/DirettaSync.cpp`, find line 848 (the closing brace of configureRingDSD after the DIRETTA_LOG). Add before the closing brace:
+
+```cpp
+    // Increment format generation to invalidate cached values
+    m_formatGeneration.fetch_add(1, std::memory_order_release);
+```
+
+**Step 3: Verify compilation**
+
+Run: `make -j4 2>&1 | head -20`
+Expected: BUILD SUCCESS
+
+**Step 4: Commit**
+
+```bash
+git add src/DirettaSync.cpp
+git commit -m "$(cat <<'EOF'
+refactor(P1): increment format generation in configure functions
+
+configureRingPCM and configureRingDSD now increment m_formatGeneration
+to signal format changes to sendAudio.
+
+Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
+EOF
+)"
+```
+
+---
+
+## Task 3: Use Format Generation Counter in sendAudio (P1 - Part 3)
+
+**Files:**
+- Modify: `src/DirettaSync.cpp:941-948` (atomic loads in sendAudio)
+
+**Step 1: Replace atomic loads with generation check**
+
+Find lines 941-948 in sendAudio():
+
+```cpp
+    // Snapshot config state
+    bool dsdMode = m_isDsdMode.load(std::memory_order_acquire);
+    bool pack24bit = m_need24BitPack.load(std::memory_order_acquire);
+    bool upsample16to32 = m_need16To32Upsample.load(std::memory_order_acquire);
+    bool needBitReversal = m_needDsdBitReversal.load(std::memory_order_acquire);
+    bool needByteSwap = m_needDsdByteSwap.load(std::memory_order_acquire);
+    int numChannels = m_channels.load(std::memory_order_acquire);
+    int bytesPerSample = m_bytesPerSample.load(std::memory_order_acquire);
+```
+
+Replace with:
+
+```cpp
+    // Generation counter optimization: single atomic load in common case
+    uint32_t gen = m_formatGeneration.load(std::memory_order_acquire);
+    if (gen != m_cachedFormatGen) {
+        // Cold path: reload all format values (only on format change)
+        m_cachedDsdMode = m_isDsdMode.load(std::memory_order_acquire);
+        m_cachedPack24bit = m_need24BitPack.load(std::memory_order_acquire);
+        m_cachedUpsample16to32 = m_need16To32Upsample.load(std::memory_order_acquire);
+        m_cachedNeedBitReversal = m_needDsdBitReversal.load(std::memory_order_acquire);
+        m_cachedNeedByteSwap = m_needDsdByteSwap.load(std::memory_order_acquire);
+        m_cachedChannels = m_channels.load(std::memory_order_acquire);
+        m_cachedBytesPerSample = m_bytesPerSample.load(std::memory_order_acquire);
+        m_cachedFormatGen = gen;
+    }
+
+    // Hot path: use cached values
+    bool dsdMode = m_cachedDsdMode;
+    bool pack24bit = m_cachedPack24bit;
+    bool upsample16to32 = m_cachedUpsample16to32;
+    bool needBitReversal = m_cachedNeedBitReversal;
+    bool needByteSwap = m_cachedNeedByteSwap;
+    int numChannels = m_cachedChannels;
+    int bytesPerSample = m_cachedBytesPerSample;
+```
+
+**Step 2: Verify compilation**
+
+Run: `make -j4 2>&1 | head -20`
+Expected: BUILD SUCCESS
+
+**Step 3: Commit**
+
+```bash
+git add src/DirettaSync.cpp
+git commit -m "$(cat <<'EOF'
+perf(P1): use format generation counter in sendAudio
+
+Replace 7 atomic loads with single generation check in common case.
+Format values are cached and only reloaded when generation changes.
+
+Hot path: 1 atomic load + comparison (~99.9% of calls)
+Cold path: 7 atomic loads (only on format change)
+
+Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
+EOF
+)"
+```
+
+---
+
+## Task 4: Add Direct Write API to Ring Buffer (P2)
+
+**Files:**
+- Modify: `src/DirettaRingBuffer.h:150` (before push methods section)
+
+**Step 1: Add getDirectWriteRegion and commitDirectWrite methods**
+
+In `src/DirettaRingBuffer.h`, find line 150 (the push methods section comment). Add before it:
+
+```cpp
+    //=========================================================================
+    // Direct Write API (zero-copy fast path)
+    //=========================================================================
+
+    /**
+     * @brief Get direct write pointer for zero-copy writes
+     * @param needed Minimum bytes needed
+     * @param region Output: pointer to contiguous write region
+     * @param available Output: bytes available in region
+     * @return true if contiguous space >= needed is available
+     */
+    bool getDirectWriteRegion(size_t needed, uint8_t*& region, size_t& available) {
+        if (size_ == 0) return false;
+
+        size_t wp = writePos_.load(std::memory_order_acquire);
+        size_t rp = readPos_.load(std::memory_order_acquire);
+
+        // Contiguous space from writePos to either readPos or end of buffer
+        size_t toEnd = size_ - wp;
+        size_t totalFree = (rp - wp - 1) & mask_;
+        size_t contiguous = std::min(toEnd, totalFree);
+
+        if (contiguous >= needed) {
+            region = buffer_.data() + wp;
+            available = contiguous;
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * @brief Commit a direct write, advancing write pointer
+     * @param written Number of bytes written to the region
+     */
+    void commitDirectWrite(size_t written) {
+        size_t wp = writePos_.load(std::memory_order_relaxed);
+        writePos_.store((wp + written) & mask_, std::memory_order_release);
+    }
+
+```
+
+**Step 2: Verify compilation**
+
+Run: `make -j4 2>&1 | head -20`
+Expected: BUILD SUCCESS
+
+**Step 3: Commit**
+
+```bash
+git add src/DirettaRingBuffer.h
+git commit -m "$(cat <<'EOF'
+refactor(P2): add direct write API to ring buffer
+
+Add getDirectWriteRegion() and commitDirectWrite() for zero-copy
+writes when contiguous space is available (~99% of operations).
+
+Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
+EOF
+)"
+```
+
+---
+
+## Task 5: Optimize push() with Direct Write and Inlined Loads (P2 + P3)
+
+**Files:**
+- Modify: `src/DirettaRingBuffer.h:157-173` (push method)
+
+**Step 1: Replace push() implementation**
+
+Find the push() method (lines 157-173):
+
+```cpp
+    size_t push(const uint8_t* data, size_t len) {
+        if (size_ == 0) return 0;
+        size_t free = getFreeSpace();
+        if (len > free) len = free;
+        if (len == 0) return 0;
+
+        size_t wp = writePos_.load(std::memory_order_acquire);
+        size_t firstChunk = std::min(len, size_ - wp);
+
+        memcpy_audio(buffer_.data() + wp, data, firstChunk);
+        if (firstChunk < len) {
+            memcpy_audio(buffer_.data(), data + firstChunk, len - firstChunk);
+        }
+
+        writePos_.store((wp + len) & mask_, std::memory_order_release);
+        return len;
+    }
+```
+
+Replace with:
+
+```cpp
+    size_t push(const uint8_t* data, size_t len) {
+        // Fast path: try direct write (no wraparound)
+        uint8_t* region;
+        size_t available;
+        if (getDirectWriteRegion(len, region, available)) {
+            memcpy_audio(region, data, len);
+            commitDirectWrite(len);
+            return len;
+        }
+
+        // Slow path: handle wraparound with inlined position loads
+        if (size_ == 0) return 0;
+
+        size_t wp = writePos_.load(std::memory_order_acquire);
+        size_t rp = readPos_.load(std::memory_order_acquire);
+        size_t free = (rp - wp - 1) & mask_;
+
+        if (len > free) len = free;
+        if (len == 0) return 0;
+
+        size_t firstChunk = std::min(len, size_ - wp);
+        memcpy_audio(buffer_.data() + wp, data, firstChunk);
+        if (firstChunk < len) {
+            memcpy_audio(buffer_.data(), data + firstChunk, len - firstChunk);
+        }
+
+        writePos_.store((wp + len) & mask_, std::memory_order_release);
+        return len;
+    }
+```
+
+**Step 2: Verify compilation**
+
+Run: `make -j4 2>&1 | head -20`
+Expected: BUILD SUCCESS
+
+**Step 3: Commit**
+
+```bash
+git add src/DirettaRingBuffer.h
+git commit -m "$(cat <<'EOF'
+perf(P2,P3): optimize push() with direct write and inlined loads
+
+- Fast path uses getDirectWriteRegion for zero-copy (~99% of calls)
+- Slow path inlines position loads to avoid redundant atomic reads
+- Eliminates getFreeSpace() call which loaded both positions
+
+Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
+EOF
+)"
+```
+
+---
+
+## Task 6: Optimize pop() with Inlined Position Loads (P3)
+
+**Files:**
+- Modify: `src/DirettaRingBuffer.h:509-525` (pop method)
+
+**Step 1: Replace pop() implementation**
+
+Find the pop() method (lines 509-525):
+
+```cpp
+    size_t pop(uint8_t* dest, size_t len) {
+        if (size_ == 0) return 0;
+        size_t avail = getAvailable();
+        if (len > avail) len = avail;
+        if (len == 0) return 0;
+
+        size_t rp = readPos_.load(std::memory_order_acquire);
+        size_t firstChunk = std::min(len, size_ - rp);
+
+        memcpy_audio(dest, buffer_.data() + rp, firstChunk);
+        if (firstChunk < len) {
+            memcpy_audio(dest + firstChunk, buffer_.data(), len - firstChunk);
+        }
+
+        readPos_.store((rp + len) & mask_, std::memory_order_release);
+        return len;
+    }
+```
+
+Replace with:
+
+```cpp
+    size_t pop(uint8_t* dest, size_t len) {
+        if (size_ == 0) return 0;
+
+        // Inline position loads to avoid redundant atomic reads
+        size_t wp = writePos_.load(std::memory_order_acquire);
+        size_t rp = readPos_.load(std::memory_order_acquire);
+        size_t avail = (wp - rp) & mask_;
+
+        if (len > avail) len = avail;
+        if (len == 0) return 0;
+
+        // rp already loaded, reuse directly
+        size_t firstChunk = std::min(len, size_ - rp);
+
+        memcpy_audio(dest, buffer_.data() + rp, firstChunk);
+        if (firstChunk < len) {
+            memcpy_audio(dest + firstChunk, buffer_.data(), len - firstChunk);
+        }
+
+        readPos_.store((rp + len) & mask_, std::memory_order_release);
+        return len;
+    }
+```
+
+**Step 2: Verify compilation**
+
+Run: `make -j4 2>&1 | head -20`
+Expected: BUILD SUCCESS
+
+**Step 3: Commit**
+
+```bash
+git add src/DirettaRingBuffer.h
+git commit -m "$(cat <<'EOF'
+perf(P3): optimize pop() with inlined position loads
+
+Inline getAvailable() logic to avoid loading readPos_ twice.
+Both positions loaded once and reused.
+
+Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
+EOF
+)"
+```
+
+---
+
+## Task 7: Add Consumer State Generation Counter Members (C1 - Part 1)
+
+**Files:**
+- Modify: `src/DirettaSync.h:332` (after m_cachedBytesPerSample)
+
+**Step 1: Add consumer generation counter and cached state members**
+
+In `src/DirettaSync.h`, after the P1 cached members (after `int m_cachedBytesPerSample{2};`), add:
+
+```cpp
+
+    // Consumer state generation - incremented on config changes
+    std::atomic<uint32_t> m_consumerStateGen{0};
+
+    // Cached consumer state for getNewStream fast path (worker thread only)
+    uint32_t m_cachedConsumerGen{0};
+    int m_cachedBytesPerBuffer{176};
+    uint32_t m_cachedFramesRemainder{0};
+    int m_cachedBytesPerFrame{0};
+    bool m_cachedConsumerIsDsd{false};
+    uint8_t m_cachedSilenceByte{0};
+```
+
+**Step 2: Verify compilation**
+
+Run: `make -j4 2>&1 | head -20`
+Expected: BUILD SUCCESS
+
+**Step 3: Commit**
+
+```bash
+git add src/DirettaSync.h
+git commit -m "$(cat <<'EOF'
+refactor(C1): add consumer state generation counter members
+
+Add m_consumerStateGen atomic and cached consumer state values for
+getNewStream fast path optimization.
+
+Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
+EOF
+)"
+```
+
+---
+
+## Task 8: Increment Consumer Generation in Configure Functions (C1 - Part 2)
+
+**Files:**
+- Modify: `src/DirettaSync.cpp` (configureRingPCM and configureRingDSD)
+
+**Step 1: Add consumer generation increment after format generation increment**
+
+In both `configureRingPCM()` and `configureRingDSD()`, after the line:
+```cpp
+    m_formatGeneration.fetch_add(1, std::memory_order_release);
+```
+
+Add:
+```cpp
+    m_consumerStateGen.fetch_add(1, std::memory_order_release);
+```
+
+**Step 2: Verify compilation**
+
+Run: `make -j4 2>&1 | head -20`
+Expected: BUILD SUCCESS
+
+**Step 3: Commit**
+
+```bash
+git add src/DirettaSync.cpp
+git commit -m "$(cat <<'EOF'
+refactor(C1): increment consumer state generation in configure functions
+
+Both configureRingPCM and configureRingDSD now increment
+m_consumerStateGen alongside m_formatGeneration.
+
+Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
+EOF
+)"
+```
+
+---
+
+## Task 9: Use Consumer State Generation Counter in getNewStream (C1 - Part 3)
+
+**Files:**
+- Modify: `src/DirettaSync.cpp:1026-1040` (start of getNewStream)
+
+**Step 1: Replace atomic loads with generation check**
+
+Find lines 1026-1040 in getNewStream():
+
+```cpp
+bool DirettaSync::getNewStream(DIRETTA::Stream& stream) {
+    m_workerActive = true;
+
+    int currentBytesPerBuffer = m_bytesPerBuffer.load(std::memory_order_acquire);
+    uint32_t remainder = m_framesPerBufferRemainder.load(std::memory_order_acquire);
+    if (remainder != 0) {
+        int bytesPerFrame = m_bytesPerFrame.load(std::memory_order_acquire);
+        uint32_t acc = m_framesPerBufferAccumulator.load(std::memory_order_relaxed);
+        acc += remainder;
+        if (acc >= 1000) {
+            acc -= 1000;
+            currentBytesPerBuffer += bytesPerFrame;
+        }
+        m_framesPerBufferAccumulator.store(acc, std::memory_order_relaxed);
+    }
+    uint8_t currentSilenceByte = m_ringBuffer.silenceByte();
+```
+
+Replace with:
+
+```cpp
+bool DirettaSync::getNewStream(DIRETTA::Stream& stream) {
+    m_workerActive = true;
+
+    // Generation counter optimization: single atomic load in common case
+    uint32_t gen = m_consumerStateGen.load(std::memory_order_acquire);
+    if (gen != m_cachedConsumerGen) {
+        // Cold path: reload stable configuration (only on format change)
+        m_cachedBytesPerBuffer = m_bytesPerBuffer.load(std::memory_order_acquire);
+        m_cachedFramesRemainder = m_framesPerBufferRemainder.load(std::memory_order_acquire);
+        m_cachedBytesPerFrame = m_bytesPerFrame.load(std::memory_order_acquire);
+        m_cachedConsumerIsDsd = m_isDsdMode.load(std::memory_order_acquire);
+        m_cachedSilenceByte = m_ringBuffer.silenceByte();
+        m_cachedConsumerGen = gen;
+    }
+
+    // Hot path: use cached values
+    int currentBytesPerBuffer = m_cachedBytesPerBuffer;
+    uint32_t remainder = m_cachedFramesRemainder;
+    if (remainder != 0) {
+        int bytesPerFrame = m_cachedBytesPerFrame;
+        uint32_t acc = m_framesPerBufferAccumulator.load(std::memory_order_relaxed);
+        acc += remainder;
+        if (acc >= 1000) {
+            acc -= 1000;
+            currentBytesPerBuffer += bytesPerFrame;
+        }
+        m_framesPerBufferAccumulator.store(acc, std::memory_order_relaxed);
+    }
+    uint8_t currentSilenceByte = m_cachedSilenceByte;
+```
+
+**Step 2: Update isDsd usage later in function**
+
+Find line 1055:
+```cpp
+    bool currentIsDsd = m_isDsdMode.load(std::memory_order_acquire);
+```
+
+Replace with:
+```cpp
+    bool currentIsDsd = m_cachedConsumerIsDsd;
+```
+
+**Step 3: Verify compilation**
+
+Run: `make -j4 2>&1 | head -20`
+Expected: BUILD SUCCESS
+
+**Step 4: Commit**
+
+```bash
+git add src/DirettaSync.cpp
+git commit -m "$(cat <<'EOF'
+perf(C1): use consumer state generation counter in getNewStream
+
+Replace 5 atomic loads with single generation check in common case.
+Stable configuration cached and only reloaded on format change.
+
+Volatile state (m_stopRequested, m_silenceBuffersRemaining, etc.)
+still checked fresh as it can change mid-playback.
+
+Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
+EOF
+)"
+```
+
+---
+
+## Task 10: Lighten RingAccessGuard Memory Ordering (C2)
+
+**Files:**
+- Modify: `src/DirettaSync.cpp:14-40` (RingAccessGuard class)
+
+**Step 1: Update memory ordering in RingAccessGuard**
+
+Find the RingAccessGuard class (lines 14-40):
+
+```cpp
+class RingAccessGuard {
+public:
+    RingAccessGuard(std::atomic<int>& users, const std::atomic<bool>& reconfiguring)
+        : users_(users), active_(false) {
+        if (reconfiguring.load(std::memory_order_acquire)) {
+            return;
+        }
+        users_.fetch_add(1, std::memory_order_acq_rel);
+        if (reconfiguring.load(std::memory_order_acquire)) {
+            users_.fetch_sub(1, std::memory_order_acq_rel);
+            return;
+        }
+        active_ = true;
+    }
+
+    ~RingAccessGuard() {
+        if (active_) {
+            users_.fetch_sub(1, std::memory_order_acq_rel);
+        }
+    }
+
+    bool active() const { return active_; }
+
+private:
+    std::atomic<int>& users_;
+    bool active_;
+};
+```
+
+Replace with:
+
+```cpp
+class RingAccessGuard {
+public:
+    RingAccessGuard(std::atomic<int>& users, const std::atomic<bool>& reconfiguring)
+        : users_(users), active_(false) {
+        if (reconfiguring.load(std::memory_order_acquire)) {
+            return;
+        }
+        // MUST use acquire: ensures increment visible to beginReconfigure()
+        // before any ring buffer operations
+        users_.fetch_add(1, std::memory_order_acquire);
+        if (reconfiguring.load(std::memory_order_acquire)) {
+            // Bail-out: never entered guarded section, relaxed is safe
+            users_.fetch_sub(1, std::memory_order_relaxed);
+            return;
+        }
+        active_ = true;
+    }
+
+    ~RingAccessGuard() {
+        if (active_) {
+            // Release: ensures all ring ops complete before decrement
+            users_.fetch_sub(1, std::memory_order_release);
+        }
+    }
+
+    bool active() const { return active_; }
+
+private:
+    std::atomic<int>& users_;
+    bool active_;
+};
+```
+
+**Step 2: Verify compilation**
+
+Run: `make -j4 2>&1 | head -20`
+Expected: BUILD SUCCESS
+
+**Step 3: Commit**
+
+```bash
+git add src/DirettaSync.cpp
+git commit -m "$(cat <<'EOF'
+perf(C2): lighten RingAccessGuard memory ordering
+
+- Increment: stays acquire (required for correctness)
+- Decrement: acq_rel -> release (sufficient for exit)
+- Bail-out decrement: relaxed (never entered guarded section)
+
+Preserves synchronization with beginReconfigure() while reducing
+atomic operation overhead where safe.
+
+Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
+EOF
+)"
+```
+
+---
+
+## Task 11: Final Build and Test
+
+**Step 1: Full rebuild**
+
+Run: `make clean && make -j4`
+Expected: BUILD SUCCESS
+
+**Step 2: Manual testing checklist**
+
+Test the following scenarios:
+- [ ] PCM 16-bit/44.1kHz playback
+- [ ] PCM 24-bit/96kHz playback
+- [ ] PCM 24-bit/192kHz playback
+- [ ] DSD64/DSD128 playback (if available)
+- [ ] Format changes mid-stream
+- [ ] Start/stop cycles (no hangs)
+- [ ] Gapless track transitions
+
+**Step 3: Create summary commit (squash if desired)**
+
+If all tests pass, optionally create a summary tag:
+
+```bash
+git tag -a v1.x.x-hot-path-opt -m "Hot path generation counter optimizations"
+```
+
+---
+
+## Summary
+
+| Task | Optimization | Files Changed |
+|------|--------------|---------------|
+| 1-3 | P1: Format generation counter | DirettaSync.h, DirettaSync.cpp |
+| 4-5 | P2: Direct write API + push() | DirettaRingBuffer.h |
+| 6 | P3: pop() inlined loads | DirettaRingBuffer.h |
+| 7-9 | C1: Consumer state generation | DirettaSync.h, DirettaSync.cpp |
+| 10 | C2: Lighter guard ordering | DirettaSync.cpp |
+| 11 | Final build and test | - |
+
+**Total commits:** 10
+**Estimated time:** Implementation only, testing separate
diff --git a/install.sh b/install.sh
index f124859..50ad784 100644
--- a/install.sh
+++ b/install.sh
@@ -1,844 +1,123 @@
 #!/bin/bash
 #
 # Diretta UPnP Renderer - Installation Script
-#
+# 
 # This script helps install dependencies and set up the renderer.
 # Run with: bash install.sh
 #
 
 set -e  # Exit on error
 
-# =============================================================================
-# CONFIGURATION
-# =============================================================================
-
-SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
-SDK_PATH="${DIRETTA_SDK_PATH:-$HOME/DirettaHostSDK_147}"
-FFMPEG_BUILD_DIR="/tmp/ffmpeg-build"
-FFMPEG_HEADERS_DIR="$SCRIPT_DIR/ffmpeg-headers"
-FFMPEG_TARGET_VERSION="8.0.1"
-
-# =============================================================================
-# HELPER FUNCTIONS
-# =============================================================================
-
 # Colors for output
 RED='\033[0;31m'
 GREEN='\033[0;32m'
 YELLOW='\033[1;33m'
 BLUE='\033[0;34m'
-CYAN='\033[0;36m'
 NC='\033[0m' # No Color
 
-print_info()    { echo -e "${BLUE}[INFO]${NC} $1"; }
-print_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
-print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
-print_error()   { echo -e "${RED}[ERROR]${NC} $1"; }
-print_header()  { echo -e "\n${CYAN}=== $1 ===${NC}\n"; }
-
-confirm() {
-    local prompt="$1"
-    local default="${2:-N}"
-    local response
-
-    if [[ "$default" =~ ^[Yy]$ ]]; then
-        read -p "$prompt [Y/n]: " response
-        response=${response:-Y}
-    else
-        read -p "$prompt [y/N]: " response
-        response=${response:-N}
-    fi
-
-    [[ "$response" =~ ^[Yy]$ ]]
-}
-
-# =============================================================================
-# SYSTEM DETECTION
-# =============================================================================
-
-detect_system() {
-    print_header "System Detection"
-
-    if [ "$EUID" -eq 0 ]; then
-        print_error "Please do not run this script as root"
-        print_info "The script will ask for sudo password when needed"
-        exit 1
-    fi
-
-    if [ -f /etc/os-release ]; then
-        . /etc/os-release
-        OS=$ID
-        VER=$VERSION_ID
-        print_success "Detected: $PRETTY_NAME"
-    else
-        print_error "Cannot detect Linux distribution"
-        exit 1
-    fi
-
-    # Detect architecture
-    ARCH=$(uname -m)
-    print_info "Architecture: $ARCH"
-}
-
-# =============================================================================
-# BASE DEPENDENCIES
-# =============================================================================
-
-install_base_dependencies() {
-    print_header "Installing Base Dependencies"
-
-    case $OS in
-        fedora|rhel|centos)
-            print_info "Using DNF package manager..."
-            sudo dnf install -y \
-                gcc-c++ \
-                make \
-                git \
-                libupnp-devel \
-                wget \
-                nasm \
-                yasm \
-                pkg-config
-            ;;
-        ubuntu|debian)
-            print_info "Using APT package manager..."
-            sudo apt update
-            sudo apt install -y \
-                build-essential \
-                git \
-                libupnp-dev \
-                wget \
-                nasm \
-                yasm \
-                pkg-config
-            ;;
-        arch|manjaro)
-            print_info "Using Pacman package manager..."
-            sudo pacman -Sy --needed --noconfirm \
-                base-devel \
-                git \
-                libupnp \
-                wget \
-                nasm \
-                yasm \
-                pkgconf
-            ;;
-        *)
-            print_error "Unsupported distribution: $OS"
-            print_info "Please install dependencies manually:"
-            print_info "  - gcc/g++ (C++ compiler)"
-            print_info "  - make"
-            print_info "  - libupnp development library"
-            exit 1
-            ;;
-    esac
-
-    print_success "Base dependencies installed"
-}
-
-# =============================================================================
-# FFMPEG INSTALLATION
-# =============================================================================
-
-install_ffmpeg_build_deps() {
-    print_info "Installing FFmpeg build dependencies..."
-
-    case $OS in
-        fedora|rhel|centos)
-            sudo dnf install -y --skip-unavailable \
-                gmp-devel \
-                gnutls-devel \
-                libdrm-devel \
-                fribidi-devel \
-                soxr-devel \
-                libvorbis-devel \
-                libxml2-devel
-            ;;
-        ubuntu|debian)
-            sudo apt install -y \
-                libgmp-dev \
-                libgnutls28-dev \
-                libdrm-dev \
-                libfribidi-dev \
-                libsoxr-dev \
-                libvorbis-dev \
-                libxml2-dev
-            ;;
-        arch|manjaro)
-            sudo pacman -Sy --needed --noconfirm \
-                gmp \
-                gnutls \
-                libdrm \
-                fribidi \
-                libsoxr \
-                libvorbis \
-                libxml2
-            ;;
-    esac
-}
-
-# Common FFmpeg configure options for audio-only build (legacy/full version)
-get_ffmpeg_configure_opts() {
-    cat <<'OPTS'
---prefix=/usr/local
---disable-debug
---enable-shared
---disable-stripping
---disable-autodetect
---enable-gmp
---enable-gnutls
---enable-gpl
---enable-libdrm
---enable-libfribidi
---enable-libsoxr
---enable-libvorbis
---enable-libxml2
---enable-postproc
---enable-swresample
---enable-lto
---disable-encoders
---disable-decoders
---disable-hwaccels
---disable-muxers
---disable-demuxers
---disable-parsers
---disable-bsfs
---disable-protocols
---disable-indevs
---disable-outdevs
---disable-devices
---disable-filters
---disable-inline-asm
---disable-doc
---enable-muxer=flac,mov,ipod,wav,w64,ffmetadata
---enable-demuxer=flac,mov,wav,w64,ffmetadata,dsf,dff,aac,hls,mpegts,mp3,ogg,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,lavfi
---enable-encoder=alac,flac,pcm_s16le,pcm_s24le,pcm_s32le
---enable-decoder=alac,flac,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,dsd_lsbf,dsd_msbf,dsd_lsbf_planar,dsd_msbf_planar,vorbis,aac,aac_fixed,aac_latm,mp3,mp3float,mjpeg,png
---enable-parser=aac,aac_latm,flac,vorbis,mpegaudio,mjpeg
---enable-protocol=file,pipe,http,https,tcp,hls
---enable-filter=aresample,hdcd,sine,anull
---enable-version3
-OPTS
-}
-
-# Minimal FFmpeg 8.x configure options - streamlined audio-only build
-get_ffmpeg_8_minimal_opts() {
-    cat <<'OPTS'
---prefix=/usr
---enable-shared
---disable-static
---enable-small
---enable-gpl
---enable-version3
---enable-gnutls
---disable-everything
---disable-doc
---disable-avdevice
---disable-swscale
---enable-protocol=file,http,https,tcp
---enable-demuxer=flac,wav,dsf,dff,aac,mov
---enable-decoder=flac,alac,pcm_s16le,pcm_s24le,pcm_s32le,dsd_lsbf,dsd_msbf,dsd_lsbf_planar,dsd_msbf_planar,aac
---enable-muxer=flac,wav
---enable-filter=aresample
-OPTS
-}
-
-get_gcc_major_version() {
-    gcc -dumpversion 2>/dev/null | cut -d. -f1
-}
-
-# Install minimal build deps for FFmpeg 8.x (only gnutls required)
-install_ffmpeg_8_build_deps() {
-    print_info "Installing minimal FFmpeg 8.x build dependencies..."
-
-    case $OS in
-        fedora|rhel|centos)
-            sudo dnf install -y --skip-unavailable \
-                gnutls-devel
-            ;;
-        ubuntu|debian)
-            sudo apt install -y \
-                libgnutls28-dev
-            ;;
-        arch|manjaro)
-            sudo pacman -Sy --needed --noconfirm \
-                gnutls
-            ;;
-    esac
-}
-
-# Build FFmpeg 8.x with minimal audio-only configuration
-build_ffmpeg_8_minimal() {
-    local version="$1"
-
-    print_info "Building FFmpeg $version (minimal audio-only)..."
-
-    install_ffmpeg_8_build_deps
-
-    mkdir -p "$FFMPEG_BUILD_DIR"
-    cd "$FFMPEG_BUILD_DIR"
-
-    local tarball="ffmpeg-${version}.tar.xz"
-    local url="https://ffmpeg.org/releases/$tarball"
-
-    if [ ! -f "$tarball" ]; then
-        print_info "Downloading FFmpeg ${version}..."
-        if ! wget -q --show-progress "$url"; then
-            print_error "Failed to download FFmpeg $version"
-            return 1
-        fi
-    fi
-
-    print_info "Extracting FFmpeg..."
-    tar xf "$tarball"
-    cd "ffmpeg-${version}"
-
-    print_info "Configuring FFmpeg (minimal audio-only)..."
-    make distclean 2>/dev/null || true
-
-    # Build configure command (convert newlines to spaces)
-    local configure_opts
-    configure_opts=$(get_ffmpeg_8_minimal_opts | tr '\n' ' ')
-
-    # Run configure
-    ./configure $configure_opts
-
-    print_info "Building FFmpeg (this may take a while)..."
-    make -j$(nproc)
-
-    print_info "Installing FFmpeg to /usr..."
-    sudo make install
-    sudo ldconfig
-
-    cd "$SCRIPT_DIR"
-}
-
-build_ffmpeg_from_source() {
-    local version="$1"
-    local extra_flags="${2:-}"
-
-    print_info "Building FFmpeg $version from source..."
-
-    install_ffmpeg_build_deps
-
-    mkdir -p "$FFMPEG_BUILD_DIR"
-    cd "$FFMPEG_BUILD_DIR"
-
-    local tarball="ffmpeg-${version}.tar.xz"
-    local url="https://ffmpeg.org/releases/$tarball"
-
-    if [ ! -f "$tarball" ]; then
-        print_info "Downloading FFmpeg ${version}..."
-        if ! wget -q --show-progress "$url"; then
-            # Try .tar.bz2 for older versions
-            tarball="ffmpeg-${version}.tar.bz2"
-            url="https://ffmpeg.org/releases/$tarball"
-            print_info "Trying alternative archive format..."
-            wget -q --show-progress "$url" || {
-                print_error "Failed to download FFmpeg $version"
-                return 1
-            }
-        fi
-    fi
-
-    print_info "Extracting FFmpeg..."
-    tar xf "$tarball"
-    cd "ffmpeg-${version}"
-
-    print_info "Configuring FFmpeg (optimized for audio)..."
-    make distclean 2>/dev/null || true
-
-    # Build configure command (convert newlines to spaces)
-    local configure_opts
-    configure_opts=$(get_ffmpeg_configure_opts | tr '\n' ' ')
-
-    # Check GCC version for compatibility workarounds
-    local gcc_ver
-    gcc_ver=$(get_gcc_major_version)
-
-    # FFmpeg 5.x has inline asm issues with GCC 14+
-    # Disable LTO and inline-asm for compatibility
-    local version_major="${version%%.*}"
-    if [ "$version_major" = "5" ] && [ "$gcc_ver" -ge 14 ] 2>/dev/null; then
-        print_warning "GCC $gcc_ver detected - applying FFmpeg 5.x compatibility workarounds"
-        # Remove --enable-lto and add workarounds
-        configure_opts="${configure_opts//--enable-lto/}"
-        extra_flags="$extra_flags --disable-inline-asm"
-    fi
-
-    # Run configure
-    ./configure $configure_opts $extra_flags
-
-    print_info "Building FFmpeg (this may take a while)..."
-    make -j$(nproc)
-
-    print_info "Installing FFmpeg to /usr/local..."
-    sudo make install
-    sudo ldconfig
-
-    cd "$SCRIPT_DIR"
-}
-
-configure_ffmpeg_paths() {
-    print_info "Configuring library paths..."
-
-    # Add to /etc/ld.so.conf.d/ for system-wide recognition
-    echo "/usr/local/lib" | sudo tee /etc/ld.so.conf.d/ffmpeg-local.conf > /dev/null
-    sudo ldconfig
-
-    # Add to /etc/profile.d/ for all users
-    sudo tee /etc/profile.d/ffmpeg-local.sh > /dev/null <<'EOF'
-# FFmpeg installed to /usr/local
-export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH
-export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH
-export PATH=/usr/local/bin:$PATH
-EOF
-    sudo chmod +x /etc/profile.d/ffmpeg-local.sh
-
-    # Source for current session
-    export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH
-    export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH
-    export PATH=/usr/local/bin:$PATH
-
-    print_success "Library paths configured"
-}
-
-test_ffmpeg_installation() {
-    print_info "Testing FFmpeg installation..."
-
-    local ffmpeg_bin="${1:-/usr/local/bin/ffmpeg}"
-
-    # Fallback to system ffmpeg if local not found
-    if [ ! -x "$ffmpeg_bin" ]; then
-        ffmpeg_bin=$(which ffmpeg 2>/dev/null || echo "")
-    fi
-
-    if [ -z "$ffmpeg_bin" ] || [ ! -x "$ffmpeg_bin" ]; then
-        print_error "FFmpeg binary not found"
-        return 1
-    fi
-
-    # Check version
-    local ffmpeg_ver
-    ffmpeg_ver=$("$ffmpeg_bin" -version 2>&1 | head -1)
-    print_success "FFmpeg: $ffmpeg_ver"
-
-    # Check for required decoders
-    print_info "Checking audio decoders..."
-    local decoders
-    decoders=$("$ffmpeg_bin" -decoders 2>&1)
-
-    local required_decoders="flac alac dsd_lsbf dsd_msbf pcm_s16le pcm_s24le pcm_s32le"
-    local all_found=true
-
-    for dec in $required_decoders; do
-        if echo "$decoders" | grep -q " $dec "; then
-            echo "  [OK] $dec"
-        else
-            echo "  [MISSING] $dec"
-            all_found=false
-        fi
-    done
-
-    # Check for required demuxers
-    print_info "Checking demuxers..."
-    local demuxers
-    demuxers=$("$ffmpeg_bin" -demuxers 2>&1)
-
-    local required_demuxers="flac wav dsf mov"
-    for dem in $required_demuxers; do
-        if echo "$demuxers" | grep -q " $dem "; then
-            echo "  [OK] $dem"
-        else
-            echo "  [MISSING] $dem"
-            all_found=false
-        fi
-    done
-
-    # Check for required protocols
-    print_info "Checking protocols..."
-    local protocols
-    protocols=$("$ffmpeg_bin" -protocols 2>&1)
-
-    local required_protocols="http https file"
-    for proto in $required_protocols; do
-        if echo "$protocols" | grep -q "$proto"; then
-            echo "  [OK] $proto"
-        else
-            echo "  [MISSING] $proto"
-            all_found=false
-        fi
-    done
-
-    if [ "$all_found" = true ]; then
-        print_success "All required FFmpeg components found!"
-    else
-        print_warning "Some FFmpeg components are missing - audio playback may be limited"
-    fi
-
-    # Quick decode test
-    print_info "Testing decoder functionality..."
-    if "$ffmpeg_bin" -f lavfi -i "sine=frequency=1000:duration=0.1" -f null - 2>/dev/null; then
-        print_success "FFmpeg decode test passed"
-    else
-        print_warning "FFmpeg decode test failed - there may be issues"
-    fi
-}
-
-install_ffmpeg_rpm_fusion() {
-    print_info "Installing FFmpeg from RPM Fusion..."
-
-    # Enable RPM Fusion repositories
-    print_info "Enabling RPM Fusion repositories..."
-    sudo dnf install -y \
-        "https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm" \
-        "https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm" \
-        2>/dev/null || true
-
-    # Install FFmpeg
-    sudo dnf install -y ffmpeg ffmpeg-devel
-
-    print_success "RPM Fusion FFmpeg installed"
-}
-
-install_ffmpeg_system() {
-    print_info "Installing FFmpeg from system packages..."
-
-    case $OS in
-        fedora|rhel|centos)
-            # Try ffmpeg-free first (Fedora repos)
-            if ! sudo dnf install -y ffmpeg-free-devel 2>/dev/null; then
-                print_warning "ffmpeg-free not available, trying ffmpeg-devel..."
-                sudo dnf install -y ffmpeg-devel 2>/dev/null || {
-                    print_error "No FFmpeg package found in repositories"
-                    print_info "Consider enabling RPM Fusion or building from source"
-                    return 1
-                }
-            fi
-            ;;
-        ubuntu|debian)
-            sudo apt install -y \
-                libavformat-dev \
-                libavcodec-dev \
-                libavutil-dev \
-                libswresample-dev
-            ;;
-        arch|manjaro)
-            sudo pacman -Sy --needed --noconfirm ffmpeg
-            ;;
-    esac
-
-    print_success "System FFmpeg installed"
-    print_warning "Note: System FFmpeg may lack some audio codecs (e.g., DSD)"
-}
-
-install_ffmpeg() {
-    print_header "FFmpeg Installation"
-
-    echo "FFmpeg is required for audio decoding."
-    echo ""
-    echo "Installation options:"
-    echo ""
-    echo "  1) Build FFmpeg 5.1.2 from source"
-    echo "     - Stable, widely tested"
-    echo "     - Requires matching headers for compilation (auto-downloaded)"
-    echo ""
-    echo "  2) Build FFmpeg 7.1 from source"
-    echo "     - Latest stable with LTO optimization"
-    echo "     - Full DSD support, GCC 14/15 compatible"
-    echo "     - Better performance and codec support"
-    echo ""
-    echo "  3) Build FFmpeg 8.0.1 minimal (recommended)"
-    echo "     - Latest major version, minimal audio-only build"
-    echo "     - Smallest footprint: only essential decoders enabled"
-    echo "     - Installs to /usr (system-wide)"
-    echo ""
-    if [ "$OS" = "fedora" ]; then
-    echo "  4) Install from RPM Fusion (Fedora)"
-    echo "     - Pre-built packages with full codec support"
-    echo "     - Quick installation"
-    echo ""
-    echo "  5) Use system packages (minimal)"
-    echo "     - Fastest installation"
-    echo "     - May lack DSD and some codecs"
-    echo ""
-    else
-    echo "  4) Use system packages (minimal)"
-    echo "     - Fastest installation"
-    echo "     - May lack DSD and some codecs"
-    echo ""
-    fi
-
-    local max_option=4
-    [ "$OS" = "fedora" ] && max_option=5
-
-    read -p "Choose option [1-$max_option] (default: 3): " FFMPEG_OPTION
-    FFMPEG_OPTION=${FFMPEG_OPTION:-3}
-
-    case $FFMPEG_OPTION in
-        1)
-            # FFmpeg 5.1.2
-            FFMPEG_TARGET_VERSION="5.1.2"
-            build_ffmpeg_from_source "5.1.2"
-            configure_ffmpeg_paths
-            rm -rf "$FFMPEG_BUILD_DIR"
-            test_ffmpeg_installation "/usr/local/bin/ffmpeg"
-            # Save selected version for header downloads
-            echo "$FFMPEG_TARGET_VERSION" > "$SCRIPT_DIR/.ffmpeg-version"
-            ;;
-        2)
-            # FFmpeg 7.1
-            FFMPEG_TARGET_VERSION="7.1"
-            build_ffmpeg_from_source "7.1"
-            configure_ffmpeg_paths
-            rm -rf "$FFMPEG_BUILD_DIR"
-            test_ffmpeg_installation "/usr/local/bin/ffmpeg"
-            # Save selected version for header downloads
-            echo "$FFMPEG_TARGET_VERSION" > "$SCRIPT_DIR/.ffmpeg-version"
-            ;;
-        3)
-            # FFmpeg 8.0.1 minimal (recommended)
-            FFMPEG_TARGET_VERSION="8.0.1"
-            build_ffmpeg_8_minimal "8.0.1"
-            rm -rf "$FFMPEG_BUILD_DIR"
-            test_ffmpeg_installation "/usr/bin/ffmpeg"
-            # Save selected version for header downloads
-            echo "$FFMPEG_TARGET_VERSION" > "$SCRIPT_DIR/.ffmpeg-version"
-            ;;
-        4)
-            if [ "$OS" = "fedora" ]; then
-                install_ffmpeg_rpm_fusion
-                test_ffmpeg_installation "$(which ffmpeg)"
-            else
-                install_ffmpeg_system
-                test_ffmpeg_installation "$(which ffmpeg)"
-            fi
-            ;;
-        5)
-            if [ "$OS" = "fedora" ]; then
-                install_ffmpeg_system
-                test_ffmpeg_installation "$(which ffmpeg)"
-            else
-                print_error "Invalid option"
-                exit 1
-            fi
-            ;;
-        *)
-            print_error "Invalid option: $FFMPEG_OPTION"
-            exit 1
-            ;;
-    esac
-}
-
-# =============================================================================
-# FFMPEG HEADERS FOR COMPILATION (ABI COMPATIBILITY)
-# =============================================================================
-
-# Download FFmpeg source headers to ensure ABI compatibility
-# This is needed when runtime FFmpeg differs from system dev headers
-download_ffmpeg_headers() {
-    local version="${1:-$FFMPEG_TARGET_VERSION}"
-
-    print_info "Downloading FFmpeg $version headers for compilation..."
-
-    if [ -d "$FFMPEG_HEADERS_DIR" ] && [ -f "$FFMPEG_HEADERS_DIR/.version" ]; then
-        local existing_ver
-        existing_ver=$(cat "$FFMPEG_HEADERS_DIR/.version")
-        if [ "$existing_ver" = "$version" ]; then
-            print_success "FFmpeg $version headers already present"
-            return 0
-        fi
-    fi
-
-    mkdir -p "$FFMPEG_HEADERS_DIR"
-    cd "$FFMPEG_HEADERS_DIR"
-
-    local tarball="ffmpeg-${version}.tar.xz"
-    local url="https://ffmpeg.org/releases/$tarball"
-
-    if [ ! -f "$tarball" ]; then
-        print_info "Downloading FFmpeg ${version} source..."
-        if ! wget -q --show-progress "$url"; then
-            # Try .tar.bz2 for older versions
-            tarball="ffmpeg-${version}.tar.bz2"
-            url="https://ffmpeg.org/releases/$tarball"
-            wget -q --show-progress "$url" || {
-                print_error "Failed to download FFmpeg $version"
-                return 1
-            }
-        fi
-    fi
-
-    print_info "Extracting headers..."
-    tar xf "$tarball"
-
-    # Create symlinks to header directories
-    rm -f libavformat libavcodec libavutil libswresample
-    ln -sf "ffmpeg-${version}/libavformat" libavformat
-    ln -sf "ffmpeg-${version}/libavcodec" libavcodec
-    ln -sf "ffmpeg-${version}/libavutil" libavutil
-    ln -sf "ffmpeg-${version}/libswresample" libswresample
-
-    # Store version for future checks
-    echo "$version" > .version
-
-    # Clean up tarball to save space
-    rm -f "$tarball"
-
-    cd "$SCRIPT_DIR"
-    print_success "FFmpeg $version headers ready at $FFMPEG_HEADERS_DIR"
-}
-
-# Check if system FFmpeg headers match runtime version
-check_ffmpeg_abi_compatibility() {
-    print_info "Checking FFmpeg ABI compatibility..."
-
-    # Get runtime version
-    local runtime_ver=""
-    if command -v ffmpeg &> /dev/null; then
-        runtime_ver=$(ffmpeg -version 2>&1 | head -1 | grep -oP 'ffmpeg version \K[0-9]+\.[0-9]+(\.[0-9]+)?' || echo "")
-    fi
-
-    if [ -z "$runtime_ver" ]; then
-        print_warning "Could not detect FFmpeg runtime version"
-        return 1
-    fi
-
-    print_info "Runtime FFmpeg version: $runtime_ver"
-
-    # Get compile-time version from system headers
-    local header_paths=(
-        "/usr/include/ffmpeg/libavformat/version.h"
-        "/usr/include/libavformat/version.h"
-        "/usr/local/include/libavformat/version.h"
-    )
-
-    local compile_major=""
-    for hpath in "${header_paths[@]}"; do
-        if [ -f "$hpath" ]; then
-            compile_major=$(grep -oP 'LIBAVFORMAT_VERSION_MAJOR\s+\K[0-9]+' "$hpath" 2>/dev/null || echo "")
-            if [ -n "$compile_major" ]; then
-                print_info "System headers libavformat major version: $compile_major"
-                break
-            fi
-        fi
-    done
-
-    if [ -z "$compile_major" ]; then
-        print_warning "Could not detect FFmpeg header version"
-        return 1
-    fi
-
-    # Map runtime version to expected libavformat major version
-    local runtime_major="${runtime_ver%%.*}"
-    local expected_major=""
-    case "$runtime_major" in
-        4) expected_major="58" ;;
-        5) expected_major="59" ;;
-        6) expected_major="60" ;;
-        7) expected_major="61" ;;
-        8) expected_major="62" ;;
-        *) expected_major="" ;;
-    esac
-
-    if [ "$compile_major" != "$expected_major" ]; then
-        print_warning "ABI MISMATCH DETECTED!"
-        print_warning "  System headers: libavformat $compile_major (FFmpeg ${compile_major#5}+)"
-        print_warning "  Runtime library: FFmpeg $runtime_ver (expects libavformat $expected_major)"
-        print_info "Will download FFmpeg $runtime_ver headers for compilation"
-        return 1
-    fi
-
-    print_success "FFmpeg headers match runtime version"
-    return 0
+# Print colored messages
+print_info() {
+    echo -e "${BLUE}[INFO]${NC} $1"
 }
 
-# Detect FFmpeg runtime version
-detect_ffmpeg_runtime_version() {
-    local runtime_ver=""
-    if command -v ffmpeg &> /dev/null; then
-        runtime_ver=$(ffmpeg -version 2>&1 | head -1 | grep -oP 'ffmpeg version \K[0-9]+\.[0-9]+(\.[0-9]+)?' || echo "")
-    fi
-    echo "$runtime_ver"
+print_success() {
+    echo -e "${GREEN}[SUCCESS]${NC} $1"
 }
 
-# Get target FFmpeg version (from saved file, runtime detection, or default)
-get_ffmpeg_target_version() {
-    # 1. Check if version was saved during install
-    if [ -f "$SCRIPT_DIR/.ffmpeg-version" ]; then
-        cat "$SCRIPT_DIR/.ffmpeg-version"
-        return 0
-    fi
-
-    # 2. Try to detect from runtime
-    local runtime_ver
-    runtime_ver=$(detect_ffmpeg_runtime_version)
-    if [ -n "$runtime_ver" ]; then
-        echo "$runtime_ver"
-        return 0
-    fi
-
-    # 3. Fall back to default
-    echo "$FFMPEG_TARGET_VERSION"
+print_warning() {
+    echo -e "${YELLOW}[WARNING]${NC} $1"
 }
 
-# Ensure FFmpeg headers are available for the target version
-ensure_ffmpeg_headers() {
-    local target_ver="${1:-}"
-
-    # Auto-detect version if not specified
-    if [ -z "$target_ver" ]; then
-        target_ver=$(get_ffmpeg_target_version)
-        print_info "Target FFmpeg version: $target_ver"
-    fi
-
-    # Check if we already have matching headers
-    if [ -d "$FFMPEG_HEADERS_DIR" ] && [ -f "$FFMPEG_HEADERS_DIR/.version" ]; then
-        local existing_ver
-        existing_ver=$(cat "$FFMPEG_HEADERS_DIR/.version")
-        if [ "$existing_ver" = "$target_ver" ]; then
-            print_success "Using FFmpeg $target_ver headers from $FFMPEG_HEADERS_DIR"
-            return 0
-        else
-            print_info "Existing headers are v$existing_ver, need v$target_ver"
-        fi
-    fi
-
-    # Check system headers compatibility
-    if check_ffmpeg_abi_compatibility; then
-        print_info "System FFmpeg headers are compatible, no download needed"
-        return 0
-    fi
-
-    # Download headers for target version
-    download_ffmpeg_headers "$target_ver"
+print_error() {
+    echo -e "${RED}[ERROR]${NC} $1"
 }
 
-# =============================================================================
-# DIRETTA SDK
-# =============================================================================
+# Check if running as root
+if [ "$EUID" -eq 0 ]; then 
+    print_error "Please do not run this script as root"
+    print_info "The script will ask for sudo password when needed"
+    exit 1
+fi
+
+echo "============================================"
+echo " Diretta UPnP Renderer - Installation"
+echo "============================================"
+echo ""
+
+# Detect Linux distribution
+print_info "Detecting Linux distribution..."
+
+if [ -f /etc/os-release ]; then
+    . /etc/os-release
+    OS=$ID
+    VER=$VERSION_ID
+    print_success "Detected: $PRETTY_NAME"
+else
+    print_error "Cannot detect Linux distribution"
+    exit 1
+fi
+
+# Install dependencies based on distribution
+print_info "Installing dependencies..."
+
+case $OS in
+    fedora|rhel|centos)
+        print_info "Using DNF package manager..."
+        sudo dnf install -y \
+            gcc-c++ \
+            make \
+            git \
+            ffmpeg-devel \
+            libupnp-devel \
+            wget
+        ;;
+    
+    ubuntu|debian)
+        print_info "Using APT package manager..."
+        sudo apt update
+        sudo apt install -y \
+            build-essential \
+            git \
+            libavformat-dev \
+            libavcodec-dev \
+            libavutil-dev \
+            libswresample-dev \
+            libupnp-dev \
+            wget
+        ;;
+    
+    arch|manjaro)
+        print_info "Using Pacman package manager..."
+        sudo pacman -Sy --needed --noconfirm \
+            base-devel \
+            git \
+            ffmpeg \
+            libupnp \
+            wget
+        ;;
+    
+    *)
+        print_error "Unsupported distribution: $OS"
+        print_info "Please install dependencies manually:"
+        print_info "  - gcc/g++ (C++ compiler)"
+        print_info "  - make"
+        print_info "  - FFmpeg development libraries"
+        print_info "  - libupnp development library"
+        exit 1
+        ;;
+esac
 
-check_diretta_sdk() {
-    print_header "Diretta SDK Check"
+print_success "Dependencies installed"
 
-    # Check common SDK locations
-    local sdk_locations=(
-        "$SDK_PATH"
-        "$HOME/DirettaHostSDK_147"
-        "$HOME/DirettaHostSDK_147_19"
-        "./DirettaHostSDK_147"
-        "/opt/DirettaHostSDK_147"
-    )
+# Check for Diretta SDK
+print_info "Checking for Diretta Host SDK..."
 
-    for loc in "${sdk_locations[@]}"; do
-        if [ -d "$loc" ] && [ -d "$loc/lib" ]; then
-            SDK_PATH="$loc"
-            print_success "Found Diretta SDK at: $SDK_PATH"
-            return 0
-        fi
-    done
+SDK_PATH="$HOME/DirettaHostSDK_147"
 
-    print_warning "Diretta SDK not found"
+if [ -d "$SDK_PATH" ]; then
+    print_success "Found Diretta SDK at: $SDK_PATH"
+else
+    print_warning "Diretta SDK not found at: $SDK_PATH"
     echo ""
     echo "The Diretta Host SDK is required but not included in this repository."
     echo ""
@@ -849,152 +128,110 @@ check_diretta_sdk() {
     echo "  4. Extract to: $HOME/"
     echo ""
     read -p "Press Enter after you've downloaded and extracted the SDK..."
-
-    # Check again
-    for loc in "${sdk_locations[@]}"; do
-        if [ -d "$loc" ] && [ -d "$loc/lib" ]; then
-            SDK_PATH="$loc"
-            print_success "Found Diretta SDK at: $SDK_PATH"
-            return 0
-        fi
-    done
-
-    print_error "SDK still not found. Please extract it and try again."
-    exit 1
-}
-
-# =============================================================================
-# BUILD
-# =============================================================================
-
-build_renderer() {
-    print_header "Building Diretta UPnP Renderer"
-
-    cd "$SCRIPT_DIR"
-
-    if [ ! -f "Makefile" ]; then
-        print_error "Makefile not found in $SCRIPT_DIR"
-        exit 1
-    fi
-
-    # Ensure FFmpeg headers are available for ABI compatibility
-    print_info "Checking FFmpeg header compatibility..."
-    ensure_ffmpeg_headers  # Auto-detects version from .ffmpeg-version or runtime
-
-    # Clean and build
-    make clean 2>/dev/null || true
-
-    # Set SDK path via environment variable
-    export DIRETTA_SDK_PATH="$SDK_PATH"
-
-    # Use local FFmpeg headers if available (for ABI compatibility)
-    if [ -d "$FFMPEG_HEADERS_DIR" ] && [ -f "$FFMPEG_HEADERS_DIR/.version" ]; then
-        print_info "Building with FFmpeg headers from $FFMPEG_HEADERS_DIR"
-        make FFMPEG_PATH="$FFMPEG_HEADERS_DIR"
-    else
-        make
-    fi
-
-    if [ ! -f "bin/DirettaRendererUPnP" ]; then
-        print_error "Build failed. Please check error messages above."
+    
+    if [ ! -d "$SDK_PATH" ]; then
+        print_error "SDK still not found. Please extract it to: $SDK_PATH"
         exit 1
     fi
+    
+    print_success "SDK found!"
+fi
 
-    print_success "Build successful!"
-}
-
-# =============================================================================
-# NETWORK CONFIGURATION
-# =============================================================================
-
-configure_network() {
-    print_header "Network Configuration"
-
-    echo "Available network interfaces:"
-    ip link show | grep -E "^[0-9]+:" | awk '{print "  " $2}' | sed 's/://g'
-    echo ""
-
-    read -p "Enter network interface for Diretta (e.g., enp4s0) or press Enter to skip: " IFACE
-
-    if [ -z "$IFACE" ]; then
-        print_info "Skipping network configuration"
-        return 0
-    fi
+# Verify SDK contents
+if [ ! -f "$SDK_PATH/lib/libDirettaHost_x64-linux-15v3.a" ]; then
+    print_error "SDK libraries not found. Please check SDK installation."
+    exit 1
+fi
 
-    if ! ip link show "$IFACE" &> /dev/null; then
-        print_error "Interface $IFACE not found"
-        return 1
-    fi
+# Build the renderer
+print_info "Building Diretta UPnP Renderer..."
 
-    if confirm "Enable jumbo frames (MTU 16128) for better performance?"; then
-        sudo ip link set "$IFACE" mtu 16128
-        print_success "Jumbo frames enabled (MTU 16128)"
+if [ ! -f "Makefile" ]; then
+    print_error "Makefile not found. Are you in the correct directory?"
+    exit 1
+fi
 
-        if confirm "Make this permanent?"; then
-            case $OS in
-                fedora|rhel|centos)
-                    local conn_name
-                    conn_name=$(nmcli -t -f NAME,DEVICE connection show 2>/dev/null | grep "$IFACE" | cut -d: -f1)
-                    if [ -n "$conn_name" ]; then
-                        sudo nmcli connection modify "$conn_name" 802-3-ethernet.mtu 16128
-                        print_success "MTU configured permanently in NetworkManager"
-                    else
-                        print_warning "Could not find NetworkManager connection for $IFACE"
-                    fi
-                    ;;
-                ubuntu|debian)
-                    print_info "Add 'mtu 16128' to /etc/network/interfaces for $IFACE"
-                    ;;
-                *)
-                    print_info "Manual configuration required for permanent MTU"
-                    ;;
-            esac
-        fi
-    fi
+# Update SDK path in Makefile if needed
+print_info "Configuring Makefile..."
+sed -i "s|SDK_PATH = .*|SDK_PATH = $SDK_PATH|g" Makefile
 
-    # Network buffer optimization
-    if confirm "Optimize network buffers for audio streaming (16MB)?"; then
-        print_info "Setting network buffer sizes..."
-        sudo sysctl -w net.core.rmem_max=16777216
-        sudo sysctl -w net.core.wmem_max=16777216
-        print_success "Network buffers set to 16MB"
+# Build
+make clean
+make
 
-        if confirm "Make this permanent?"; then
-            sudo tee /etc/sysctl.d/99-diretta.conf > /dev/null <<'SYSCTL'
-# Diretta UPnP Renderer - Network buffer optimization
-# Larger buffers help with high-resolution audio streaming
-net.core.rmem_max=16777216
-net.core.wmem_max=16777216
-SYSCTL
-            sudo sysctl --system > /dev/null
-            print_success "Network buffer settings saved to /etc/sysctl.d/99-diretta.conf"
+if [ ! -f "bin/DirettaRendererUPnP" ]; then
+    print_error "Build failed. Please check error messages above."
+    exit 1
+fi
+
+print_success "Build successful!"
+
+# Configure network
+print_info "Configuring network..."
+
+echo ""
+echo "Available network interfaces:"
+ip link show | grep -E "^[0-9]+:" | awk '{print $2}' | sed 's/://g'
+echo ""
+
+read -p "Enter your network interface name (e.g., enp4s0): " IFACE
+
+if [ -z "$IFACE" ]; then
+    print_warning "No interface specified, skipping network configuration"
+else
+    # Check if interface exists
+    if ip link show "$IFACE" &> /dev/null; then
+        print_info "Configuring MTU for $IFACE..."
+        
+        # Ask about jumbo frames
+        read -p "Enable jumbo frames (MTU 9000)? [y/N]: " ENABLE_JUMBO
+        
+        if [[ "$ENABLE_JUMBO" =~ ^[Yy]$ ]]; then
+            sudo ip link set "$IFACE" mtu 9000
+            print_success "Jumbo frames enabled (MTU 9000)"
+            
+            # Offer to make permanent
+            read -p "Make this permanent? [y/N]: " MAKE_PERMANENT
+            
+            if [[ "$MAKE_PERMANENT" =~ ^[Yy]$ ]]; then
+                case $OS in
+                    fedora|rhel|centos)
+                        CONN_NAME=$(nmcli -t -f NAME,DEVICE connection show | grep "$IFACE" | cut -d: -f1)
+                        if [ -n "$CONN_NAME" ]; then
+                            sudo nmcli connection modify "$CONN_NAME" 802-3-ethernet.mtu 9000
+                            print_success "MTU configured permanently in NetworkManager"
+                        fi
+                        ;;
+                    ubuntu|debian)
+                        print_info "Add this to /etc/network/interfaces:"
+                        echo "  mtu 9000"
+                        ;;
+                    *)
+                        print_info "Manual configuration required for permanent MTU"
+                        ;;
+                esac
+            fi
+        else
+            print_info "Using standard MTU (1500)"
         fi
+    else
+        print_error "Interface $IFACE not found"
     fi
-}
-
-# =============================================================================
-# FIREWALL CONFIGURATION
-# =============================================================================
+fi
 
-configure_firewall() {
-    print_header "Firewall Configuration"
+# Firewall configuration
+print_info "Configuring firewall..."
 
-    if ! confirm "Configure firewall to allow UPnP traffic?"; then
-        print_info "Skipping firewall configuration"
-        return 0
-    fi
+read -p "Configure firewall to allow UPnP? [y/N]: " CONFIG_FIREWALL
 
+if [[ "$CONFIG_FIREWALL" =~ ^[Yy]$ ]]; then
     case $OS in
         fedora|rhel|centos)
-            if command -v firewall-cmd &> /dev/null; then
-                sudo firewall-cmd --permanent --add-port=1900/udp  # SSDP
-                sudo firewall-cmd --permanent --add-port=4005/tcp  # UPnP HTTP
-                sudo firewall-cmd --permanent --add-port=4006/tcp  # UPnP HTTP alt
-                sudo firewall-cmd --reload
-                print_success "Firewall configured (firewalld)"
-            else
-                print_info "firewalld not installed, skipping"
-            fi
+            sudo firewall-cmd --permanent --add-port=1900/udp
+            sudo firewall-cmd --permanent --add-port=4005/tcp
+            sudo firewall-cmd --permanent --add-port=4006/tcp
+            sudo firewall-cmd --reload
+            print_success "Firewall configured (firewalld)"
             ;;
         ubuntu|debian)
             if command -v ufw &> /dev/null; then
@@ -1003,7 +240,7 @@ configure_firewall() {
                 sudo ufw allow 4006/tcp
                 print_success "Firewall configured (ufw)"
             else
-                print_info "ufw not installed, skipping"
+                print_warning "ufw not found, skipping firewall configuration"
             fi
             ;;
         *)
@@ -1011,24 +248,18 @@ configure_firewall() {
             print_info "Open ports: 1900/udp, 4005/tcp, 4006/tcp"
             ;;
     esac
-}
-
-# =============================================================================
-# SYSTEMD SERVICE
-# =============================================================================
+fi
 
-setup_systemd_service() {
-    print_header "Systemd Service Setup"
+# Create systemd service
+print_info "Setting up systemd service..."
 
-    if ! confirm "Create systemd service for auto-start?"; then
-        print_info "Skipping systemd service setup"
-        return 0
-    fi
+read -p "Create systemd service for auto-start? [y/N]: " CREATE_SERVICE
 
-    local service_file="/etc/systemd/system/diretta-renderer.service"
-    local bin_path="$SCRIPT_DIR/bin/DirettaRendererUPnP"
-
-    sudo tee "$service_file" > /dev/null <<EOF
+if [[ "$CREATE_SERVICE" =~ ^[Yy]$ ]]; then
+    SERVICE_FILE="/etc/systemd/system/diretta-renderer.service"
+    BIN_PATH="$(pwd)/bin/DirettaRendererUPnP"
+    
+    sudo tee "$SERVICE_FILE" > /dev/null <<EOF
 [Unit]
 Description=Diretta UPnP Renderer
 After=network-online.target
@@ -1037,8 +268,8 @@ Wants=network-online.target
 [Service]
 Type=simple
 User=root
-WorkingDirectory=$SCRIPT_DIR/bin
-ExecStart=$bin_path --port 4005 --buffer 2.0
+WorkingDirectory=$(pwd)/bin
+ExecStart=$BIN_PATH --port 4005 --buffer 2.0
 Restart=on-failure
 RestartSec=5
 StandardOutput=journal
@@ -1050,287 +281,42 @@ AmbientCapabilities=CAP_NET_RAW CAP_NET_ADMIN
 [Install]
 WantedBy=multi-user.target
 EOF
-
+    
     sudo systemctl daemon-reload
     sudo systemctl enable diretta-renderer
-
+    
     print_success "Systemd service created and enabled"
     print_info "Start with: sudo systemctl start diretta-renderer"
     print_info "View logs with: sudo journalctl -u diretta-renderer -f"
-}
-
-# =============================================================================
-# FEDORA AGGRESSIVE OPTIMIZATION (OPTIONAL)
-# =============================================================================
-
-optimize_fedora_aggressive() {
-    print_header "Aggressive Fedora Optimization"
-
-    if [ "$OS" != "fedora" ]; then
-        print_warning "This optimization is only for Fedora systems"
-        return 1
-    fi
-
-    echo ""
-    echo "WARNING: This will make aggressive changes to your system:"
-    echo ""
-    echo "  - Remove firewalld (firewall disabled)"
-    echo "  - Remove SELinux policy (security framework disabled)"
-    echo "  - Disable systemd-journald (no persistent logs)"
-    echo "  - Disable systemd-oomd (out-of-memory daemon)"
-    echo "  - Disable systemd-homed (home directory manager)"
-    echo "  - Disable auditd (audit daemon)"
-    echo "  - Remove polkit (privilege manager)"
-    echo "  - Replace sshd with dropbear (lightweight SSH)"
-    echo ""
-    echo "This is intended for DEDICATED AUDIO SERVERS ONLY."
-    echo "Do NOT use on general-purpose systems or servers with"
-    echo "sensitive data."
-    echo ""
-
-    if ! confirm "Are you sure you want to proceed with aggressive optimization?" "N"; then
-        print_info "Optimization cancelled"
-        return 0
-    fi
-
-    echo ""
-    if ! confirm "FINAL WARNING: This will significantly reduce system security. Continue?" "N"; then
-        print_info "Optimization cancelled"
-        return 0
-    fi
-
-    print_info "Starting aggressive optimization..."
-
-    # Install kernel development tools (for potential future kernel builds)
-    print_info "Installing development tools..."
-    sudo dnf install -y kernel-devel make dwarves tar zstd rsync curl which || true
-    sudo dnf install -y gcc bc bison flex perl elfutils-libelf-devel elfutils-devel openssl openssl-devel rpm-build ncurses-devel || true
-
-    # Disable and remove security services
-    print_info "Disabling security services..."
-
-    sudo systemctl disable auditd 2>/dev/null || true
-    sudo systemctl stop auditd 2>/dev/null || true
-
-    sudo systemctl stop firewalld 2>/dev/null || true
-    sudo systemctl disable firewalld 2>/dev/null || true
-    sudo dnf remove -y firewalld 2>/dev/null || true
-
-    sudo dnf remove -y selinux-policy 2>/dev/null || true
-
-    # Disable system services that add overhead
-    print_info "Disabling system overhead services..."
-
-    sudo systemctl disable systemd-journald 2>/dev/null || true
-    sudo systemctl stop systemd-journald 2>/dev/null || true
-
-    sudo systemctl disable systemd-oomd 2>/dev/null || true
-    sudo systemctl stop systemd-oomd 2>/dev/null || true
-
-    sudo systemctl disable systemd-homed 2>/dev/null || true
-    sudo systemctl stop systemd-homed 2>/dev/null || true
-
-    sudo systemctl stop polkitd 2>/dev/null || true
-    sudo dnf remove -y polkit 2>/dev/null || true
-
-    sudo dnf remove -y gssproxy 2>/dev/null || true
-
-    # Replace sshd with dropbear
-    print_info "Installing lightweight SSH server (dropbear)..."
-    sudo dnf install -y dropbear || {
-        print_warning "Failed to install dropbear, keeping sshd"
-    }
-
-    if command -v dropbear &> /dev/null; then
-        sudo systemctl enable dropbear || true
-        sudo systemctl start dropbear || true
-
-        sudo systemctl disable sshd 2>/dev/null || true
-        sudo systemctl stop sshd 2>/dev/null || true
-
-        print_success "Dropbear installed and running"
-    fi
-
-    # Network buffer optimization for audio streaming
-    print_info "Optimizing network buffers..."
-    sudo sysctl -w net.core.rmem_max=16777216
-    sudo sysctl -w net.core.wmem_max=16777216
-    sudo tee /etc/sysctl.d/99-diretta.conf > /dev/null <<'SYSCTL'
-# Diretta UPnP Renderer - Network buffer optimization
-# Larger buffers help with high-resolution audio streaming
-net.core.rmem_max=16777216
-net.core.wmem_max=16777216
-SYSCTL
-    sudo sysctl --system > /dev/null
-    print_success "Network buffers optimized (16MB)"
-
-    # Install useful tools
-    sudo dnf install -y htop || true
-
-    print_success "Aggressive optimization complete"
-    print_warning "A reboot is recommended to apply all changes"
-
-    if confirm "Reboot now?"; then
-        sudo reboot
-    fi
-}
-
-# =============================================================================
-# MAIN MENU
-# =============================================================================
-
-show_main_menu() {
-    echo ""
-    echo "============================================"
-    echo " Diretta UPnP Renderer - Installation"
-    echo "============================================"
-    echo ""
-    echo "Installation options:"
-    echo ""
-    echo "  1) Full installation (recommended)"
-    echo "     - Install dependencies, FFmpeg, build, configure"
-    echo ""
-    echo "  2) Install dependencies only"
-    echo "     - Base packages and FFmpeg"
-    echo ""
-    echo "  3) Build only"
-    echo "     - Assumes dependencies are installed"
-    echo ""
-    echo "  4) Configure only"
-    echo "     - Network, firewall, systemd service"
-    echo ""
-    if [ "$OS" = "fedora" ]; then
-    echo "  5) Aggressive Fedora optimization"
-    echo "     - For dedicated audio servers only"
-    echo ""
-    fi
-    echo "  q) Quit"
-    echo ""
-}
-
-run_full_installation() {
-    install_base_dependencies
-    install_ffmpeg
-    check_diretta_sdk
-    build_renderer
-    configure_network
-    configure_firewall
-    setup_systemd_service
-
-    print_header "Installation Complete!"
-
-    echo ""
-    echo "Quick Start:"
-    echo "  1. Start the renderer:"
-    echo "     sudo ./bin/DirettaRendererUPnP --port 4005 --buffer 2.0"
-    echo ""
-    echo "  2. Or use systemd service:"
-    echo "     sudo systemctl start diretta-renderer"
-    echo ""
-    echo "  3. Open your UPnP control point (JPlay, BubbleUPnP, etc.)"
-    echo "  4. Select 'Diretta Renderer' as output device"
-    echo ""
-    echo "Documentation:"
-    echo "  - README.md - Overview and quick start"
-    echo "  - docs/CONFIGURATION.md - Configuration options"
-    echo "  - docs/TROUBLESHOOTING.md - Problem solving"
-    echo ""
-}
-
-# =============================================================================
-# ENTRY POINT
-# =============================================================================
-
-main() {
-    detect_system
-
-    # Check for command-line arguments
-    case "${1:-}" in
-        --full|-f)
-            run_full_installation
-            exit 0
-            ;;
-        --deps|-d)
-            install_base_dependencies
-            install_ffmpeg
-            exit 0
-            ;;
-        --build|-b)
-            check_diretta_sdk
-            build_renderer
-            exit 0
-            ;;
-        --configure|-c)
-            configure_network
-            configure_firewall
-            setup_systemd_service
-            exit 0
-            ;;
-        --optimize|-o)
-            optimize_fedora_aggressive
-            exit 0
-            ;;
-        --help|-h)
-            echo "Usage: $0 [OPTION]"
-            echo ""
-            echo "Options:"
-            echo "  --full, -f       Full installation"
-            echo "  --deps, -d       Install dependencies only"
-            echo "  --build, -b      Build only"
-            echo "  --configure, -c  Configure only"
-            echo "  --optimize, -o   Aggressive Fedora optimization"
-            echo "  --help, -h       Show this help"
-            echo ""
-            echo "Without options, shows interactive menu."
-            exit 0
-            ;;
-    esac
-
-    # Interactive menu
-    while true; do
-        show_main_menu
-
-        local max_option=4
-        [ "$OS" = "fedora" ] && max_option=5
-
-        read -p "Choose option [1-$max_option/q]: " choice
-
-        case $choice in
-            1)
-                run_full_installation
-                break
-                ;;
-            2)
-                install_base_dependencies
-                install_ffmpeg
-                print_success "Dependencies installed"
-                ;;
-            3)
-                check_diretta_sdk
-                build_renderer
-                ;;
-            4)
-                configure_network
-                configure_firewall
-                setup_systemd_service
-                ;;
-            5)
-                if [ "$OS" = "fedora" ]; then
-                    optimize_fedora_aggressive
-                else
-                    print_error "Invalid option"
-                fi
-                ;;
-            q|Q)
-                print_info "Exiting..."
-                exit 0
-                ;;
-            *)
-                print_error "Invalid option: $choice"
-                ;;
-        esac
-    done
-}
-
-# Run main
-main "$@"
+fi
+
+# Installation complete
+echo ""
+echo "============================================"
+echo " Installation Complete! 🎉"
+echo "============================================"
+echo ""
+print_success "Diretta UPnP Renderer is ready to use!"
+echo ""
+echo "Quick Start:"
+echo "  1. Start the renderer:"
+echo "     sudo ./bin/DirettaRendererUPnP --port 4005 --buffer 2.0"
+echo ""
+echo "  2. Or use systemd service:"
+echo "     sudo systemctl start diretta-renderer"
+echo ""
+echo "  3. Open your UPnP control point (JPlay, BubbleUPnP, etc.)"
+echo "  4. Select 'Diretta Renderer' as output device"
+echo "  5. Enjoy your music! 🎵"
+echo ""
+echo "Documentation:"
+echo "  - README.md - Overview and quick start"
+echo "  - docs/INSTALLATION.md - Detailed installation"
+echo "  - docs/CONFIGURATION.md - Configuration options"
+echo "  - docs/TROUBLESHOOTING.md - Problem solving"
+echo ""
+echo "Support:"
+echo "  - GitHub Issues: Report bugs or request features"
+echo "  - Diretta Website: https://www.diretta.link"
+echo ""
+print_info "Have fun streaming! 🎧"
diff --git a/src/AudioEngine.cpp b/src/AudioEngine.cpp
index e7fc9d5..2bc0a37 100644
--- a/src/AudioEngine.cpp
+++ b/src/AudioEngine.cpp
@@ -4,7 +4,6 @@
  */
 
 #include "AudioEngine.h"
-#include "DirettaRingBuffer.h"  // For kBitReverseLUT
 #include <iostream>
 #include <thread>
 #include <cstring>
@@ -77,13 +76,13 @@ AudioDecoder::AudioDecoder()
     , m_swrContext(nullptr)
     , m_audioStreamIndex(-1)
     , m_eof(false)
-    , m_rawDSD(false)         // DSD mode off by default
-    , m_packet(nullptr)       // Reusable packet for raw reading
-    , m_frame(nullptr)        // Reusable frame for PCM decoding
-    , m_dsdRemainderCount(0)  // DSD packet fragment counter
-    , m_pcmFifo(nullptr)      // PCM overflow FIFO
+    , m_rawDSD(false)
+    , m_packet(nullptr)
+    , m_frame(nullptr)
+    , m_dsdRemainderCount(0)
+    , m_pcmFifo(nullptr)
     , m_resampleBufferCapacity(0)
-    , m_bypassMode(false)     // PCM bypass disabled by default
+    , m_bypassMode(false)
     , m_resamplerInitialized(false)
 {
 }
@@ -156,21 +155,22 @@ bool AudioDecoder::open(const std::string& url) {
         DEBUG_LOG("[AudioDecoder] Stream duration: unknown (live stream?)");
     }
 
-    // Find audio stream using FFmpeg's recommended API (handles NULL codecpar in FFmpeg 5.x)
-    m_audioStreamIndex = av_find_best_stream(m_formatContext, AVMEDIA_TYPE_AUDIO, -1, -1, nullptr, 0);
+    // Find audio stream
+    m_audioStreamIndex = -1;
+    for (unsigned int i = 0; i < m_formatContext->nb_streams; i++) {
+        if (m_formatContext->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
+            m_audioStreamIndex = i;
+            break;
+        }
+    }
 
-    if (m_audioStreamIndex < 0) {
+    if (m_audioStreamIndex == -1) {
         std::cerr << "[AudioDecoder] No audio stream found" << std::endl;
         avformat_close_input(&m_formatContext);
         return false;
     }
 
     AVStream* audioStream = m_formatContext->streams[m_audioStreamIndex];
-    if (!audioStream || !audioStream->codecpar) {
-        std::cerr << "[AudioDecoder] Audio stream has invalid codec parameters" << std::endl;
-        avformat_close_input(&m_formatContext);
-        return false;
-    }
     AVCodecParameters* codecpar = audioStream->codecpar;
 
     // ═══════════════════════════════════════════════════════════
@@ -234,6 +234,37 @@ bool AudioDecoder::open(const std::string& url) {
         return false;
     }
 
+    // Request packed output format BEFORE avcodec_open2()
+    // This enables bypass mode for integer formats (S16P→S16, S32P→S32)
+    // IMPORTANT: Float formats (FLT, FLTP) are NOT eligible - would corrupt audio
+    AVSampleFormat srcFmt = m_codecContext->sample_fmt;
+    AVSampleFormat preferredFormat = AV_SAMPLE_FMT_NONE;
+
+    if (srcFmt == AV_SAMPLE_FMT_S16P)
+        preferredFormat = AV_SAMPLE_FMT_S16;
+    else if (srcFmt == AV_SAMPLE_FMT_S32P)
+        preferredFormat = AV_SAMPLE_FMT_S32;
+    // NOTE: Do NOT request FLT for FLTP - float bypass would corrupt audio
+
+    // Check if decoder actually supports packed format before requesting
+    // Some decoders only support planar output - requesting unsupported format
+    // causes avcodec_open2() to fail with EINVAL
+    if (preferredFormat != AV_SAMPLE_FMT_NONE && codec->sample_fmts != nullptr) {
+        bool packedSupported = false;
+        for (const AVSampleFormat* fmt = codec->sample_fmts; *fmt != AV_SAMPLE_FMT_NONE; fmt++) {
+            if (*fmt == preferredFormat) {
+                packedSupported = true;
+                break;
+            }
+        }
+        if (packedSupported) {
+            m_codecContext->request_sample_fmt = preferredFormat;
+            DEBUG_LOG("[AudioDecoder] Requesting packed format: " << av_get_sample_fmt_name(preferredFormat));
+        } else {
+            DEBUG_LOG("[AudioDecoder] Packed format not supported by decoder, will use swr");
+        }
+    }
+
     // Open codec
     if (avcodec_open2(m_codecContext, codec, nullptr) < 0) {
         std::cerr << "[AudioDecoder] Failed to open codec" << std::endl;
@@ -346,7 +377,6 @@ bool AudioDecoder::open(const std::string& url) {
             m_rawDSD = true;
             m_packet = av_packet_alloc();
 
-#ifdef DIRETTA_DSD_DIAGNOSTICS
             std::cout << "\n[DSD DIAGNOSTIC] Reading first packets to understand layout:" << std::endl;
             for (int i = 0; i < 3; i++) {
                 AVPacket* testPkt = av_packet_alloc();
@@ -390,7 +420,6 @@ bool AudioDecoder::open(const std::string& url) {
             // Seek back to beginning
             av_seek_frame(m_formatContext, m_audioStreamIndex, 0, AVSEEK_FLAG_BACKWARD);
             std::cout << "[DSD DIAGNOSTIC] Seek back to start complete\n" << std::endl;
-#endif // DIRETTA_DSD_DIAGNOSTICS
 
             // DO NOT open codec for DSD!
             // We'll read raw packets with av_read_frame()
@@ -495,28 +524,14 @@ bool AudioDecoder::open(const std::string& url) {
 
     m_trackInfo.bitDepth = realBitDepth;
 
-    // Detect S24 alignment hint for 24-bit content
-    // This hint helps the ring buffer when track starts with silence
-    m_trackInfo.s24Alignment = TrackInfo::S24Alignment::Unknown;
-    if (realBitDepth == 24) {
-        // PCM_S24LE/BE codecs: data is truly 24-bit, packed LSB-aligned in 32-bit
-        if (codecpar->codec_id == AV_CODEC_ID_PCM_S24LE ||
-            codecpar->codec_id == AV_CODEC_ID_PCM_S24BE) {
-            m_trackInfo.s24Alignment = TrackInfo::S24Alignment::LsbAligned;
-            DEBUG_LOG("[AudioDecoder] S24 hint: LSB-aligned (PCM_S24)");
-        }
-        // FLAC/ALAC with 24-bit: typically LSB-aligned in S32 container
-        else if (codecpar->codec_id == AV_CODEC_ID_FLAC ||
-                 codecpar->codec_id == AV_CODEC_ID_ALAC) {
-            m_trackInfo.s24Alignment = TrackInfo::S24Alignment::LsbAligned;
-            DEBUG_LOG("[AudioDecoder] S24 hint: LSB-aligned (FLAC/ALAC)");
-        }
-        // Other decoders: check sample format
-        else if (m_codecContext->sample_fmt == AV_SAMPLE_FMT_S32 ||
-                 m_codecContext->sample_fmt == AV_SAMPLE_FMT_S32P) {
-            // S32 format with 24-bit content is typically LSB-aligned
+    // Detect S24 alignment hint from FFmpeg
+    // NOTE: bits_per_coded_sample indicates container size, NOT byte alignment
+    // This is a HINT only - sample-based detection in DirettaRingBuffer takes priority
+    if (m_trackInfo.bitDepth == 24) {
+        if (codecpar->bits_per_coded_sample == 32 || codecpar->bits_per_raw_sample == 24) {
+            // Most 24-in-32 is LSB-aligned, but MSB-aligned exists (left-justified)
             m_trackInfo.s24Alignment = TrackInfo::S24Alignment::LsbAligned;
-            DEBUG_LOG("[AudioDecoder] S24 hint: LSB-aligned (S32 format)");
+            DEBUG_LOG("[AudioDecoder] S24 hint: LsbAligned (from bits_per_coded_sample)");
         }
     }
 
@@ -548,13 +563,13 @@ void AudioDecoder::close() {
     if (m_codecContext) {
         avcodec_free_context(&m_codecContext);
     }
-    if (m_frame) {  // Free reusable frame
+    if (m_frame) {
         av_frame_free(&m_frame);
     }
-    if (m_packet) {  // Free reusable packet
+    if (m_packet) {
         av_packet_free(&m_packet);
     }
-    if (m_pcmFifo) {  // Free PCM overflow FIFO
+    if (m_pcmFifo) {
         av_audio_fifo_free(m_pcmFifo);
         m_pcmFifo = nullptr;
     }
@@ -564,10 +579,8 @@ void AudioDecoder::close() {
     m_audioStreamIndex = -1;
     m_eof = false;
     m_rawDSD = false;
-    m_resampleBufferCapacity = 0;  // Reset capacity tracking
-    m_dsdBufferCapacity = 0;       // Reset DSD buffer capacity tracking
-    m_dsdRemainderCount = 0;       // Reset DSD packet remainder
-    m_bypassMode = false;          // Reset PCM bypass mode
+    m_resampleBufferCapacity = 0;
+    m_bypassMode = false;
     m_resamplerInitialized = false;
 }
 
@@ -587,41 +600,36 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
         size_t totalBytesNeeded = (numSamples * m_trackInfo.channels) / 8;
         size_t bytesPerChannelNeeded = totalBytesNeeded / m_trackInfo.channels;
 
-        // Ensure pre-allocated DSD buffers are large enough (resize only if capacity insufficient)
-        if (m_dsdBufferCapacity < bytesPerChannelNeeded) {
-            m_dsdLeftBuffer.resize(bytesPerChannelNeeded);
-            m_dsdRightBuffer.resize(bytesPerChannelNeeded);
-            m_dsdBufferCapacity = bytesPerChannelNeeded;
-        }
-
-        // Use offset tracking instead of vector operations (zero allocations)
-        size_t leftOffset = 0;
-        size_t rightOffset = 0;
-        uint8_t* leftData = m_dsdLeftBuffer.data();
-        uint8_t* rightData = m_dsdRightBuffer.data();
+        // Vectors to collect L and R data
+        std::vector<uint8_t> leftData;
+        std::vector<uint8_t> rightData;
+        leftData.reserve(bytesPerChannelNeeded);
+        rightData.reserve(bytesPerChannelNeeded);
 
         // Ensure output buffer is large enough
         if (buffer.size() < totalBytesNeeded) {
             buffer.resize(totalBytesNeeded);
         }
 
-        // Use remaining data from previous DSD packet reads
+        // Use remaining data from previous reads
         if (m_dsdRemainderCount > 0) {
             size_t remainingPerCh = m_dsdRemainderCount / 2;
             size_t toUse = std::min(remainingPerCh, bytesPerChannelNeeded);
 
-            memcpy(leftData + leftOffset, m_dsdPacketRemainder.data(), toUse);
-            leftOffset += toUse;
-            memcpy(rightData + rightOffset, m_dsdPacketRemainder.data() + remainingPerCh, toUse);
-            rightOffset += toUse;
+            leftData.insert(leftData.end(),
+                           m_dsdRemainderBuffer.data(),
+                           m_dsdRemainderBuffer.data() + toUse);
+            rightData.insert(rightData.end(),
+                            m_dsdRemainderBuffer.data() + remainingPerCh,
+                            m_dsdRemainderBuffer.data() + remainingPerCh + toUse);
 
             if (toUse < remainingPerCh) {
                 size_t leftover = remainingPerCh - toUse;
-                memmove(m_dsdPacketRemainder.data(),
-                        m_dsdPacketRemainder.data() + toUse,
+                memmove(m_dsdRemainderBuffer.data(),
+                        m_dsdRemainderBuffer.data() + toUse,
                         leftover);
-                memmove(m_dsdPacketRemainder.data() + leftover,
-                        m_dsdPacketRemainder.data() + remainingPerCh + toUse,
+                memmove(m_dsdRemainderBuffer.data() + leftover,
+                        m_dsdRemainderBuffer.data() + remainingPerCh + toUse,
                         leftover);
                 m_dsdRemainderCount = leftover * 2;
             } else {
@@ -631,7 +639,7 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
 
         // Read packets until we have enough data
         // DSF layout: each packet is [blockSize L][blockSize R]
-        while (leftOffset < bytesPerChannelNeeded && !m_eof) {
+        while (leftData.size() < bytesPerChannelNeeded && !m_eof) {
             int ret = av_read_frame(m_formatContext, m_packet);
             if (ret < 0) {
                 if (ret == AVERROR_EOF) {
@@ -653,13 +661,11 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
             const uint8_t* pktL = m_packet->data;
             const uint8_t* pktR = m_packet->data + blockSize;
 
-            size_t stillNeed = bytesPerChannelNeeded - leftOffset;
+            size_t stillNeed = bytesPerChannelNeeded - leftData.size();
             size_t toTake = std::min(blockSize, stillNeed);
 
-            memcpy(leftData + leftOffset, pktL, toTake);
-            leftOffset += toTake;
-            memcpy(rightData + rightOffset, pktR, toTake);
-            rightOffset += toTake;
+            leftData.insert(leftData.end(), pktL, pktL + toTake);
+            rightData.insert(rightData.end(), pktR, pktR + toTake);
 
             // Debug first few packets
             if (m_packetCount <= 3) {
@@ -675,14 +681,14 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
                 printf("\n");
             }
 
-            // Save DSD packet excess
+            // Save excess
             if (toTake < blockSize) {
                 size_t excess = blockSize - toTake;
-                if (m_dsdPacketRemainder.size() < excess * 2) {
-                    m_dsdPacketRemainder.resize(excess * 2);
+                if (m_dsdRemainderBuffer.size() < excess * 2) {
+                    m_dsdRemainderBuffer.resize(excess * 2);
                 }
-                memcpy_audio(m_dsdPacketRemainder.data(), pktL + toTake, excess);
-                memcpy_audio(m_dsdPacketRemainder.data() + excess, pktR + toTake, excess);
+                memcpy_audio(m_dsdRemainderBuffer.data(), pktL + toTake, excess);
+                memcpy_audio(m_dsdRemainderBuffer.data() + excess, pktR + toTake, excess);
                 m_dsdRemainderCount = excess * 2;
             }
 
@@ -690,12 +696,12 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
         }
 
         // Build output: [all L][all R]
-        size_t actualPerCh = std::min(leftOffset, rightOffset);
+        size_t actualPerCh = std::min(leftData.size(), rightData.size());
         size_t totalBytes = actualPerCh * 2;
 
         if (actualPerCh > 0) {
-            memcpy_audio(buffer.data(), leftData, actualPerCh);
-            memcpy_audio(buffer.data() + actualPerCh, rightData, actualPerCh);
+            memcpy_audio(buffer.data(), leftData.data(), actualPerCh);
+            memcpy_audio(buffer.data() + actualPerCh, rightData.data(), actualPerCh);
         }
 
         // Debug output
@@ -711,8 +717,24 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
 
         // Bit reversal for DFF (MSB) files - DSF is LSB, no reversal needed
         if (m_trackInfo.codec.find("msbf") != std::string::npos) {
-            // Use shared LUT from DirettaRingBuffer (cache-friendly, single copy in memory)
-            const uint8_t* rev = DirettaRingBuffer::kBitReverseLUT;
+            static const uint8_t rev[256] = {
+                0x00,0x80,0x40,0xC0,0x20,0xA0,0x60,0xE0,0x10,0x90,0x50,0xD0,0x30,0xB0,0x70,0xF0,
+                0x08,0x88,0x48,0xC8,0x28,0xA8,0x68,0xE8,0x18,0x98,0x58,0xD8,0x38,0xB8,0x78,0xF8,
+                0x04,0x84,0x44,0xC4,0x24,0xA4,0x64,0xE4,0x14,0x94,0x54,0xD4,0x34,0xB4,0x74,0xF4,
+                0x0C,0x8C,0x4C,0xCC,0x2C,0xAC,0x6C,0xEC,0x1C,0x9C,0x5C,0xDC,0x3C,0xBC,0x7C,0xFC,
+                0x02,0x82,0x42,0xC2,0x22,0xA2,0x62,0xE2,0x12,0x92,0x52,0xD2,0x32,0xB2,0x72,0xF2,
+                0x0A,0x8A,0x4A,0xCA,0x2A,0xAA,0x6A,0xEA,0x1A,0x9A,0x5A,0xDA,0x3A,0xBA,0x7A,0xFA,
+                0x06,0x86,0x46,0xC6,0x26,0xA6,0x66,0xE6,0x16,0x96,0x56,0xD6,0x36,0xB6,0x76,0xF6,
+                0x0E,0x8E,0x4E,0xCE,0x2E,0xAE,0x6E,0xEE,0x1E,0x9E,0x5E,0xDE,0x3E,0xBE,0x7E,0xFE,
+                0x01,0x81,0x41,0xC1,0x21,0xA1,0x61,0xE1,0x11,0x91,0x51,0xD1,0x31,0xB1,0x71,0xF1,
+                0x09,0x89,0x49,0xC9,0x29,0xA9,0x69,0xE9,0x19,0x99,0x59,0xD9,0x39,0xB9,0x79,0xF9,
+                0x05,0x85,0x45,0xC5,0x25,0xA5,0x65,0xE5,0x15,0x95,0x55,0xD5,0x35,0xB5,0x75,0xF5,
+                0x0D,0x8D,0x4D,0xCD,0x2D,0xAD,0x6D,0xED,0x1D,0x9D,0x5D,0xDD,0x3D,0xBD,0x7D,0xFD,
+                0x03,0x83,0x43,0xC3,0x23,0xA3,0x63,0xE3,0x13,0x93,0x53,0xD3,0x33,0xB3,0x73,0xF3,
+                0x0B,0x8B,0x4B,0xCB,0x2B,0xAB,0x6B,0xEB,0x1B,0x9B,0x5B,0xDB,0x3B,0xBB,0x7B,0xFB,
+                0x07,0x87,0x47,0xC7,0x27,0xA7,0x67,0xE7,0x17,0x97,0x57,0xD7,0x37,0xB7,0x77,0xF7,
+                0x0F,0x8F,0x4F,0xCF,0x2F,0xAF,0x6F,0xEF,0x1F,0x9F,0x5F,0xDF,0x3F,0xBF,0x7F,0xFF
+            };
             for (size_t i = 0; i < totalBytes; i++) {
                 buffer.data()[i] = rev[buffer.data()[i]];
             }
@@ -730,7 +752,8 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
     }
 
     // Initialize resampler if needed (not for DSD)
-    if (!m_trackInfo.isDSD && !m_swrContext) {
+    // Uses m_resamplerInitialized flag to track init state (covers both bypass and swr modes)
+    if (!m_trackInfo.isDSD && !m_resamplerInitialized) {
         if (!initResampler(outputRate, outputBits)) {
             return 0;
         }
@@ -754,10 +777,10 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
 
     uint8_t* outputPtr = buffer.data();
 
-    // First, drain any samples from PCM FIFO (O(1) circular buffer read)
+    // First, drain any samples from FIFO (O(1) read from circular buffer)
     if (m_pcmFifo && av_audio_fifo_size(m_pcmFifo) > 0) {
         int fifoSamples = av_audio_fifo_size(m_pcmFifo);
-        int samplesToRead = std::min(fifoSamples, (int)(numSamples - totalSamplesRead));
+        int samplesToRead = std::min(fifoSamples, (int)numSamples);
 
         uint8_t* readPtrs[1] = { outputPtr };
         int samplesRead = av_audio_fifo_read(m_pcmFifo, (void**)readPtrs, samplesToRead);
@@ -767,13 +790,13 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
             totalSamplesRead += samplesRead;
         }
 
-        // If FIFO provided enough samples, return early
+        // If we have enough samples, return now
         if (totalSamplesRead >= numSamples) {
             return totalSamplesRead;
         }
     }
 
-    // Lazy initialization of reusable structures (allocated once, reused via unref)
+    // Lazy initialization of reusable members
     if (!m_packet) {
         m_packet = av_packet_alloc();
     }
@@ -782,7 +805,7 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
     }
 
     if (!m_packet || !m_frame) {
-        return totalSamplesRead; // Retourner ce qu'on a déjà lu du buffer
+        return totalSamplesRead;
     }
 
     while (totalSamplesRead < numSamples && !m_eof) {
@@ -876,7 +899,7 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
                 totalSamplesRead += frameSamples;
 
             } else {
-                // PCM: Resample if needed, or bypass for bit-perfect playback
+                // PCM: Resample if needed, or bypass if formats match
                 size_t samplesNeeded = numSamples - totalSamplesRead;
 
                 if (m_bypassMode) {
@@ -888,7 +911,7 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
                     outputPtr += bytesToCopy;
                     totalSamplesRead += samplesToCopy;
 
-                    // Store excess samples in FIFO
+                    // Store excess in FIFO
                     if (frameSamples > samplesToCopy && m_pcmFifo) {
                         size_t excess = frameSamples - samplesToCopy;
                         uint8_t* excessPtr = m_frame->data[0] + bytesToCopy;
@@ -896,60 +919,77 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
 
                         int written = av_audio_fifo_write(m_pcmFifo, (void**)excessPtrs, excess);
                         if (written < 0) {
-                            std::cerr << "[AudioDecoder] FIFO write failed (bypass): " << written << std::endl;
+                            std::cerr << "[AudioDecoder] FIFO write failed: " << written << std::endl;
                         }
                     }
                 } else if (m_swrContext) {
-                    // Calculate TOTAL output samples (without limiting)
-                    int64_t totalOutSamples = av_rescale_rnd(
+                    // Max possible output samples for this frame (upper bound)
+                    int64_t maxOutSamples = av_rescale_rnd(
                         swr_get_delay(m_swrContext, m_codecContext->sample_rate) + frameSamples,
                         outputRate,
                         m_codecContext->sample_rate,
                         AV_ROUND_UP
                     );
-
-                    // Reuse member buffer with capacity growth (eliminates per-call allocation)
-                    size_t tempBufferSize = totalOutSamples * bytesPerSample;
-                    if (tempBufferSize > m_resampleBufferCapacity) {
-                        // Grow with 50% headroom to reduce future reallocations
-                        size_t newCapacity = static_cast<size_t>(tempBufferSize * 1.5);
-                        m_resampleBuffer.resize(newCapacity);
-                        m_resampleBufferCapacity = m_resampleBuffer.size();
+                    if (maxOutSamples < 0) {
+                        maxOutSamples = 0;
                     }
-                    uint8_t* tempPtr = m_resampleBuffer.data();
-
-                    // Convertir TOUTE la frame
-                    int convertedSamples = swr_convert(
-                        m_swrContext,
-                        &tempPtr,
-                        totalOutSamples,
-                        (const uint8_t**)m_frame->data,
-                        frameSamples
-                    );
 
-                    if (convertedSamples > 0) {
-                        // Déterminer combien on peut utiliser maintenant
-                        size_t samplesToUse = std::min((size_t)convertedSamples, samplesNeeded);
-                        size_t bytesToUse = samplesToUse * bytesPerSample;
-
-                        // Copier vers le buffer de sortie
-                        memcpy_audio(outputPtr, m_resampleBuffer.data(), bytesToUse);
-                        outputPtr += bytesToUse;
-                        totalSamplesRead += samplesToUse;
-
-                        // Store excess samples in FIFO (O(1) write to circular buffer)
-                        if ((size_t)convertedSamples > samplesToUse && m_pcmFifo) {
-                            size_t excess = convertedSamples - samplesToUse;
-                            uint8_t* excessPtr = m_resampleBuffer.data() + bytesToUse;
-                            uint8_t* excessPtrs[1] = { excessPtr };
-
-                            int written = av_audio_fifo_write(m_pcmFifo, (void**)excessPtrs, excess);
-                            if (written < 0) {
-                                std::cerr << "[AudioDecoder] FIFO write failed: " << written << std::endl;
-                            } else if (!m_resamplerInitLogged) {
-                                std::cout << "[AudioDecoder] FIFO buffering " << excess
-                                          << " excess samples for next read" << std::endl;
-                                m_resamplerInitLogged = true;
+                    if (maxOutSamples > 0 && (size_t)maxOutSamples <= samplesNeeded) {
+                        // Fast path: resample directly into caller buffer
+                        uint8_t* outPtrs[1] = { outputPtr };
+                        int convertedSamples = swr_convert(
+                            m_swrContext,
+                            outPtrs,
+                            maxOutSamples,
+                            (const uint8_t**)m_frame->data,
+                            frameSamples
+                        );
+
+                        if (convertedSamples > 0) {
+                            outputPtr += convertedSamples * bytesPerSample;
+                            totalSamplesRead += convertedSamples;
+                        }
+                    } else {
+                        // Temp buffer path: convert full frame, then copy and FIFO excess
+                        size_t tempBufferSize = static_cast<size_t>(maxOutSamples) * bytesPerSample;
+                        if (tempBufferSize > m_resampleBufferCapacity) {
+                            // Grow with 50% headroom to reduce future reallocations
+                            size_t newCapacity = static_cast<size_t>(tempBufferSize * 1.5);
+                            m_resampleBuffer.resize(newCapacity);
+                            m_resampleBufferCapacity = m_resampleBuffer.size();
+                        }
+                        uint8_t* tempPtr = m_resampleBuffer.data();
+
+                        int convertedSamples = swr_convert(
+                            m_swrContext,
+                            &tempPtr,
+                            maxOutSamples,
+                            (const uint8_t**)m_frame->data,
+                            frameSamples
+                        );
+
+                        if (convertedSamples > 0) {
+                            size_t samplesToUse = std::min((size_t)convertedSamples, samplesNeeded);
+                            size_t bytesToUse = samplesToUse * bytesPerSample;
+
+                            // Copy needed samples to output
+                            memcpy_audio(outputPtr, m_resampleBuffer.data(), bytesToUse);
+                            outputPtr += bytesToUse;
+                            totalSamplesRead += samplesToUse;
+
+                            // Store excess in FIFO (O(1) write, replaces manual buffer)
+                            if ((size_t)convertedSamples > samplesToUse && m_pcmFifo) {
+                                size_t excess = convertedSamples - samplesToUse;
+                                uint8_t* excessPtr = m_resampleBuffer.data() + bytesToUse;
+                                uint8_t* excessPtrs[1] = { excessPtr };
+
+                                int written = av_audio_fifo_write(m_pcmFifo, (void**)excessPtrs, excess);
+                                if (written < 0) {
+                                    std::cerr << "[AudioDecoder] FIFO write failed: " << written << std::endl;
+                                } else if ((size_t)written != excess) {
+                                    std::cerr << "[AudioDecoder] FIFO partial write: " << written
+                                              << "/" << excess << " samples" << std::endl;
+                                }
                             }
                         }
                     }
@@ -962,7 +1002,7 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
                     outputPtr += bytesToCopy;
                     totalSamplesRead += samplesToCopy;
 
-                    // Store excess samples in FIFO (O(1) write to circular buffer)
+                    // Store excess in FIFO (O(1) write, replaces manual buffer)
                     if (frameSamples > samplesToCopy && m_pcmFifo) {
                         size_t excess = frameSamples - samplesToCopy;
                         uint8_t* excessPtr = m_frame->data[0] + bytesToCopy;
@@ -971,9 +1011,9 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
                         int written = av_audio_fifo_write(m_pcmFifo, (void**)excessPtrs, excess);
                         if (written < 0) {
                             std::cerr << "[AudioDecoder] FIFO write failed: " << written << std::endl;
-                        } else {
-                            std::cout << "[AudioDecoder] FIFO buffering " << excess
-                                      << " excess samples (no resampling)" << std::endl;
+                        } else if ((size_t)written != excess) {
+                            std::cerr << "[AudioDecoder] FIFO partial write: " << written
+                                      << "/" << excess << " samples" << std::endl;
                         }
                     }
                 }
@@ -983,52 +1023,82 @@ size_t AudioDecoder::readSamples(AudioBuffer& buffer, size_t numSamples,
         }
     }
 
-    // Unref for reuse (no deallocation - freed in close())
+    // Unref for reuse (no deallocation)
     av_packet_unref(m_packet);
     av_frame_unref(m_frame);
 
     return totalSamplesRead;
 }
 
+bool AudioDecoder::canBypass(uint32_t outputRate, uint32_t outputBits) const {
+    // DSD never uses bypass (handled separately)
+    if (m_trackInfo.isDSD) {
+        return false;
+    }
+
+    // Must have codec context
+    if (!m_codecContext) {
+        return false;
+    }
+
+    // Sample rate must match exactly
+    if (m_codecContext->sample_rate != (int)outputRate) {
+        DEBUG_LOG("[AudioDecoder] canBypass: NO (sample rate mismatch: "
+                  << m_codecContext->sample_rate << " vs " << outputRate << ")");
+        return false;
+    }
+
+    // Channel count must match (currently always 2)
+    if (m_codecContext->ch_layout.nb_channels != (int)m_trackInfo.channels) {
+        DEBUG_LOG("[AudioDecoder] canBypass: NO (channel mismatch)");
+        return false;
+    }
+
+    // Format must be integer packed (NOT planar, NOT float)
+    AVSampleFormat fmt = m_codecContext->sample_fmt;
+    bool isPackedInteger = (fmt == AV_SAMPLE_FMT_S16 || fmt == AV_SAMPLE_FMT_S32);
+
+    if (!isPackedInteger) {
+        DEBUG_LOG("[AudioDecoder] canBypass: NO (format " << av_get_sample_fmt_name(fmt)
+                  << " requires conversion)");
+        return false;
+    }
+
+    // Bit depth must match (with special case for 24-bit in S32 container)
+    bool is24BitIn32 = (m_trackInfo.bitDepth == 24 && fmt == AV_SAMPLE_FMT_S32);
+    bool bitDepthMatch = (m_trackInfo.bitDepth == outputBits) || is24BitIn32;
+
+    if (!bitDepthMatch) {
+        DEBUG_LOG("[AudioDecoder] canBypass: NO (bit depth mismatch: "
+                  << m_trackInfo.bitDepth << " vs " << outputBits << ")");
+        return false;
+    }
+
+    DEBUG_LOG("[AudioDecoder] canBypass: YES (bit-perfect path enabled)");
+    return true;
+}
+
 bool AudioDecoder::initResampler(uint32_t outputRate, uint32_t outputBits) {
     // Don't resample DSD!
     if (m_trackInfo.isDSD) {
         std::cout << "[AudioDecoder] DSD: No resampling, native passthrough" << std::endl;
+        m_resamplerInitialized = true;
         return true;
     }
 
-    // Determine output format
-    AVSampleFormat outFormat;
-    switch (outputBits) {
-        case 16:
-            outFormat = AV_SAMPLE_FMT_S16;
-            break;
-        case 24:
-        case 32:
-            outFormat = AV_SAMPLE_FMT_S32;
-            break;
-        default:
-            outFormat = AV_SAMPLE_FMT_S32;
-            break;
-    }
-
-    // Check if we can bypass resampling entirely (bit-perfect path)
+    // Check if we can bypass resampling entirely
     if (canBypass(outputRate, outputBits)) {
         std::cout << "[AudioDecoder] PCM BYPASS enabled - bit-perfect path" << std::endl;
 
-        // Free existing resampler if any
-        if (m_swrContext) {
-            swr_free(&m_swrContext);
-        }
-
         // Still need FIFO for frame overflow handling
         if (m_pcmFifo) {
             av_audio_fifo_free(m_pcmFifo);
             m_pcmFifo = nullptr;
         }
 
-        // Smaller FIFO for bypass (less overflow expected)
-        int fifoSize = 8192;
+        AVSampleFormat outFormat = (outputBits == 16) ? AV_SAMPLE_FMT_S16 : AV_SAMPLE_FMT_S32;
+        size_t fifoSize = 8192;
+        if (outputRate > 96000) fifoSize = 16384;
         if (outputRate > 192000) fifoSize = 32768;
 
         m_pcmFifo = av_audio_fifo_alloc(outFormat, m_trackInfo.channels, fifoSize);
@@ -1051,6 +1121,21 @@ bool AudioDecoder::initResampler(uint32_t outputRate, uint32_t outputBits) {
         swr_free(&m_swrContext);
     }
 
+    // Determine output format
+    AVSampleFormat outFormat;
+    switch (outputBits) {
+        case 16:
+            outFormat = AV_SAMPLE_FMT_S16;
+            break;
+        case 24:
+        case 32:
+            outFormat = AV_SAMPLE_FMT_S32;
+            break;
+        default:
+            outFormat = AV_SAMPLE_FMT_S32;
+            break;
+    }
+
     // Allocate resampler with new API
     AVChannelLayout inLayout, outLayout;
     av_channel_layout_default(&inLayout, m_codecContext->ch_layout.nb_channels);
@@ -1087,12 +1172,15 @@ bool AudioDecoder::initResampler(uint32_t outputRate, uint32_t outputBits) {
         m_pcmFifo = nullptr;
     }
 
-    // FIFO size: scale with sample rate using 64-bit math to avoid overflow
-    // Base: 8192 samples at 48kHz, scales proportionally
-    // 384kHz: ~65536 samples, 768kHz: ~131072 samples
-    int fifoSize = static_cast<int>((static_cast<int64_t>(8192) * outputRate) / 48000);
-    if (fifoSize < 4096) fifoSize = 4096;    // Minimum for stability
-    if (fifoSize > 262144) fifoSize = 262144; // Maximum reasonable size
+    // Scale FIFO size with sample rate: 8192 for 44.1kHz, up to 32768 for 384kHz
+    size_t fifoSize = 8192;
+    if (outputRate > 96000) {
+        fifoSize = 16384;
+    }
+    if (outputRate > 192000) {
+        fifoSize = 32768;
+    }
+    DEBUG_LOG("[AudioDecoder] FIFO allocated: " << fifoSize << " samples for " << outputRate << "Hz");
 
     m_pcmFifo = av_audio_fifo_alloc(outFormat, m_trackInfo.channels, fifoSize);
     if (!m_pcmFifo) {
@@ -1102,84 +1190,12 @@ bool AudioDecoder::initResampler(uint32_t outputRate, uint32_t outputBits) {
     }
 
     std::cout << "[AudioDecoder] Resampler: " << m_codecContext->sample_rate
-              << "Hz -> " << outputRate << "Hz, " << outputBits << "bit"
-              << " (FIFO: " << fifoSize << " samples)" << std::endl;
+              << "Hz -> " << outputRate << "Hz, " << outputBits << "bit" << std::endl;
 
     m_resamplerInitialized = true;
     return true;
 }
 
-/**
- * @brief Check if PCM bypass mode can be used
- *
- * Bypass skips the SwrContext entirely for bit-perfect playback when:
- * - Format is uncompressed (WAV, AIFF) - NOT FLAC, ALAC, etc.
- * - Sample rates match exactly
- * - Channel counts match
- * - Format is packed integer (S16 or S32) - NOT planar, NOT float
- * - Bit depth matches (or is S32 container with 24-bit content)
- *
- * Compressed formats (FLAC, ALAC) are NEVER bypassed - they decode to
- * planar format which requires conversion through SwrContext.
- */
-bool AudioDecoder::canBypass(uint32_t outputRate, uint32_t outputBits) const {
-    // DSD never uses bypass (handled separately)
-    if (m_trackInfo.isDSD) {
-        return false;
-    }
-
-    // Compressed formats (FLAC, ALAC, etc.) NEVER bypass
-    // They decode to planar format which requires conversion
-    if (m_trackInfo.isCompressed) {
-        DEBUG_LOG("[AudioDecoder] canBypass: NO (compressed format requires decoding)");
-        return false;
-    }
-
-    if (!m_codecContext) {
-        return false;
-    }
-
-    // Sample rate must match exactly
-    if (m_codecContext->sample_rate != (int)outputRate) {
-        DEBUG_LOG("[AudioDecoder] canBypass: NO (sample rate mismatch: "
-                  << m_codecContext->sample_rate << " vs " << outputRate << ")");
-        return false;
-    }
-
-    // Channel count must match
-    if (m_codecContext->ch_layout.nb_channels != (int)m_trackInfo.channels) {
-        DEBUG_LOG("[AudioDecoder] canBypass: NO (channel mismatch)");
-        return false;
-    }
-
-    // Format must be packed integer (NOT planar, NOT float)
-    AVSampleFormat fmt = m_codecContext->sample_fmt;
-    bool isPackedInteger = (fmt == AV_SAMPLE_FMT_S16 || fmt == AV_SAMPLE_FMT_S32);
-
-    if (!isPackedInteger) {
-        DEBUG_LOG("[AudioDecoder] canBypass: NO (format " << av_get_sample_fmt_name(fmt)
-                  << " requires conversion)");
-        return false;
-    }
-
-    // Bit depth must match (accounting for S32 container with 24-bit content)
-    bool bitDepthMatch = false;
-    if (outputBits == 16 && fmt == AV_SAMPLE_FMT_S16) {
-        bitDepthMatch = true;
-    } else if ((outputBits == 24 || outputBits == 32) && fmt == AV_SAMPLE_FMT_S32) {
-        bitDepthMatch = true;
-    }
-
-    if (!bitDepthMatch) {
-        DEBUG_LOG("[AudioDecoder] canBypass: NO (bit depth mismatch: "
-                  << m_trackInfo.bitDepth << " vs " << outputBits << ")");
-        return false;
-    }
-
-    DEBUG_LOG("[AudioDecoder] canBypass: YES (bit-perfect path enabled)");
-    return true;
-}
-
 // ============================================================================
 // AudioEngine
 // ============================================================================
@@ -1551,10 +1567,10 @@ bool AudioEngine::process(size_t samplesNeeded) {
             std::string nextURI = m_nextURI;
             std::string nextMetadata = m_nextMetadata;
 
-            // NOTE: Do NOT call m_trackEndCallback() here!
-            // trackEndCallback is for playlist END (releases Diretta target).
-            // For format changes, we want to keep the connection alive and
-            // let DirettaSync::open() handle the format transition.
+            // Signal track end to allow clean transition
+            if (m_trackEndCallback) {
+                m_trackEndCallback();
+            }
 
             // Apply next URI as current
             m_currentURI = nextURI;
@@ -1753,7 +1769,7 @@ bool AudioDecoder::seek(double seconds) {
             return false;
         }
 
-        // Clear stale DSD buffered data from before the seek
+        // Clear stale buffered data from before the seek
         m_dsdRemainderCount = 0;
         m_eof = false;
 
@@ -1789,7 +1805,7 @@ bool AudioDecoder::seek(double seconds) {
         avcodec_flush_buffers(m_codecContext);
     }
 
-    // Reset PCM FIFO (clear stale samples from before the seek)
+    // Reset PCM FIFO (clear stale samples)
     if (m_pcmFifo) {
         av_audio_fifo_reset(m_pcmFifo);
     }
diff --git a/src/AudioEngine.h b/src/AudioEngine.h
index 8e0c618..a680349 100644
--- a/src/AudioEngine.h
+++ b/src/AudioEngine.h
@@ -36,9 +36,9 @@ struct TrackInfo {
     DSDSourceFormat dsdSourceFormat;
 
     // 24-bit alignment hint from FFmpeg (for S24_P32 packing)
-    // This is a HINT only - sample-based detection in ring buffer takes priority
+    // This is a HINT only - sample-based detection takes priority
     enum class S24Alignment { Unknown, LsbAligned, MsbAligned };
-    S24Alignment s24Alignment;
+    S24Alignment s24Alignment = S24Alignment::Unknown;
 
     TrackInfo() : sampleRate(0), bitDepth(0), channels(2), duration(0),
                   isDSD(false), dsdRate(0), isCompressed(true),
@@ -133,27 +133,19 @@ private:
     // DSD Native Mode
     bool m_rawDSD;           // True if reading raw DSD packets (no decoding)
     AVPacket* m_packet;      // Reusable for raw packet reading (DSD and PCM)
-    AVFrame* m_frame;        // Reusable for decoded frames (PCM) - eliminates per-call alloc
+    AVFrame* m_frame;        // Reusable for decoded frames (PCM)
 
-    // DSD packet remainder buffer (for incomplete packet fragments)
-    // Stores leftover bytes when DSD packets don't align with request size
-    AudioBuffer m_dsdPacketRemainder;
-    size_t m_dsdRemainderCount = 0;
+    // DSD remainder buffer (byte-level L/R channel buffering)
+    AudioBuffer m_dsdRemainderBuffer;
+    size_t m_dsdRemainderCount;
 
     // PCM FIFO for sample overflow (O(1) circular buffer)
-    // Replaces memmove-based overflow handling with efficient FIFO
     AVAudioFifo* m_pcmFifo = nullptr;
 
     // Reusable resample buffer (eliminates per-call allocation)
     AudioBuffer m_resampleBuffer;
     size_t m_resampleBufferCapacity = 0;
 
-    // Pre-allocated DSD channel buffers (eliminates per-call std::vector allocation)
-    // Uses per-channel separation for optimal cache behavior
-    AudioBuffer m_dsdLeftBuffer;
-    AudioBuffer m_dsdRightBuffer;
-    size_t m_dsdBufferCapacity = 0;
-
     // Debug/diagnostic counters (instance variables, NOT static!)
     // These were previously static variables causing race conditions when
     // multiple AudioDecoder instances run concurrently (e.g., gapless preload)
@@ -162,7 +154,6 @@ private:
     bool m_resamplerInitLogged = false;   // Resampler init logged (open())
 
     // PCM bypass mode - skip resampler when formats match exactly
-    // Enables bit-perfect playback for matching integer formats
     bool m_bypassMode = false;
     bool m_resamplerInitialized = false;
 
diff --git a/src/DirettaRenderer.cpp b/src/DirettaRenderer.cpp
index 9f820b1..1e67127 100644
--- a/src/DirettaRenderer.cpp
+++ b/src/DirettaRenderer.cpp
@@ -7,6 +7,7 @@
 
 #include "DirettaRenderer.h"
 #include "DirettaSync.h"
+#include "DirettaRingBuffer.h"
 #include "UPnPDevice.hpp"
 #include "AudioEngine.h"
 #include <chrono>
@@ -16,19 +17,17 @@
 #include <functional>
 #include <unistd.h>
 #include <cstring>
+#include <algorithm>
 
 extern bool g_verbose;
 #define DEBUG_LOG(x) if (g_verbose) { std::cout << x << std::endl; }
 
-//=============================================================================
-// Hybrid Flow Control Constants
-//=============================================================================
-
+// Hybrid flow control constants
 namespace FlowControl {
-    constexpr int MICROSLEEP_US = 500;                                    // 500µs micro-sleep (was 10ms)
-    constexpr int MAX_WAIT_MS = 20;                                       // Max total wait time
-    constexpr int MAX_RETRIES = MAX_WAIT_MS * 1000 / MICROSLEEP_US;       // 40 retries
-    constexpr float CRITICAL_BUFFER_LEVEL = 0.10f;                        // Early-return below 10%
+    constexpr int MICROSLEEP_US = 500;
+    constexpr int MAX_WAIT_MS = 20;
+    constexpr int MAX_RETRIES = MAX_WAIT_MS * 1000 / MICROSLEEP_US;  // 40 retries
+    constexpr float CRITICAL_BUFFER_LEVEL = 0.10f;
 }
 
 //=============================================================================
@@ -91,14 +90,17 @@ DirettaRenderer::~DirettaRenderer() {
 }
 
 void DirettaRenderer::waitForCallbackComplete() {
-    m_shutdownRequested.store(true, std::memory_order_release);
+    // Use seq_cst to pair with callback's seq_cst operations
+    m_shutdownRequested.store(true, std::memory_order_seq_cst);
 
     auto start = std::chrono::steady_clock::now();
-    while (m_callbackRunning.load(std::memory_order_acquire)) {
+    while (m_callbackRunning.load(std::memory_order_seq_cst)) {
         std::this_thread::yield();
         auto elapsed = std::chrono::steady_clock::now() - start;
         if (elapsed > std::chrono::seconds(5)) {
             std::cerr << "[DirettaRenderer] CRITICAL: Callback timeout!" << std::endl;
+            // Reset flag to avoid permanent "callback running" state
+            m_callbackRunning.store(false, std::memory_order_release);
             break;
         }
     }
@@ -161,13 +163,16 @@ bool DirettaRenderer::start() {
             [this](const AudioBuffer& buffer, size_t samples,
                    uint32_t sampleRate, uint32_t bitDepth, uint32_t channels) -> bool {
 
-                // Check if shutdown requested (avoid work during teardown)
-                if (m_shutdownRequested.load(std::memory_order_acquire)) {
+                // CRITICAL: Set running flag FIRST, then check shutdown.
+                // This order prevents a race where stopper checks m_callbackRunning
+                // before we set it, but after checking m_shutdownRequested.
+                m_callbackRunning.store(true, std::memory_order_seq_cst);
+
+                if (m_shutdownRequested.load(std::memory_order_seq_cst)) {
+                    m_callbackRunning.store(false, std::memory_order_release);
                     return false;
                 }
 
-                // Lightweight atomic flag (no syscalls in hot path)
-                m_callbackRunning.store(true, std::memory_order_release);
                 struct Guard {
                     std::atomic<bool>& flag;
                     ~Guard() { flag.store(false, std::memory_order_release); }
@@ -225,10 +230,6 @@ bool DirettaRenderer::start() {
                                   << format.bitDepth << "bit "
                                   << (format.isDSD ? "DSD" : "PCM") << std::endl;
 
-                        // Send silence BEFORE stopping to flush Diretta pipeline
-                        // This prevents crackling on format transitions (gapless case)
-                        m_direttaSync->sendPreTransitionSilence();
-
                         // Stop current playback to trigger full reopen
                         m_direttaSync->stopPlayback(true);
                         needsOpen = true;
@@ -241,17 +242,13 @@ bool DirettaRenderer::start() {
                         return false;
                     }
 
-                    // Propagate S24 alignment hint to ring buffer for 24-bit PCM
-                    // This helps detection when track starts with silence
-                    if (!format.isDSD && bitDepth == 24 &&
-                        trackInfo.s24Alignment != TrackInfo::S24Alignment::Unknown) {
-                        DirettaRingBuffer::S24PackMode hint =
-                            (trackInfo.s24Alignment == TrackInfo::S24Alignment::LsbAligned)
-                                ? DirettaRingBuffer::S24PackMode::LsbAligned
-                                : DirettaRingBuffer::S24PackMode::MsbAligned;
-                        m_direttaSync->setS24PackModeHint(hint);
-                        DEBUG_LOG("[Callback] Set S24 hint: "
-                                  << (hint == DirettaRingBuffer::S24PackMode::LsbAligned ? "LSB" : "MSB"));
+                    // Propagate S24 alignment hint AFTER open() completes
+                    if (trackInfo.s24Alignment == TrackInfo::S24Alignment::LsbAligned) {
+                        m_direttaSync->setS24PackModeHint(DirettaRingBuffer::S24PackMode::LsbAligned);
+                        DEBUG_LOG("[Callback] S24 hint propagated: LsbAligned");
+                    } else if (trackInfo.s24Alignment == TrackInfo::S24Alignment::MsbAligned) {
+                        m_direttaSync->setS24PackModeHint(DirettaRingBuffer::S24PackMode::MsbAligned);
+                        DEBUG_LOG("[Callback] S24 hint propagated: MsbAligned");
                     }
                 }
 
@@ -281,7 +278,6 @@ bool DirettaRenderer::start() {
                     size_t bytesPerSample = (bitDepth == 24 || bitDepth == 32)
                         ? 4 * channels : (bitDepth / 8) * channels;
 
-                    // Hybrid flow control: micro-sleep normally, early-return if buffer critical
                     float bufferLevel = m_direttaSync->getBufferLevel();
                     bool criticalMode = (bufferLevel < FlowControl::CRITICAL_BUFFER_LEVEL);
 
@@ -297,11 +293,9 @@ bool DirettaRenderer::start() {
                             retryCount = 0;
                         } else {
                             if (criticalMode) {
-                                // Buffer critically low - return immediately to prioritize refill
                                 DEBUG_LOG("[Audio] Early-return, buffer critical: " << bufferLevel);
                                 break;
                             }
-                            // Normal backpressure: 500µs micro-sleep (was 10ms)
                             std::this_thread::sleep_for(std::chrono::microseconds(FlowControl::MICROSLEEP_US));
                             retryCount++;
                         }
@@ -336,13 +330,12 @@ bool DirettaRenderer::start() {
         );
 
         m_audioEngine->setTrackEndCallback([this]() {
-            std::cout << "[DirettaRenderer] Track ended naturally" << std::endl;
+            std::cout << "[DirettaRenderer] 🏁 Track ended naturally" << std::endl;
 
-            // Fully release the Diretta target on playlist end
-            // This closes the SDK connection so the target can accept other sources
-            // Using release() instead of close() ensures complete disconnection
+            // Stop Diretta playback to prevent underrun log spam
+            // This sets m_stopRequested which outputs silence instead of logging underruns
             if (m_direttaSync) {
-                m_direttaSync->release();
+                m_direttaSync->stopPlayback(true);
             }
 
             // Notify control point that track finished
@@ -350,6 +343,7 @@ bool DirettaRenderer::start() {
             // The control point will poll GetTransportInfo, see STOPPED,
             // and send SetAVTransportURI + Play for the next track
             m_upnp->notifyStateChange("STOPPED");
+            std::cout << "[DirettaRenderer] 🏁 Notified STOPPED to control point" << std::endl;
         });
 
         //=====================================================================
@@ -379,14 +373,6 @@ bool DirettaRenderer::start() {
                 // Don't close DirettaSync - keep connection alive for quick track transitions
                 // Format changes are handled in DirettaSync::open()
                 if (m_direttaSync && m_direttaSync->isOpen()) {
-                    // EXPERIMENTAL: Force full reopen for user-initiated track changes
-                    // This ensures clean transition even for same-format tracks
-                    // (vs gapless sequential playback which uses quick path)
-                    m_direttaSync->setForceFullReopen(true);
-
-                    // Send silence BEFORE stopping to flush Diretta pipeline
-                    // This prevents crackling on DSD→PCM or DSD rate change transitions
-                    m_direttaSync->sendPreTransitionSilence();
                     m_direttaSync->stopPlayback(true);
                     // m_direttaSync->close();  // Removed
                 }
@@ -464,14 +450,13 @@ bool DirettaRenderer::start() {
                 m_audioEngine->setCurrentURI(m_currentURI, m_currentMetadata, true);
             }
 
-            // Fully release Diretta target on Stop for proper resource cleanup
-            // This ensures:
-            // - Clean handoff when switching to a different renderer
-            // - Proper resource release on the Diretta target
-            // - Control point gets expected clean disconnection
-            // Trade-off: subsequent Play will need to reopen SDK (~300ms)
+            // Don't close DirettaSync here - keep connection alive for quick track transitions
+            // DirettaSync will only close on:
+            // - Format family change (PCM↔DSD) - handled in audio callback
+            // - App shutdown - handled in DirettaRenderer::stop()
             if (m_direttaSync) {
-                m_direttaSync->release();
+                m_direttaSync->stopPlayback(true);
+                // m_direttaSync->close();  // Removed - keep connection open
             }
 
             m_upnp->notifyStateChange("STOPPED");
@@ -557,6 +542,28 @@ void DirettaRenderer::upnpThreadFunc() {
     DEBUG_LOG("[UPnP Thread] Stopped");
 }
 
+size_t DirettaRenderer::calculateAdaptiveChunkSize(size_t baseSize, float bufferLevel) const {
+    constexpr float TARGET_LEVEL = 0.50f;
+    constexpr float DEADBAND = 0.10f;
+    constexpr float MIN_SCALE = 0.25f;
+    constexpr float MAX_SCALE = 1.50f;
+
+    float scale = 1.0f;
+    float deviation = bufferLevel - TARGET_LEVEL;
+
+    if (deviation > DEADBAND) {
+        // Buffer too full - reduce chunk size
+        scale = 1.0f - ((deviation - DEADBAND) / (1.0f - TARGET_LEVEL - DEADBAND));
+        scale = std::max(scale, MIN_SCALE);
+    } else if (deviation < -DEADBAND) {
+        // Buffer too empty - increase chunk size
+        scale = 1.0f + ((-deviation - DEADBAND) / (TARGET_LEVEL - DEADBAND)) * 0.5f;
+        scale = std::min(scale, MAX_SCALE);
+    }
+
+    return static_cast<size_t>(baseSize * scale);
+}
+
 void DirettaRenderer::audioThreadFunc() {
     DEBUG_LOG("[Audio Thread] Started");
 
@@ -586,22 +593,7 @@ void DirettaRenderer::audioThreadFunc() {
             }
 
             // Adjust samples per call based on format
-            // PCM: 2048 samples = ~46ms at 44.1kHz
-            // DSD: Rate-adaptive for consistent ~12ms chunks
-            size_t samplesPerCall;
-            if (isDSD) {
-                samplesPerCall = DirettaBuffer::calculateDsdSamplesPerCall(sampleRate);
-            } else {
-                samplesPerCall = 2048;
-            }
-
-            if (sampleRate != lastSampleRate || samplesPerCall != currentSamplesPerCall) {
-                currentSamplesPerCall = samplesPerCall;
-                lastSampleRate = sampleRate;
-                DEBUG_LOG("[Audio Thread] Format: " << sampleRate << "Hz "
-                          << (isDSD ? "DSD" : "PCM") << ", samples/call="
-                          << currentSamplesPerCall);
-            }
+            size_t baseSamplesPerCall = isDSD ? 32768 : 8192;
 
             // Buffer-level flow control (MPD-style)
             // Only throttle if DirettaSync is actively playing
@@ -612,6 +604,17 @@ void DirettaRenderer::audioThreadFunc() {
                 bufferLevel = m_direttaSync->getBufferLevel();
             }
 
+            // Apply adaptive sizing based on buffer level
+            size_t samplesPerCall = calculateAdaptiveChunkSize(baseSamplesPerCall, bufferLevel);
+
+            if (sampleRate != lastSampleRate || samplesPerCall != currentSamplesPerCall) {
+                currentSamplesPerCall = samplesPerCall;
+                lastSampleRate = sampleRate;
+                DEBUG_LOG("[Audio Thread] Format: " << sampleRate << "Hz "
+                          << (isDSD ? "DSD" : "PCM") << ", samples/call="
+                          << currentSamplesPerCall);
+            }
+
             if (bufferLevel > BUFFER_HIGH_THRESHOLD) {
                 // Buffer is healthy - throttle to avoid wasting CPU
                 std::this_thread::sleep_for(std::chrono::milliseconds(10));
diff --git a/src/DirettaRenderer.h b/src/DirettaRenderer.h
index 3e04b54..73ca56b 100644
--- a/src/DirettaRenderer.h
+++ b/src/DirettaRenderer.h
@@ -80,4 +80,10 @@ private:
 
     // DAC stabilization timing
     std::chrono::steady_clock::time_point m_lastStopTime;
+
+    // Adaptive chunk sizing based on buffer level
+    size_t calculateAdaptiveChunkSize(size_t baseSize, float bufferLevel) const;
+
+    // Track URI for gapless S24 hint updates
+    std::string m_lastProcessedURI;
 };
diff --git a/src/DirettaRingBuffer.h b/src/DirettaRingBuffer.h
index e0481dc..24f1fb0 100644
--- a/src/DirettaRingBuffer.h
+++ b/src/DirettaRingBuffer.h
@@ -18,15 +18,7 @@
 #include <cstdlib>
 #include <new>
 #include <type_traits>
-
-// Architecture detection for SIMD support
-#if defined(__x86_64__) || defined(_M_X64) || defined(__i386__) || defined(_M_IX86)
-    #define DIRETTA_HAS_AVX2 1
-    #include <immintrin.h>
-#else
-    #define DIRETTA_HAS_AVX2 0
-#endif
-
+#include <immintrin.h>
 #include "memcpyfast_audio.h"
 
 template <typename T, size_t Alignment>
@@ -100,35 +92,6 @@ bool operator!=(const AlignedAllocator<T, Alignment>&, const AlignedAllocator<T,
  */
 class DirettaRingBuffer {
 public:
-    // DSD conversion mode - determined at track open, eliminates per-iteration branch checks
-    // Declared early so it can be used in method signatures
-    enum class DSDConversionMode {
-        Passthrough,       // Just interleave (DSF→LSB target or DFF→MSB target) - fastest
-        BitReverseOnly,    // DSF→MSB or DFF→LSB target
-        ByteSwapOnly,      // Endianness conversion only
-        BitReverseAndSwap  // Both operations needed
-    };
-
-    // Single bit-reversal LUT for all DSD conversion functions (cache-friendly)
-    static constexpr uint8_t kBitReverseLUT[256] = {
-        0x00,0x80,0x40,0xC0,0x20,0xA0,0x60,0xE0,0x10,0x90,0x50,0xD0,0x30,0xB0,0x70,0xF0,
-        0x08,0x88,0x48,0xC8,0x28,0xA8,0x68,0xE8,0x18,0x98,0x58,0xD8,0x38,0xB8,0x78,0xF8,
-        0x04,0x84,0x44,0xC4,0x24,0xA4,0x64,0xE4,0x14,0x94,0x54,0xD4,0x34,0xB4,0x74,0xF4,
-        0x0C,0x8C,0x4C,0xCC,0x2C,0xAC,0x6C,0xEC,0x1C,0x9C,0x5C,0xDC,0x3C,0xBC,0x7C,0xFC,
-        0x02,0x82,0x42,0xC2,0x22,0xA2,0x62,0xE2,0x12,0x92,0x52,0xD2,0x32,0xB2,0x72,0xF2,
-        0x0A,0x8A,0x4A,0xCA,0x2A,0xAA,0x6A,0xEA,0x1A,0x9A,0x5A,0xDA,0x3A,0xBA,0x7A,0xFA,
-        0x06,0x86,0x46,0xC6,0x26,0xA6,0x66,0xE6,0x16,0x96,0x56,0xD6,0x36,0xB6,0x76,0xF6,
-        0x0E,0x8E,0x4E,0xCE,0x2E,0xAE,0x6E,0xEE,0x1E,0x9E,0x5E,0xDE,0x3E,0xBE,0x7E,0xFE,
-        0x01,0x81,0x41,0xC1,0x21,0xA1,0x61,0xE1,0x11,0x91,0x51,0xD1,0x31,0xB1,0x71,0xF1,
-        0x09,0x89,0x49,0xC9,0x29,0xA9,0x69,0xE9,0x19,0x99,0x59,0xD9,0x39,0xB9,0x79,0xF9,
-        0x05,0x85,0x45,0xC5,0x25,0xA5,0x65,0xE5,0x15,0x95,0x55,0xD5,0x35,0xB5,0x75,0xF5,
-        0x0D,0x8D,0x4D,0xCD,0x2D,0xAD,0x6D,0xED,0x1D,0x9D,0x5D,0xDD,0x3D,0xBD,0x7D,0xFD,
-        0x03,0x83,0x43,0xC3,0x23,0xA3,0x63,0xE3,0x13,0x93,0x53,0xD3,0x33,0xB3,0x73,0xF3,
-        0x0B,0x8B,0x4B,0xCB,0x2B,0xAB,0x6B,0xEB,0x1B,0x9B,0x5B,0xDB,0x3B,0xBB,0x7B,0xFB,
-        0x07,0x87,0x47,0xC7,0x27,0xA7,0x67,0xE7,0x17,0x97,0x57,0xD7,0x37,0xB7,0x77,0xF7,
-        0x0F,0x8F,0x4F,0xCF,0x2F,0xAF,0x6F,0xEF,0x1F,0x9F,0x5F,0xDF,0x3F,0xBF,0x7F,0xFF
-    };
-
     DirettaRingBuffer() = default;
 
     /**
@@ -139,8 +102,9 @@ public:
         mask_ = size_ - 1;
         buffer_.resize(size_);
         silenceByte_.store(silenceByte, std::memory_order_release);
-        clear();  // Resets all S24 state - hint will be set by caller via setS24PackModeHint()
+        clear();
         fillWithSilence();
+        // clear() already resets S24 state - hint will be set by caller via setS24PackModeHint()
     }
 
     size_t size() const { return size_; }
@@ -184,121 +148,52 @@ public:
     const uint8_t* getStagingDSD() const { return m_stagingDSD; }
 
     //=========================================================================
-    // Direct Write API - eliminates memcpy for contiguous regions
+    // Direct Write API (zero-copy fast path)
     //=========================================================================
 
     /**
      * @brief Get direct write pointer for zero-copy writes
-     *
-     * Returns a pointer to contiguous writable space in the ring buffer.
-     * Use this to write directly without staging buffer overhead.
-     * Call commitDirectWrite() after writing to advance the write pointer.
-     *
      * @param needed Minimum bytes needed
-     * @param region Output: pointer to writable region (valid until commitDirectWrite)
-     * @param available Output: contiguous bytes available (may be > needed)
-     * @return true if contiguous space >= needed available, false if wraparound required
-     *
-     * Usage:
-     *   uint8_t* ptr;
-     *   size_t avail;
-     *   if (ring.getDirectWriteRegion(size, ptr, avail)) {
-     *       memcpy(ptr, data, size);  // or decode directly here
-     *       ring.commitDirectWrite(size);
-     *   } else {
-     *       ring.push(data, size);  // fallback for wraparound case
-     *   }
+     * @param region Output: pointer to contiguous write region
+     * @param available Output: bytes available in region
+     * @return true if contiguous space >= needed is available
      */
     bool getDirectWriteRegion(size_t needed, uint8_t*& region, size_t& available) {
-        if (size_ == 0 || needed == 0) {
-            region = nullptr;
-            available = 0;
-            return false;
-        }
+        if (size_ == 0) return false;
 
         size_t wp = writePos_.load(std::memory_order_acquire);
         size_t rp = readPos_.load(std::memory_order_acquire);
 
-        // Calculate free space
-        size_t free = (rp > wp) ? (rp - wp - 1) : (size_ - wp + rp - 1);
-        if (free < needed) {
-            region = nullptr;
-            available = 0;
-            return false;
-        }
-
-        // Calculate contiguous space from write position to end of buffer
-        size_t contiguous = size_ - wp;
-
-        // Also consider the read position for wrap case
-        if (rp <= wp) {
-            // Write position is ahead of or equal to read position
-            // Contiguous space is to end of buffer (we can't wrap past read)
-            contiguous = size_ - wp;
-        } else {
-            // Read position is ahead - contiguous space is to read position
-            contiguous = rp - wp - 1;
-        }
+        // Contiguous space from writePos to either readPos or end of buffer
+        size_t toEnd = size_ - wp;
+        size_t totalFree = (rp - wp - 1) & mask_;
+        size_t contiguous = std::min(toEnd, totalFree);
 
         if (contiguous >= needed) {
             region = buffer_.data() + wp;
             available = contiguous;
             return true;
         }
-
-        // Not enough contiguous space - caller should use fallback
-        region = nullptr;
-        available = 0;
         return false;
     }
 
     /**
-     * @brief Commit a direct write, advancing the write pointer
-     * @param written Number of bytes actually written (must be <= available from getDirectWriteRegion)
+     * @brief Commit a direct write, advancing write pointer
+     * @param written Number of bytes written to the region
      */
     void commitDirectWrite(size_t written) {
-        if (written == 0 || size_ == 0) return;
         size_t wp = writePos_.load(std::memory_order_relaxed);
         writePos_.store((wp + written) & mask_, std::memory_order_release);
     }
 
-    /**
-     * @brief Get staging buffer for format conversion with direct commit
-     *
-     * For format conversions that need a staging area, this provides the staging
-     * buffer and allows direct commit to ring buffer afterward.
-     *
-     * @param stagingType Which staging buffer to use (0=24bit, 1=16to32, 2=DSD)
-     * @return Pointer to staging buffer (STAGING_SIZE bytes available)
-     */
-    uint8_t* getStagingForConversion(int stagingType) {
-        switch (stagingType) {
-            case 0: return m_staging24BitPack;
-            case 1: return m_staging16To32;
-            case 2: return m_stagingDSD;
-            default: return m_staging24BitPack;
-        }
-    }
-
-    // Expose staging buffer size for callers
-    static constexpr size_t getStagingBufferSize() { return STAGING_SIZE; }
-
     //=========================================================================
     // Push methods (write to buffer)
     //=========================================================================
 
     /**
      * @brief Push PCM data directly (no conversion)
-     *
-     * Optimized path: uses direct write when contiguous space available,
-     * avoiding the check-then-copy overhead of the wraparound case.
      */
     size_t push(const uint8_t* data, size_t len) {
-        if (size_ == 0) return 0;
-        size_t free = getFreeSpace();
-        if (len > free) len = free;
-        if (len == 0) return 0;
-
         // Fast path: try direct write (no wraparound)
         uint8_t* region;
         size_t available;
@@ -308,10 +203,17 @@ public:
             return len;
         }
 
-        // Slow path: handle wraparound
+        // Slow path: handle wraparound with inlined position loads
+        if (size_ == 0) return 0;
+
         size_t wp = writePos_.load(std::memory_order_acquire);
-        size_t firstChunk = std::min(len, size_ - wp);
+        size_t rp = readPos_.load(std::memory_order_acquire);
+        size_t free = (rp - wp - 1) & mask_;
+
+        if (len > free) len = free;
+        if (len == 0) return 0;
 
+        size_t firstChunk = std::min(len, size_ - wp);
         memcpy_audio(buffer_.data() + wp, data, firstChunk);
         if (firstChunk < len) {
             memcpy_audio(buffer_.data(), data + firstChunk, len - firstChunk);
@@ -324,11 +226,6 @@ public:
     /**
      * @brief Push with 24-bit packing (4 bytes in -> 3 bytes out, S24_P32 format)
      * @return Input bytes consumed
-     *
-     * Uses hybrid S24 detection:
-     * 1. Sample-based detection takes priority (checks actual byte values)
-     * 2. Hint from FFmpeg metadata used as fallback for silence
-     * 3. Timeout defaults to LSB after ~1 second of silence
      */
     size_t push24BitPacked(const uint8_t* data, size_t inputSize) {
         if (size_ == 0) return 0;
@@ -351,14 +248,16 @@ public:
             (m_s24PackMode == m_s24Hint && !m_s24DetectionConfirmed)) {
             S24PackMode detected = detectS24PackMode(data, numSamples);
             if (detected != S24PackMode::Deferred) {
-                // Sample detection found definitive result - use it
+                // Sample detection found definitive result - override any hint
+                if (detected != m_s24Hint && m_s24Hint != S24PackMode::Unknown) {
+                    // Log when detection disagrees with hint (important for debugging)
+                }
                 m_s24PackMode = detected;
                 m_s24DetectionConfirmed = true;
                 m_deferredSampleCount = 0;
             } else {
-                // Still silence - accumulate count for timeout
                 m_deferredSampleCount += numSamples;
-                // Timeout: if still silent after threshold, use hint or default to LSB
+                // Timeout: if still silent after ~1 second, use hint or default to LSB
                 if (m_deferredSampleCount > DEFERRED_TIMEOUT_SAMPLES) {
                     m_s24PackMode = (m_s24Hint != S24PackMode::Unknown) ? m_s24Hint : S24PackMode::LsbAligned;
                     m_s24DetectionConfirmed = true;
@@ -366,7 +265,7 @@ public:
             }
         }
 
-        // Use effective mode for conversion (Deferred/Unknown use hint or LSB as fallback)
+        // Use effective mode for conversion (Deferred uses hint or LSB as default)
         S24PackMode effectiveMode = m_s24PackMode;
         if (effectiveMode == S24PackMode::Deferred || effectiveMode == S24PackMode::Unknown) {
             effectiveMode = (m_s24Hint != S24PackMode::Unknown) ? m_s24Hint : S24PackMode::LsbAligned;
@@ -408,19 +307,20 @@ public:
     }
 
     /**
-     * @brief Optimized DSD planar push using pre-selected conversion mode
+     * @brief Push DSD data from PLANAR input (FFmpeg format)
      *
-     * Uses specialized conversion functions with no per-iteration branch checks.
-     * Mode should be determined at track open and cached in DirettaSync.
+     * Input format: [L0 L1 L2 L3...][R0 R1 R2 R3...] (planar, per-channel blocks)
+     * Output format: 4-byte groups per channel, interleaved
      *
      * @param data Planar DSD data
      * @param inputSize Total input size in bytes
      * @param numChannels Number of audio channels
-     * @param mode Pre-selected conversion mode (eliminates runtime checks)
+     * @param bitReverseTable Lookup table for MSB<->LSB conversion (nullptr if not needed)
+     * @param byteSwap If true, swap byte order within 4-byte groups (for LITTLE endian targets)
      * @return Input bytes consumed
      */
-    size_t pushDSDPlanarOptimized(const uint8_t* data, size_t inputSize,
-                                   int numChannels, DSDConversionMode mode) {
+    size_t pushDSDPlanar(const uint8_t* data, size_t inputSize, int numChannels,
+                         const uint8_t* bitReverseTable, bool byteSwap = false) {
         if (size_ == 0) return 0;
         if (numChannels == 0) return 0;
 
@@ -436,34 +336,13 @@ public:
 
         prefetch_audio_buffer(data, usableInput);
 
-        size_t stagedBytes;
-        switch (mode) {
-            case DSDConversionMode::Passthrough:
-                stagedBytes = convertDSD_Passthrough(m_stagingDSD, data, usableInput, numChannels);
-                break;
-            case DSDConversionMode::BitReverseOnly:
-                stagedBytes = convertDSD_BitReverse(m_stagingDSD, data, usableInput, numChannels);
-                break;
-            case DSDConversionMode::ByteSwapOnly:
-                stagedBytes = convertDSD_ByteSwap(m_stagingDSD, data, usableInput, numChannels);
-                break;
-            case DSDConversionMode::BitReverseAndSwap:
-                stagedBytes = convertDSD_BitReverseSwap(m_stagingDSD, data, usableInput, numChannels);
-                break;
-            default:
-                // Fallback to passthrough if unknown mode
-                stagedBytes = convertDSD_Passthrough(m_stagingDSD, data, usableInput, numChannels);
-                break;
-        }
+        size_t stagedBytes = convertDSDPlanar_AVX2(
+            m_stagingDSD, data, usableInput, numChannels, bitReverseTable, byteSwap);
+        size_t written = writeToRing(m_stagingDSD, stagedBytes);
 
-        return writeToRing(m_stagingDSD, stagedBytes);
+        return written;
     }
 
-    //=========================================================================
-    // Format conversion functions - with AVX2 optimization on x86
-    //=========================================================================
-
-#if DIRETTA_HAS_AVX2
     /**
      * Convert S24_P32 to packed 24-bit using AVX2
      * Input: 4 bytes per sample (24-bit in 32-bit container)
@@ -596,195 +475,23 @@ public:
         return outputBytes;
     }
 
-#else // !DIRETTA_HAS_AVX2 - Scalar implementations for ARM64 and other architectures
-
-    /**
-     * Convert S24_P32 to packed 24-bit (scalar version)
-     */
-    size_t convert24BitPacked_AVX2(uint8_t* dst, const uint8_t* src, size_t numSamples) {
-        size_t outputBytes = 0;
-        for (size_t i = 0; i < numSamples; i++) {
-            dst[outputBytes + 0] = src[i * 4 + 0];
-            dst[outputBytes + 1] = src[i * 4 + 1];
-            dst[outputBytes + 2] = src[i * 4 + 2];
-            outputBytes += 3;
-        }
-        return outputBytes;
-    }
-
-    size_t convert24BitPackedShifted_AVX2(uint8_t* dst, const uint8_t* src, size_t numSamples) {
-        size_t outputBytes = 0;
-        for (size_t i = 0; i < numSamples; i++) {
-            dst[outputBytes + 0] = src[i * 4 + 1];
-            dst[outputBytes + 1] = src[i * 4 + 2];
-            dst[outputBytes + 2] = src[i * 4 + 3];
-            outputBytes += 3;
-        }
-        return outputBytes;
-    }
-
     /**
-     * Convert 16-bit to 32-bit (scalar version)
+     * Convert DSD planar to interleaved using AVX2 (stereo only)
+     * Input: [L channel bytes][R channel bytes] planar
+     * Output: [4B L][4B R][4B L][4B R]... interleaved
+     * Falls back to scalar for non-stereo
      */
-    size_t convert16To32_AVX2(uint8_t* dst, const uint8_t* src, size_t numSamples) {
-        size_t outputBytes = 0;
-        for (size_t i = 0; i < numSamples; i++) {
-            dst[outputBytes + 0] = 0x00;
-            dst[outputBytes + 1] = 0x00;
-            dst[outputBytes + 2] = src[i * 2 + 0];
-            dst[outputBytes + 3] = src[i * 2 + 1];
-            outputBytes += 4;
-        }
-        return outputBytes;
-    }
-
-#endif // DIRETTA_HAS_AVX2
-
-    //=========================================================================
-    // Specialized DSD conversion functions - no per-iteration branch checks
-    // Mode is determined at track open, eliminating runtime conditionals
-    //=========================================================================
-
-    /**
-     * DSD Passthrough: Just interleave channels (fastest path)
-     * Used when source bit ordering matches target (DSF→LSB or DFF→MSB)
-     * NO bit reversal, NO byte swap
-     */
-    size_t convertDSD_Passthrough(uint8_t* dst, const uint8_t* src,
-                                   size_t totalInputBytes, int numChannels) {
+    size_t convertDSDPlanar_AVX2(
+        uint8_t* dst,
+        const uint8_t* src,
+        size_t totalInputBytes,
+        int numChannels,
+        const uint8_t* bitReversalTable,
+        bool needByteSwap
+    ) {
         size_t bytesPerChannel = totalInputBytes / static_cast<size_t>(numChannels);
         size_t outputBytes = 0;
 
-#if DIRETTA_HAS_AVX2
-        if (numChannels == 2) {
-            const uint8_t* srcL = src;
-            const uint8_t* srcR = src + bytesPerChannel;
-
-            size_t i = 0;
-            for (; i + 32 <= bytesPerChannel; i += 32) {
-                __m256i left = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(srcL + i));
-                __m256i right = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(srcR + i));
-
-                // NO bit reversal - passthrough
-                // NO byte swap - passthrough
-
-                __m256i interleaved_lo = _mm256_unpacklo_epi32(left, right);
-                __m256i interleaved_hi = _mm256_unpackhi_epi32(left, right);
-
-                __m256i out0 = _mm256_permute2x128_si256(interleaved_lo, interleaved_hi, 0x20);
-                __m256i out1 = _mm256_permute2x128_si256(interleaved_lo, interleaved_hi, 0x31);
-
-                _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + outputBytes), out0);
-                outputBytes += 32;
-                _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + outputBytes), out1);
-                outputBytes += 32;
-            }
-
-            // Scalar tail - no branches
-            for (; i + 4 <= bytesPerChannel; i += 4) {
-                dst[outputBytes++] = srcL[i + 0];
-                dst[outputBytes++] = srcL[i + 1];
-                dst[outputBytes++] = srcL[i + 2];
-                dst[outputBytes++] = srcL[i + 3];
-                dst[outputBytes++] = srcR[i + 0];
-                dst[outputBytes++] = srcR[i + 1];
-                dst[outputBytes++] = srcR[i + 2];
-                dst[outputBytes++] = srcR[i + 3];
-            }
-
-            _mm256_zeroupper();
-            return outputBytes;
-        }
-#endif
-        // Scalar fallback for non-AVX2 or non-stereo
-        for (size_t i = 0; i < bytesPerChannel; i += 4) {
-            for (int ch = 0; ch < numChannels; ch++) {
-                size_t chOffset = static_cast<size_t>(ch) * bytesPerChannel;
-                dst[outputBytes++] = src[chOffset + i + 0];
-                dst[outputBytes++] = src[chOffset + i + 1];
-                dst[outputBytes++] = src[chOffset + i + 2];
-                dst[outputBytes++] = src[chOffset + i + 3];
-            }
-        }
-        return outputBytes;
-    }
-
-    /**
-     * DSD BitReverse: Apply bit reversal only (no byte swap)
-     * Used for DSF→MSB or DFF→LSB target conversions
-     */
-    size_t convertDSD_BitReverse(uint8_t* dst, const uint8_t* src,
-                                  size_t totalInputBytes, int numChannels) {
-        size_t bytesPerChannel = totalInputBytes / static_cast<size_t>(numChannels);
-        size_t outputBytes = 0;
-
-#if DIRETTA_HAS_AVX2
-        if (numChannels == 2) {
-            const uint8_t* srcL = src;
-            const uint8_t* srcR = src + bytesPerChannel;
-
-            size_t i = 0;
-            for (; i + 32 <= bytesPerChannel; i += 32) {
-                __m256i left = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(srcL + i));
-                __m256i right = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(srcR + i));
-
-                // ALWAYS apply bit reversal
-                left = simd_bit_reverse(left);
-                right = simd_bit_reverse(right);
-
-                // NO byte swap
-
-                __m256i interleaved_lo = _mm256_unpacklo_epi32(left, right);
-                __m256i interleaved_hi = _mm256_unpackhi_epi32(left, right);
-
-                __m256i out0 = _mm256_permute2x128_si256(interleaved_lo, interleaved_hi, 0x20);
-                __m256i out1 = _mm256_permute2x128_si256(interleaved_lo, interleaved_hi, 0x31);
-
-                _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + outputBytes), out0);
-                outputBytes += 32;
-                _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + outputBytes), out1);
-                outputBytes += 32;
-            }
-
-            // Scalar tail with bit reversal lookup (using class-scope LUT)
-            for (; i + 4 <= bytesPerChannel; i += 4) {
-                dst[outputBytes++] = kBitReverseLUT[srcL[i + 0]];
-                dst[outputBytes++] = kBitReverseLUT[srcL[i + 1]];
-                dst[outputBytes++] = kBitReverseLUT[srcL[i + 2]];
-                dst[outputBytes++] = kBitReverseLUT[srcL[i + 3]];
-                dst[outputBytes++] = kBitReverseLUT[srcR[i + 0]];
-                dst[outputBytes++] = kBitReverseLUT[srcR[i + 1]];
-                dst[outputBytes++] = kBitReverseLUT[srcR[i + 2]];
-                dst[outputBytes++] = kBitReverseLUT[srcR[i + 3]];
-            }
-
-            _mm256_zeroupper();
-            return outputBytes;
-        }
-#endif
-        // Scalar fallback with bit reversal (using class-scope LUT)
-        for (size_t i = 0; i < bytesPerChannel; i += 4) {
-            for (int ch = 0; ch < numChannels; ch++) {
-                size_t chOffset = static_cast<size_t>(ch) * bytesPerChannel;
-                dst[outputBytes++] = kBitReverseLUT[src[chOffset + i + 0]];
-                dst[outputBytes++] = kBitReverseLUT[src[chOffset + i + 1]];
-                dst[outputBytes++] = kBitReverseLUT[src[chOffset + i + 2]];
-                dst[outputBytes++] = kBitReverseLUT[src[chOffset + i + 3]];
-            }
-        }
-        return outputBytes;
-    }
-
-    /**
-     * DSD ByteSwap: Apply byte swap only (no bit reversal)
-     * Used for endianness conversion
-     */
-    size_t convertDSD_ByteSwap(uint8_t* dst, const uint8_t* src,
-                                size_t totalInputBytes, int numChannels) {
-        size_t bytesPerChannel = totalInputBytes / static_cast<size_t>(numChannels);
-        size_t outputBytes = 0;
-
-#if DIRETTA_HAS_AVX2
         if (numChannels == 2) {
             const uint8_t* srcL = src;
             const uint8_t* srcR = src + bytesPerChannel;
@@ -799,14 +506,18 @@ public:
                 __m256i left = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(srcL + i));
                 __m256i right = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(srcR + i));
 
-                // NO bit reversal
+                if (bitReversalTable) {
+                    left = simd_bit_reverse(left);
+                    right = simd_bit_reverse(right);
+                }
 
                 __m256i interleaved_lo = _mm256_unpacklo_epi32(left, right);
                 __m256i interleaved_hi = _mm256_unpackhi_epi32(left, right);
 
-                // ALWAYS apply byte swap
-                interleaved_lo = _mm256_shuffle_epi8(interleaved_lo, byteswap_mask);
-                interleaved_hi = _mm256_shuffle_epi8(interleaved_hi, byteswap_mask);
+                if (needByteSwap) {
+                    interleaved_lo = _mm256_shuffle_epi8(interleaved_lo, byteswap_mask);
+                    interleaved_hi = _mm256_shuffle_epi8(interleaved_hi, byteswap_mask);
+                }
 
                 __m256i out0 = _mm256_permute2x128_si256(interleaved_lo, interleaved_hi, 0x20);
                 __m256i out1 = _mm256_permute2x128_si256(interleaved_lo, interleaved_hi, 0x31);
@@ -817,105 +528,25 @@ public:
                 outputBytes += 32;
             }
 
-            // Scalar tail with byte swap
             for (; i + 4 <= bytesPerChannel; i += 4) {
-                dst[outputBytes++] = srcL[i + 3];
-                dst[outputBytes++] = srcL[i + 2];
-                dst[outputBytes++] = srcL[i + 1];
-                dst[outputBytes++] = srcL[i + 0];
-                dst[outputBytes++] = srcR[i + 3];
-                dst[outputBytes++] = srcR[i + 2];
-                dst[outputBytes++] = srcR[i + 1];
-                dst[outputBytes++] = srcR[i + 0];
+                for (int j = 0; j < 4; j++) {
+                    uint8_t b = srcL[i + j];
+                    if (bitReversalTable) b = bitReversalTable[b];
+                    dst[outputBytes++] = b;
+                }
+                for (int j = 0; j < 4; j++) {
+                    uint8_t b = srcR[i + j];
+                    if (bitReversalTable) b = bitReversalTable[b];
+                    dst[outputBytes++] = b;
+                }
             }
 
             _mm256_zeroupper();
-            return outputBytes;
-        }
-#endif
-        // Scalar fallback with byte swap
-        for (size_t i = 0; i < bytesPerChannel; i += 4) {
-            for (int ch = 0; ch < numChannels; ch++) {
-                size_t chOffset = static_cast<size_t>(ch) * bytesPerChannel;
-                dst[outputBytes++] = src[chOffset + i + 3];
-                dst[outputBytes++] = src[chOffset + i + 2];
-                dst[outputBytes++] = src[chOffset + i + 1];
-                dst[outputBytes++] = src[chOffset + i + 0];
-            }
+        } else {
+            outputBytes = convertDSDPlanar_Scalar(dst, src, totalInputBytes, numChannels,
+                                                  bitReversalTable, needByteSwap);
         }
-        return outputBytes;
-    }
 
-    /**
-     * DSD BitReverse + ByteSwap: Apply both operations
-     * Used when both bit reversal and endianness conversion are needed
-     */
-    size_t convertDSD_BitReverseSwap(uint8_t* dst, const uint8_t* src,
-                                      size_t totalInputBytes, int numChannels) {
-        size_t bytesPerChannel = totalInputBytes / static_cast<size_t>(numChannels);
-        size_t outputBytes = 0;
-
-#if DIRETTA_HAS_AVX2
-        if (numChannels == 2) {
-            const uint8_t* srcL = src;
-            const uint8_t* srcR = src + bytesPerChannel;
-
-            static const __m256i byteswap_mask = _mm256_setr_epi8(
-                3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 14, 13, 12,
-                3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 14, 13, 12
-            );
-
-            size_t i = 0;
-            for (; i + 32 <= bytesPerChannel; i += 32) {
-                __m256i left = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(srcL + i));
-                __m256i right = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(srcR + i));
-
-                // ALWAYS apply bit reversal
-                left = simd_bit_reverse(left);
-                right = simd_bit_reverse(right);
-
-                __m256i interleaved_lo = _mm256_unpacklo_epi32(left, right);
-                __m256i interleaved_hi = _mm256_unpackhi_epi32(left, right);
-
-                // ALWAYS apply byte swap
-                interleaved_lo = _mm256_shuffle_epi8(interleaved_lo, byteswap_mask);
-                interleaved_hi = _mm256_shuffle_epi8(interleaved_hi, byteswap_mask);
-
-                __m256i out0 = _mm256_permute2x128_si256(interleaved_lo, interleaved_hi, 0x20);
-                __m256i out1 = _mm256_permute2x128_si256(interleaved_lo, interleaved_hi, 0x31);
-
-                _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + outputBytes), out0);
-                outputBytes += 32;
-                _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + outputBytes), out1);
-                outputBytes += 32;
-            }
-
-            // Scalar tail with bit reversal + byte swap (using class-scope LUT)
-            for (; i + 4 <= bytesPerChannel; i += 4) {
-                dst[outputBytes++] = kBitReverseLUT[srcL[i + 3]];
-                dst[outputBytes++] = kBitReverseLUT[srcL[i + 2]];
-                dst[outputBytes++] = kBitReverseLUT[srcL[i + 1]];
-                dst[outputBytes++] = kBitReverseLUT[srcL[i + 0]];
-                dst[outputBytes++] = kBitReverseLUT[srcR[i + 3]];
-                dst[outputBytes++] = kBitReverseLUT[srcR[i + 2]];
-                dst[outputBytes++] = kBitReverseLUT[srcR[i + 1]];
-                dst[outputBytes++] = kBitReverseLUT[srcR[i + 0]];
-            }
-
-            _mm256_zeroupper();
-            return outputBytes;
-        }
-#endif
-        // Scalar fallback with bit reversal + byte swap (using class-scope LUT)
-        for (size_t i = 0; i < bytesPerChannel; i += 4) {
-            for (int ch = 0; ch < numChannels; ch++) {
-                size_t chOffset = static_cast<size_t>(ch) * bytesPerChannel;
-                dst[outputBytes++] = kBitReverseLUT[src[chOffset + i + 3]];
-                dst[outputBytes++] = kBitReverseLUT[src[chOffset + i + 2]];
-                dst[outputBytes++] = kBitReverseLUT[src[chOffset + i + 1]];
-                dst[outputBytes++] = kBitReverseLUT[src[chOffset + i + 0]];
-            }
-        }
         return outputBytes;
     }
 
@@ -928,11 +559,16 @@ public:
      */
     size_t pop(uint8_t* dest, size_t len) {
         if (size_ == 0) return 0;
-        size_t avail = getAvailable();
+
+        // Inline position loads to avoid redundant atomic reads
+        size_t wp = writePos_.load(std::memory_order_acquire);
+        size_t rp = readPos_.load(std::memory_order_acquire);
+        size_t avail = (wp - rp) & mask_;
+
         if (len > avail) len = avail;
         if (len == 0) return 0;
 
-        size_t rp = readPos_.load(std::memory_order_acquire);
+        // rp already loaded, reuse directly
         size_t firstChunk = std::min(len, size_ - rp);
 
         memcpy_audio(dest, buffer_.data() + rp, firstChunk);
@@ -986,7 +622,43 @@ private:
         return len;
     }
 
-#if DIRETTA_HAS_AVX2
+    size_t convertDSDPlanar_Scalar(
+        uint8_t* dst,
+        const uint8_t* src,
+        size_t totalInputBytes,
+        int numChannels,
+        const uint8_t* bitReversalTable,
+        bool needByteSwap
+    ) {
+        size_t bytesPerChannel = totalInputBytes / static_cast<size_t>(numChannels);
+        size_t outputBytes = 0;
+
+        for (size_t i = 0; i < bytesPerChannel; i += 4) {
+            for (int ch = 0; ch < numChannels; ch++) {
+                uint8_t group[4] = {0, 0, 0, 0};
+                for (int j = 0; j < 4 && (i + static_cast<size_t>(j)) < bytesPerChannel; j++) {
+                    uint8_t b = src[static_cast<size_t>(ch) * bytesPerChannel + i + static_cast<size_t>(j)];
+                    if (bitReversalTable) b = bitReversalTable[b];
+                    group[j] = b;
+                }
+
+                if (needByteSwap) {
+                    dst[outputBytes++] = group[3];
+                    dst[outputBytes++] = group[2];
+                    dst[outputBytes++] = group[1];
+                    dst[outputBytes++] = group[0];
+                } else {
+                    dst[outputBytes++] = group[0];
+                    dst[outputBytes++] = group[1];
+                    dst[outputBytes++] = group[2];
+                    dst[outputBytes++] = group[3];
+                }
+            }
+        }
+
+        return outputBytes;
+    }
+
     static __m256i simd_bit_reverse(__m256i x) {
         static const __m256i nibble_reverse = _mm256_setr_epi8(
             0x0, 0x8, 0x4, 0xC, 0x2, 0xA, 0x6, 0xE,
@@ -1004,7 +676,6 @@ private:
 
         return _mm256_or_si256(_mm256_slli_epi16(lo_reversed, 4), hi_reversed);
     }
-#endif // DIRETTA_HAS_AVX2
 
     static size_t roundUpPow2(size_t value) {
         if (value < 2) {
@@ -1032,16 +703,8 @@ private:
     std::atomic<uint8_t> silenceByte_{0};
 
 public:
-    // S24 pack mode detection - determines byte alignment of 24-bit samples in 32-bit containers
     enum class S24PackMode { Unknown, LsbAligned, MsbAligned, Deferred };
 
-    /**
-     * @brief Set S24 pack mode hint from FFmpeg metadata
-     *
-     * Call this when track info indicates 24-bit content. The hint is used as fallback
-     * when sample-based detection sees all-zero data (silence at track start).
-     * Sample-based detection takes priority when non-zero samples are present.
-     */
     void setS24PackModeHint(S24PackMode hint) {
         // Store hint separately - sample detection can override
         m_s24Hint = hint;
@@ -1057,16 +720,8 @@ public:
     S24PackMode getS24Hint() const { return m_s24Hint; }
 
 private:
-    /**
-     * Detect S24 pack mode by examining sample data
-     *
-     * Checks both LSB (byte 0) and MSB (byte 3) positions:
-     * - LSB-aligned: data in bytes 0-2, byte 3 is zero (standard S24_LE)
-     * - MSB-aligned: data in bytes 1-3, byte 0 is zero (left-justified)
-     * - Deferred: all samples are zero (silence) - cannot determine
-     */
-    S24PackMode detectS24PackMode(const uint8_t* data, size_t numSamples) const {
-        size_t checkSamples = std::min<size_t>(numSamples, 64);
+    S24PackMode detectS24PackMode(const uint8_t* data, size_t numSamples) {
+        size_t checkSamples = std::min<size_t>(numSamples, 32);
         bool allZeroLSB = true;
         bool allZeroMSB = true;
 
@@ -1078,13 +733,14 @@ private:
         }
 
         if (!allZeroLSB && allZeroMSB) {
-            return S24PackMode::LsbAligned;  // Data in LSB, MSB is padding
+            return S24PackMode::LsbAligned;
         } else if (allZeroLSB && !allZeroMSB) {
-            return S24PackMode::MsbAligned;  // Data in MSB, LSB is padding
+            return S24PackMode::MsbAligned;
         } else if (allZeroLSB && allZeroMSB) {
-            return S24PackMode::Deferred;    // Silence - can't determine yet
+            // Silence - can't determine, use deferred
+            return S24PackMode::Deferred;
         }
-        // Both non-zero - ambiguous, default to LSB (more common)
+        // Both non-zero - ambiguous, default to LSB
         return S24PackMode::LsbAligned;
     }
 
@@ -1092,7 +748,7 @@ private:
     S24PackMode m_s24Hint = S24PackMode::Unknown;
     bool m_s24DetectionConfirmed = false;
     size_t m_deferredSampleCount = 0;
-    static constexpr size_t DEFERRED_TIMEOUT_SAMPLES = 48000;  // ~1 second at 48kHz
+    static constexpr size_t DEFERRED_TIMEOUT_SAMPLES = 48000;
 };
 
 #endif // DIRETTA_RING_BUFFER_H
diff --git a/src/DirettaSync.cpp b/src/DirettaSync.cpp
index f3c5d74..9c5c284 100644
--- a/src/DirettaSync.cpp
+++ b/src/DirettaSync.cpp
@@ -18,9 +18,12 @@ public:
         if (reconfiguring.load(std::memory_order_acquire)) {
             return;
         }
-        users_.fetch_add(1, std::memory_order_acq_rel);
+        // MUST use acquire: ensures increment visible to beginReconfigure()
+        // before any ring buffer operations
+        users_.fetch_add(1, std::memory_order_acquire);
         if (reconfiguring.load(std::memory_order_acquire)) {
-            users_.fetch_sub(1, std::memory_order_acq_rel);
+            // Bail-out: never entered guarded section, relaxed is safe
+            users_.fetch_sub(1, std::memory_order_relaxed);
             return;
         }
         active_ = true;
@@ -28,7 +31,8 @@ public:
 
     ~RingAccessGuard() {
         if (active_) {
-            users_.fetch_sub(1, std::memory_order_acq_rel);
+            // Release: ensures all ring ops complete before decrement
+            users_.fetch_sub(1, std::memory_order_release);
         }
     }
 
@@ -40,6 +44,29 @@ private:
 };
 } // namespace
 
+//=============================================================================
+// Bit reversal lookup table for DSD MSB<->LSB conversion
+//=============================================================================
+
+static const uint8_t bitReverseTable[256] = {
+    0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
+    0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
+    0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
+    0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
+    0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
+    0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
+    0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
+    0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
+    0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
+    0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
+    0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
+    0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
+    0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
+    0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
+    0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
+    0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
+};
+
 //=============================================================================
 // Constructor / Destructor
 //=============================================================================
@@ -98,7 +125,6 @@ void DirettaSync::disable() {
     if (m_enabled) {
         shutdownWorker();
         DIRETTA::Sync::close();
-        m_sdkOpen = false;
         m_calculator.reset();
         m_enabled = false;
     }
@@ -113,10 +139,10 @@ bool DirettaSync::openSyncConnection() {
     DIRETTA_LOG("Opening DIRETTA::Sync with threadMode=" << m_config.threadMode);
 
     bool opened = false;
-    for (int attempt = 0; attempt < DirettaRetry::OPEN_RETRIES && !opened; attempt++) {
+    for (int attempt = 0; attempt < 3 && !opened; attempt++) {
         if (attempt > 0) {
             DIRETTA_LOG("open() retry #" << attempt);
-            std::this_thread::sleep_for(std::chrono::milliseconds(DirettaRetry::OPEN_DELAY_MS));
+            std::this_thread::sleep_for(std::chrono::milliseconds(500));
         }
         opened = DIRETTA::Sync::open(
             DIRETTA::Sync::THRED_MODE(m_config.threadMode),
@@ -129,7 +155,6 @@ bool DirettaSync::openSyncConnection() {
         return false;
     }
 
-    m_sdkOpen = true;
     inquirySupportFormat(m_targetAddress);
 
     if (g_verbose) {
@@ -259,37 +284,11 @@ void DirettaSync::listTargets() {
         return;
     }
 
-    std::cout << "\nAvailable Diretta Targets (" << results.size() << " found):\n" << std::endl;
+    std::cout << "Available Diretta Targets (" << results.size() << " found):" << std::endl;
 
     int index = 1;
     for (const auto& target : results) {
-        const auto& info = target.second;
-        std::cout << "[" << index << "] " << info.targetName << std::endl;
-
-        // Show output/port name if available (differentiates I2S vs USB, etc.)
-        if (!info.outputName.empty()) {
-            std::cout << "    Output: " << info.outputName << std::endl;
-        }
-
-        // Show port numbers
-        std::cout << "    Port: IN=" << info.PI << " OUT=" << info.PO;
-        if (info.multiport) {
-            std::cout << " (multiport)";
-        }
-        std::cout << std::endl;
-
-        // Show configuration URL if available
-        if (!info.config.empty()) {
-            std::cout << "    Config: " << info.config << std::endl;
-        }
-
-        // Show SDK version
-        std::cout << "    Version: " << info.version << std::endl;
-
-        // Show Product ID
-        std::cout << "    ProductID: 0x" << std::hex << info.productID << std::dec << std::endl;
-
-        std::cout << std::endl;
+        std::cout << "[" << index << "] " << target.second.targetName << std::endl;
         index++;
     }
 
@@ -321,16 +320,6 @@ bool DirettaSync::open(const AudioFormat& format) {
         return false;
     }
 
-    // Reopen SDK if it was released (e.g., after playlist end)
-    if (!m_sdkOpen) {
-        std::cout << "[DirettaSync] SDK was released, reopening..." << std::endl;
-        if (!openSyncConnection()) {
-            std::cerr << "[DirettaSync] ERROR: Failed to reopen SDK" << std::endl;
-            return false;
-        }
-        std::cout << "[DirettaSync] SDK reopened successfully" << std::endl;
-    }
-
     bool newIsDsd = format.isDSD;
     bool needFullConnect = true;  // Whether we need connectPrepare/connect/connectWait
 
@@ -349,20 +338,7 @@ bool DirettaSync::open(const AudioFormat& format) {
                   << format.bitDepth << "bit/" << format.channels << "ch"
                   << (format.isDSD ? " DSD" : " PCM") << std::endl;
 
-        // EXPERIMENTAL: Check force full reopen flag (user-initiated track change)
-        // When set, bypass quick path even for same format
-        if (m_forceFullReopen) {
-            std::cout << "[DirettaSync] EXPERIMENTAL: Force full reopen requested (user interaction)" << std::endl;
-            m_forceFullReopen = false;  // Clear flag after use
-
-            // Use standard reopen sequence for clean transition
-            if (!reopenForFormatChange()) {
-                std::cerr << "[DirettaSync] Failed to reopen for user-initiated change" << std::endl;
-                return false;
-            }
-            needFullConnect = true;
-            // Skip to full connect path (after the if-else block)
-        } else if (sameFormat) {
+        if (sameFormat) {
             std::cout << "[DirettaSync] Same format - quick resume (no setSink)" << std::endl;
 
             // Send silence before transition to flush Diretta pipeline
@@ -389,135 +365,12 @@ bool DirettaSync::open(const AudioFormat& format) {
             std::cout << "[DirettaSync] ========== OPEN COMPLETE (quick) ==========" << std::endl;
             return true;
         } else {
-            // Format change detected
-            bool wasDSD = m_previousFormat.isDSD;
-            bool nowDSD = format.isDSD;
-            bool nowPCM = !format.isDSD;
-
-            // Detect rate changes (DSD or PCM)
-            // DSD512×44.1 (22,579,200 Hz) ↔ DSD512×48 (24,576,000 Hz) requires clock domain change
-            bool isDsdRateChange = wasDSD && nowDSD &&
-                                   (m_previousFormat.sampleRate != format.sampleRate);
-            bool isPcmRateChange = !wasDSD && nowPCM &&
-                                   (m_previousFormat.sampleRate != format.sampleRate);
-
-            if (wasDSD && (nowPCM || isDsdRateChange)) {
-                // DSD→PCM or any DSD rate change: Full close/reopen for clean transition
-                // I2S targets are timing-sensitive and need a clean break
-                // Rate changes cause noise if target's internal buffers aren't fully flushed
-                // Clock domain changes (44.1kHz ↔ 48kHz family) also require full reset
-                // Note: We can't send silence here because playback is already stopped
-                // (auto-stop happens before URI change), so getNewStream() isn't being called
-                if (nowPCM) {
-                    std::cout << "[DirettaSync] DSD->PCM transition - full close/reopen" << std::endl;
-                } else {
-                    int prevMultiplier = m_previousFormat.sampleRate / 2822400;
-                    int newMultiplier = format.sampleRate / 2822400;
-                    std::cout << "[DirettaSync] DSD" << (prevMultiplier * 64) << "->DSD"
-                              << (newMultiplier * 64) << " rate change - full close/reopen" << std::endl;
-                }
-
-                int dsdMultiplier = m_previousFormat.sampleRate / 44100;
-                std::cout << "[DirettaSync] Previous format was DSD" << dsdMultiplier << std::endl;
-
-                // Clear any pending silence requests (playback is stopped, can't send anyway)
-                m_silenceBuffersRemaining = 0;
-
-                // Stop playback and disconnect
-                stop();
-                disconnect(true);
-
-                // Close DIRETTA::Sync completely (critical for buffer flush)
-                DIRETTA::Sync::close();
-
-                // Shutdown worker thread
-                m_running = false;
-                {
-                    std::lock_guard<std::mutex> lock(m_workerMutex);
-                    if (m_workerThread.joinable()) {
-                        m_workerThread.join();
-                    }
-                }
-
-                m_open = false;
-                m_playing = false;
-                m_paused = false;
-
-                // Extended delay for target to fully reset
-                // DSD→PCM needs delay for clock domain switch (TEST: reduced from 800 to 400)
-                // DSD rate downgrade needs 400ms to flush internal buffers
-                int resetDelayMs = nowPCM ? 400 : 400;
-                std::cout << "[DirettaSync] Waiting " << resetDelayMs
-                          << "ms for target to reset..." << std::endl;
-                std::this_thread::sleep_for(std::chrono::milliseconds(resetDelayMs));
-
-                // Reopen DIRETTA::Sync fresh
-                ACQUA::Clock cycleTime = ACQUA::Clock::MicroSeconds(m_config.cycleTime);
-                if (!DIRETTA::Sync::open(
-                        DIRETTA::Sync::THRED_MODE(m_config.threadMode),
-                        cycleTime, 0, "DirettaRenderer", 0x44525400,
-                        -1, -1, 0, DIRETTA::Sync::MSMODE_MS3)) {
-                    std::cerr << "[DirettaSync] Failed to re-open DIRETTA::Sync" << std::endl;
-                    return false;
-                }
-                std::cout << "[DirettaSync] DIRETTA::Sync reopened" << std::endl;
-
-                // Fall through to full open path (needFullConnect is already true)
-            } else if (isPcmRateChange) {
-                // PCM rate change: Full close/reopen for clean transition
-                // Same issue as DSD - stale samples at old rate cause transition noise
-                std::cout << "[DirettaSync] PCM " << m_previousFormat.sampleRate << "Hz->"
-                          << format.sampleRate << "Hz rate change - full close/reopen" << std::endl;
-
-                // Clear any pending silence requests
-                m_silenceBuffersRemaining = 0;
-
-                // Stop playback and disconnect
-                stop();
-                disconnect(true);
-
-                // Close DIRETTA::Sync completely (critical for buffer flush)
-                DIRETTA::Sync::close();
-
-                // Shutdown worker thread
-                m_running = false;
-                {
-                    std::lock_guard<std::mutex> lock(m_workerMutex);
-                    if (m_workerThread.joinable()) {
-                        m_workerThread.join();
-                    }
-                }
-
-                m_open = false;
-                m_playing = false;
-                m_paused = false;
-
-                // Shorter delay for PCM rate change (TEST: reduced from 200 to 100)
-                int resetDelayMs = 100;
-                std::cout << "[DirettaSync] Waiting " << resetDelayMs
-                          << "ms for target to reset..." << std::endl;
-                std::this_thread::sleep_for(std::chrono::milliseconds(resetDelayMs));
-
-                // Reopen DIRETTA::Sync fresh
-                ACQUA::Clock cycleTime = ACQUA::Clock::MicroSeconds(m_config.cycleTime);
-                if (!DIRETTA::Sync::open(
-                        DIRETTA::Sync::THRED_MODE(m_config.threadMode),
-                        cycleTime, 0, "DirettaRenderer", 0x44525400,
-                        -1, -1, 0, DIRETTA::Sync::MSMODE_MS3)) {
-                    std::cerr << "[DirettaSync] Failed to re-open DIRETTA::Sync" << std::endl;
-                    return false;
-                }
-                std::cout << "[DirettaSync] DIRETTA::Sync reopened" << std::endl;
-
-                // Fall through to full open path
-            } else {
-                // Other format changes (PCM→DSD, bit depth change):
-                // use existing reopenForFormatChange()
-                std::cout << "[DirettaSync] Format change - reopen" << std::endl;
-                if (!reopenForFormatChange()) {
-                    std::cerr << "[DirettaSync] Failed to reopen for format change" << std::endl;
-                    return false;
-                }
+            // Format change - need full reopen for reliable Target reconfiguration
+            // Some Targets need DIRETTA::Sync to be fully closed and reopened
+            std::cout << "[DirettaSync] Format change - full reopen" << std::endl;
+            if (!reopenForFormatChange()) {
+                std::cerr << "[DirettaSync] Failed to reopen for format change" << std::endl;
+                return false;
             }
             needFullConnect = true;
         }
@@ -566,8 +419,8 @@ bool DirettaSync::open(const AudioFormat& format) {
 
     // setSink reconfiguration
     bool sinkSet = false;
-    int maxAttempts = needFullConnect ? DirettaRetry::SETSINK_RETRIES_FULL : DirettaRetry::SETSINK_RETRIES_QUICK;
-    int retryDelayMs = needFullConnect ? DirettaRetry::SETSINK_DELAY_FULL_MS : DirettaRetry::SETSINK_DELAY_QUICK_MS;
+    int maxAttempts = needFullConnect ? 20 : 15;
+    int retryDelayMs = needFullConnect ? 500 : 300;
     for (int attempt = 0; attempt < maxAttempts && !sinkSet; attempt++) {
         if (attempt > 0) {
             DIRETTA_LOG("setSink retry #" << attempt);
@@ -591,10 +444,10 @@ bool DirettaSync::open(const AudioFormat& format) {
         }
 
         bool connected = false;
-        for (int attempt = 0; attempt < DirettaRetry::CONNECT_RETRIES && !connected; attempt++) {
+        for (int attempt = 0; attempt < 3 && !connected; attempt++) {
             if (attempt > 0) {
                 DIRETTA_LOG("connect retry #" << attempt);
-                std::this_thread::sleep_for(std::chrono::milliseconds(DirettaRetry::CONNECT_DELAY_MS));
+                std::this_thread::sleep_for(std::chrono::milliseconds(500));
             }
             connected = connect(0);
         }
@@ -678,42 +531,35 @@ void DirettaSync::close() {
     DIRETTA_LOG("Close() done");
 }
 
-void DirettaSync::release() {
-    std::cout << "[DirettaSync] Release() - fully releasing target" << std::endl;
-
-    // First do a normal close if still open
-    if (m_open) {
-        close();
-    }
-
-    // Now fully close the SDK connection so target is released
-    if (m_sdkOpen) {
-        DIRETTA_LOG("Closing SDK connection...");
+bool DirettaSync::reopenForFormatChange() {
+    DIRETTA_LOG("reopenForFormatChange: sending silence before format switch...");
 
-        // Shutdown worker thread
-        m_running = false;
-        {
-            std::lock_guard<std::mutex> lock(m_workerMutex);
-            if (m_workerThread.joinable()) {
-                m_workerThread.join();
-            }
+    // Send silence buffers to let DAC mute gracefully before format change
+    // Scale silence with DSD rate - higher rates need more buffers for same duration
+    int silenceBuffers = 30;  // PCM default
+    if (m_isDsdMode.load(std::memory_order_acquire)) {
+        // Calculate DSD multiplier from sample rate (DSD64=64, DSD128=128, etc.)
+        int dsdMultiplier = m_previousFormat.sampleRate / 44100;
+        // Base 100 buffers for DSD64, scale up for higher rates
+        // DSD64: 100, DSD128: 200, DSD256: 400, DSD512: 800
+        silenceBuffers = 100 * (dsdMultiplier / 64);
+        if (silenceBuffers < 100) silenceBuffers = 100;
+        if (silenceBuffers > 1000) silenceBuffers = 1000;
+        DIRETTA_LOG("DSD" << dsdMultiplier << " -> silence buffers: " << silenceBuffers);
+    }
+    requestShutdownSilence(silenceBuffers);
+
+    // Wait for silence to be sent - scale timeout with buffer count
+    int timeoutMs = std::max(300, silenceBuffers * 2);
+    auto start = std::chrono::steady_clock::now();
+    while (m_silenceBuffersRemaining.load(std::memory_order_acquire) > 0) {
+        if (std::chrono::steady_clock::now() - start > std::chrono::milliseconds(timeoutMs)) {
+            DIRETTA_LOG("Silence timeout in reopenForFormatChange");
+            break;
         }
-
-        // Close SDK-level connection
-        DIRETTA::Sync::close();
-        m_sdkOpen = false;
-
-        // Brief delay to ensure target processes the disconnect
-        std::this_thread::sleep_for(std::chrono::milliseconds(100));
-
-        std::cout << "[DirettaSync] Target released" << std::endl;
+        std::this_thread::yield();
     }
 
-    // Clear format state so next open() starts fresh
-    m_hasPreviousFormat = false;
-}
-
-bool DirettaSync::reopenForFormatChange() {
     DIRETTA_LOG("reopenForFormatChange: stopping...");
 
     stop();
@@ -743,10 +589,10 @@ bool DirettaSync::reopenForFormatChange() {
 
     // Re-discover sink with retry
     bool sinkFound = false;
-    for (int attempt = 0; attempt < DirettaRetry::REOPEN_SINK_RETRIES && !sinkFound; attempt++) {
+    for (int attempt = 0; attempt < 10 && !sinkFound; attempt++) {
         if (attempt > 0) {
             DIRETTA_LOG("setSink retry #" << attempt);
-            std::this_thread::sleep_for(std::chrono::milliseconds(DirettaRetry::REOPEN_SINK_DELAY_MS));
+            std::this_thread::sleep_for(std::chrono::milliseconds(500));
         }
         sinkFound = setSink(m_targetAddress, cycleTime, false, m_effectiveMTU);
     }
@@ -790,6 +636,9 @@ void DirettaSync::fullReset() {
         m_isLowBitrate.store(false, std::memory_order_release);
         m_need24BitPack.store(false, std::memory_order_release);
         m_need16To32Upsample.store(false, std::memory_order_release);
+        m_bytesPerFrame.store(0, std::memory_order_release);
+        m_framesPerBufferRemainder.store(0, std::memory_order_release);
+        m_framesPerBufferAccumulator.store(0, std::memory_order_release);
 
         m_ringBuffer.clear();
     }
@@ -863,13 +712,8 @@ void DirettaSync::configureSinkDSD(uint32_t dsdBitRate, int channels, const Audi
         setSinkConfigure(fmt);
         m_needDsdBitReversal.store(!sourceIsLSB, std::memory_order_release);  // Reverse if source is MSB (DFF)
         m_needDsdByteSwap.store(false, std::memory_order_release);  // BIG endian = no swap
-        // Set cached conversion mode: no swap, maybe bit reverse
-        m_dsdConversionMode = m_needDsdBitReversal.load(std::memory_order_acquire)
-            ? DirettaRingBuffer::DSDConversionMode::BitReverseOnly
-            : DirettaRingBuffer::DSDConversionMode::Passthrough;
         DIRETTA_LOG("Sink DSD: LSB | BIG"
-                    << (m_needDsdBitReversal.load(std::memory_order_acquire) ? " (bit reversal)" : "")
-                    << " mode=" << static_cast<int>(m_dsdConversionMode));
+                    << (m_needDsdBitReversal.load(std::memory_order_acquire) ? " (bit reversal)" : ""));
         return;
     }
 
@@ -882,13 +726,8 @@ void DirettaSync::configureSinkDSD(uint32_t dsdBitRate, int channels, const Audi
         setSinkConfigure(fmt);
         m_needDsdBitReversal.store(sourceIsLSB, std::memory_order_release);  // Reverse if source is LSB (DSF)
         m_needDsdByteSwap.store(false, std::memory_order_release);  // BIG endian = no swap
-        // Set cached conversion mode: no swap, maybe bit reverse
-        m_dsdConversionMode = m_needDsdBitReversal.load(std::memory_order_acquire)
-            ? DirettaRingBuffer::DSDConversionMode::BitReverseOnly
-            : DirettaRingBuffer::DSDConversionMode::Passthrough;
         DIRETTA_LOG("Sink DSD: MSB | BIG"
-                    << (m_needDsdBitReversal.load(std::memory_order_acquire) ? " (bit reversal)" : "")
-                    << " mode=" << static_cast<int>(m_dsdConversionMode));
+                    << (m_needDsdBitReversal.load(std::memory_order_acquire) ? " (bit reversal)" : ""));
         return;
     }
 
@@ -901,13 +740,9 @@ void DirettaSync::configureSinkDSD(uint32_t dsdBitRate, int channels, const Audi
         setSinkConfigure(fmt);
         m_needDsdBitReversal.store(!sourceIsLSB, std::memory_order_release);
         m_needDsdByteSwap.store(true, std::memory_order_release);  // LITTLE endian = swap bytes
-        // Set cached conversion mode: always swap, maybe bit reverse
-        m_dsdConversionMode = m_needDsdBitReversal.load(std::memory_order_acquire)
-            ? DirettaRingBuffer::DSDConversionMode::BitReverseAndSwap
-            : DirettaRingBuffer::DSDConversionMode::ByteSwapOnly;
         DIRETTA_LOG("Sink DSD: LSB | LITTLE"
                     << (m_needDsdBitReversal.load(std::memory_order_acquire) ? " (bit reversal)" : "")
-                    << " (byte swap) mode=" << static_cast<int>(m_dsdConversionMode));
+                    << " (byte swap)");
         return;
     }
 
@@ -920,13 +755,9 @@ void DirettaSync::configureSinkDSD(uint32_t dsdBitRate, int channels, const Audi
         setSinkConfigure(fmt);
         m_needDsdBitReversal.store(sourceIsLSB, std::memory_order_release);
         m_needDsdByteSwap.store(true, std::memory_order_release);  // LITTLE endian = swap bytes
-        // Set cached conversion mode: always swap, maybe bit reverse
-        m_dsdConversionMode = m_needDsdBitReversal.load(std::memory_order_acquire)
-            ? DirettaRingBuffer::DSDConversionMode::BitReverseAndSwap
-            : DirettaRingBuffer::DSDConversionMode::ByteSwapOnly;
         DIRETTA_LOG("Sink DSD: MSB | LITTLE"
                     << (m_needDsdBitReversal.load(std::memory_order_acquire) ? " (bit reversal)" : "")
-                    << " (byte swap) mode=" << static_cast<int>(m_dsdConversionMode));
+                    << " (byte swap)");
         return;
     }
 
@@ -938,20 +769,6 @@ void DirettaSync::configureSinkDSD(uint32_t dsdBitRate, int channels, const Audi
         m_needDsdByteSwap.store(false, std::memory_order_release);
         DIRETTA_LOG("Sink DSD: FMT_DSD1 only"
                     << (m_needDsdBitReversal.load(std::memory_order_acquire) ? " (bit reversal)" : ""));
-
-        // Set cached conversion mode for optimized DSD path
-        bool needReverse = m_needDsdBitReversal.load(std::memory_order_acquire);
-        bool needSwap = m_needDsdByteSwap.load(std::memory_order_acquire);
-        if (needReverse && needSwap) {
-            m_dsdConversionMode = DirettaRingBuffer::DSDConversionMode::BitReverseAndSwap;
-        } else if (needReverse) {
-            m_dsdConversionMode = DirettaRingBuffer::DSDConversionMode::BitReverseOnly;
-        } else if (needSwap) {
-            m_dsdConversionMode = DirettaRingBuffer::DSDConversionMode::ByteSwapOnly;
-        } else {
-            m_dsdConversionMode = DirettaRingBuffer::DSDConversionMode::Passthrough;
-        }
-        DIRETTA_LOG("DSD conversion mode: " << static_cast<int>(m_dsdConversionMode));
         return;
     }
 
@@ -976,10 +793,6 @@ void DirettaSync::configureRingPCM(int rate, int channels, int direttaBps, int i
     m_needDsdBitReversal.store(false, std::memory_order_release);
     m_needDsdByteSwap.store(false, std::memory_order_release);
     m_isLowBitrate.store(direttaBps <= 2 && rate <= 48000, std::memory_order_release);
-    m_dsdConversionMode = DirettaRingBuffer::DSDConversionMode::Passthrough;
-
-    // Increment format generation to invalidate cached values in sendAudio
-    m_formatGeneration.fetch_add(1, std::memory_order_release);
 
     size_t bytesPerSecond = static_cast<size_t>(rate) * channels * direttaBps;
     size_t ringSize = DirettaBuffer::calculateBufferSize(bytesPerSecond, DirettaBuffer::PCM_BUFFER_SECONDS);
@@ -987,7 +800,13 @@ void DirettaSync::configureRingPCM(int rate, int channels, int direttaBps, int i
     m_ringBuffer.resize(ringSize, 0x00);
     ringSize = m_ringBuffer.size();
 
-    m_bytesPerBuffer.store(((rate + 999) / 1000) * channels * direttaBps, std::memory_order_release);
+    int bytesPerFrame = channels * direttaBps;
+    int framesBase = rate / 1000;
+    int framesRemainder = rate % 1000;
+    m_bytesPerFrame.store(bytesPerFrame, std::memory_order_release);
+    m_framesPerBufferRemainder.store(static_cast<uint32_t>(framesRemainder), std::memory_order_release);
+    m_framesPerBufferAccumulator.store(0, std::memory_order_release);
+    m_bytesPerBuffer.store(framesBase * bytesPerFrame, std::memory_order_release);
 
     m_prefillTarget = DirettaBuffer::calculatePrefill(bytesPerSecond, false,
         m_isLowBitrate.load(std::memory_order_acquire));
@@ -997,6 +816,10 @@ void DirettaSync::configureRingPCM(int rate, int channels, int direttaBps, int i
     DIRETTA_LOG("Ring PCM: " << rate << "Hz " << channels << "ch "
                 << direttaBps << "bps, buffer=" << ringSize
                 << ", prefill=" << m_prefillTarget);
+
+    // Increment format generation to invalidate cached values
+    m_formatGeneration.fetch_add(1, std::memory_order_release);
+    m_consumerStateGen.fetch_add(1, std::memory_order_release);
 }
 
 void DirettaSync::configureRingDSD(uint32_t byteRate, int channels) {
@@ -1009,9 +832,6 @@ void DirettaSync::configureRingDSD(uint32_t byteRate, int channels) {
     m_channels.store(channels, std::memory_order_release);
     m_isLowBitrate.store(false, std::memory_order_release);
 
-    // Increment format generation to invalidate cached values in sendAudio
-    m_formatGeneration.fetch_add(1, std::memory_order_release);
-
     uint32_t bytesPerSecond = byteRate * channels;
     size_t ringSize = DirettaBuffer::calculateBufferSize(bytesPerSecond, DirettaBuffer::DSD_BUFFER_SECONDS);
 
@@ -1023,6 +843,9 @@ void DirettaSync::configureRingDSD(uint32_t byteRate, int channels) {
     bytesPerBuffer = ((bytesPerBuffer + (4 * channels - 1)) / (4 * channels)) * (4 * channels);
     if (bytesPerBuffer < 64) bytesPerBuffer = 64;
     m_bytesPerBuffer.store(static_cast<int>(bytesPerBuffer), std::memory_order_release);
+    m_bytesPerFrame.store(0, std::memory_order_release);
+    m_framesPerBufferRemainder.store(0, std::memory_order_release);
+    m_framesPerBufferAccumulator.store(0, std::memory_order_release);
 
     m_prefillTarget = DirettaBuffer::calculatePrefill(bytesPerSecond, true, false);
     m_prefillTarget = std::min(m_prefillTarget, ringSize / 4);
@@ -1030,6 +853,10 @@ void DirettaSync::configureRingDSD(uint32_t byteRate, int channels) {
 
     DIRETTA_LOG("Ring DSD: byteRate=" << byteRate << " ch=" << channels
                 << " buffer=" << ringSize << " prefill=" << m_prefillTarget);
+
+    // Increment format generation to invalidate cached values
+    m_formatGeneration.fetch_add(1, std::memory_order_release);
+    m_consumerStateGen.fetch_add(1, std::memory_order_release);
 }
 
 //=============================================================================
@@ -1052,14 +879,14 @@ bool DirettaSync::startPlayback() {
 }
 
 void DirettaSync::stopPlayback(bool immediate) {
-    // Log accumulated underruns at session end
+    if (!m_playing) return;
+
+    // Report accumulated underruns (moved from hot path)
     uint32_t underruns = m_underrunCount.exchange(0, std::memory_order_relaxed);
     if (underruns > 0) {
         std::cerr << "[DirettaSync] Session had " << underruns << " underrun(s)" << std::endl;
     }
 
-    if (!m_playing) return;
-
     if (!immediate) {
         requestShutdownSilence(m_isDsdMode.load(std::memory_order_acquire) ? 50 : 20);
 
@@ -1111,11 +938,6 @@ void DirettaSync::resumePlayback() {
     DIRETTA_LOG("Resumed - buffer cleared, waiting for prefill");
 }
 
-void DirettaSync::sendPreTransitionSilence() {
-    // Pre-transition silence disabled - was causing issues during format switching
-    // The stopPlayback() silence mechanism handles this case adequately
-}
-
 //=============================================================================
 // Audio Data (Push Interface)
 //=============================================================================
@@ -1128,23 +950,26 @@ size_t DirettaSync::sendAudio(const uint8_t* data, size_t numSamples) {
     RingAccessGuard ringGuard(m_ringUsers, m_reconfiguring);
     if (!ringGuard.active()) return 0;
 
-    // Generation counter optimization: single atomic load vs 5-6 loads
-    // Only reload format atomics when format has actually changed
+    // Generation counter optimization: single atomic load in common case
     uint32_t gen = m_formatGeneration.load(std::memory_order_acquire);
     if (gen != m_cachedFormatGen) {
+        // Cold path: reload all format values (only on format change)
         m_cachedDsdMode = m_isDsdMode.load(std::memory_order_acquire);
         m_cachedPack24bit = m_need24BitPack.load(std::memory_order_acquire);
         m_cachedUpsample16to32 = m_need16To32Upsample.load(std::memory_order_acquire);
+        m_cachedNeedBitReversal = m_needDsdBitReversal.load(std::memory_order_acquire);
+        m_cachedNeedByteSwap = m_needDsdByteSwap.load(std::memory_order_acquire);
         m_cachedChannels = m_channels.load(std::memory_order_acquire);
         m_cachedBytesPerSample = m_bytesPerSample.load(std::memory_order_acquire);
-        m_cachedDsdConversionMode = m_dsdConversionMode;
         m_cachedFormatGen = gen;
     }
 
-    // Use cached values (no atomic loads in hot path)
+    // Hot path: use cached values
     bool dsdMode = m_cachedDsdMode;
     bool pack24bit = m_cachedPack24bit;
     bool upsample16to32 = m_cachedUpsample16to32;
+    bool needBitReversal = m_cachedNeedBitReversal;
+    bool needByteSwap = m_cachedNeedByteSwap;
     int numChannels = m_cachedChannels;
     int bytesPerSample = m_cachedBytesPerSample;
 
@@ -1158,9 +983,10 @@ size_t DirettaSync::sendAudio(const uint8_t* data, size_t numSamples) {
         // Reverse: totalBytes = numSamples * channels / 8
         totalBytes = (numSamples * numChannels) / 8;
 
-        // Use optimized path with cached conversion mode (no per-iteration branching)
-        written = m_ringBuffer.pushDSDPlanarOptimized(
-            data, totalBytes, numChannels, m_cachedDsdConversionMode);
+        written = m_ringBuffer.pushDSDPlanar(
+            data, totalBytes, numChannels,
+            needBitReversal ? bitReverseTable : nullptr,
+            needByteSwap);
         formatLabel = "DSD";
 
     } else if (pack24bit) {
@@ -1222,14 +1048,35 @@ float DirettaSync::getBufferLevel() const {
 // DIRETTA::Sync Overrides
 //=============================================================================
 
-bool DirettaSync::getNewStream(diretta_stream& baseStream) {
-    // SDK 148+ uses diretta_stream& but passes DIRETTA::Stream objects
-    DIRETTA::Stream& stream = static_cast<DIRETTA::Stream&>(baseStream);
-
+bool DirettaSync::getNewStream(DIRETTA::Stream& stream) {
     m_workerActive = true;
 
-    int currentBytesPerBuffer = m_bytesPerBuffer.load(std::memory_order_acquire);
-    uint8_t currentSilenceByte = m_ringBuffer.silenceByte();
+    // Generation counter optimization: single atomic load in common case
+    uint32_t gen = m_consumerStateGen.load(std::memory_order_acquire);
+    if (gen != m_cachedConsumerGen) {
+        // Cold path: reload stable configuration (only on format change)
+        m_cachedBytesPerBuffer = m_bytesPerBuffer.load(std::memory_order_acquire);
+        m_cachedFramesRemainder = m_framesPerBufferRemainder.load(std::memory_order_acquire);
+        m_cachedBytesPerFrame = m_bytesPerFrame.load(std::memory_order_acquire);
+        m_cachedConsumerIsDsd = m_isDsdMode.load(std::memory_order_acquire);
+        m_cachedSilenceByte = m_ringBuffer.silenceByte();
+        m_cachedConsumerGen = gen;
+    }
+
+    // Hot path: use cached values
+    int currentBytesPerBuffer = m_cachedBytesPerBuffer;
+    uint32_t remainder = m_cachedFramesRemainder;
+    if (remainder != 0) {
+        int bytesPerFrame = m_cachedBytesPerFrame;
+        uint32_t acc = m_framesPerBufferAccumulator.load(std::memory_order_relaxed);
+        acc += remainder;
+        if (acc >= 1000) {
+            acc -= 1000;
+            currentBytesPerBuffer += bytesPerFrame;
+        }
+        m_framesPerBufferAccumulator.store(acc, std::memory_order_relaxed);
+    }
+    uint8_t currentSilenceByte = m_cachedSilenceByte;
 
     if (stream.size() != static_cast<size_t>(currentBytesPerBuffer)) {
         stream.resize(currentBytesPerBuffer);
@@ -1244,7 +1091,7 @@ bool DirettaSync::getNewStream(diretta_stream& baseStream) {
         return true;
     }
 
-    bool currentIsDsd = m_isDsdMode.load(std::memory_order_acquire);
+    bool currentIsDsd = m_cachedConsumerIsDsd;
     size_t currentRingSize = m_ringBuffer.size();
 
     // Shutdown silence
@@ -1271,40 +1118,12 @@ bool DirettaSync::getNewStream(diretta_stream& baseStream) {
     }
 
     // Post-online stabilization
-    // Scale stabilization to achieve consistent WARMUP TIME regardless of MTU
-    // With small MTU (1500), getNewStream() is called more frequently (shorter cycle time)
-    // With large MTU (9000+), calls are less frequent (longer cycle time)
-    // We need to scale buffer count to achieve target warmup duration
     if (!m_postOnlineDelayDone.load(std::memory_order_acquire)) {
-        int stabilizationTarget = static_cast<int>(DirettaBuffer::POST_ONLINE_SILENCE_BUFFERS);
-
-        if (currentIsDsd) {
-            // Target warmup time scales with DSD rate:
-            // DSD64: 50ms, DSD128: 100ms, DSD256: 200ms, DSD512: 400ms
-            int currentSampleRate = m_sampleRate.load(std::memory_order_acquire);
-            int dsdMultiplier = currentSampleRate / 2822400;  // DSD64 = 1
-            int targetWarmupMs = 50 * std::max(1, dsdMultiplier);  // 50ms baseline
-
-            // Calculate cycle time based on MTU and data rate
-            // cycleTime = (efficientMTU / bytesPerSecond) in microseconds
-            int efficientMTU = static_cast<int>(m_effectiveMTU) - 24;  // Subtract overhead
-            double bytesPerSecond = static_cast<double>(currentSampleRate) * 2 / 8.0;  // 2ch, 1bit
-            double cycleTimeUs = (static_cast<double>(efficientMTU) / bytesPerSecond) * 1000000.0;
-
-            // Calculate buffers needed for target warmup time
-            // targetWarmupMs * 1000 = warmup in microseconds
-            double buffersNeeded = (targetWarmupMs * 1000.0) / cycleTimeUs;
-            stabilizationTarget = static_cast<int>(std::ceil(buffersNeeded));
-
-            // Clamp to reasonable range
-            stabilizationTarget = std::max(50, std::min(stabilizationTarget, 3000));
-        }
-
         int count = m_stabilizationCount.fetch_add(1, std::memory_order_acq_rel) + 1;
-        if (count >= stabilizationTarget) {
+        if (count >= static_cast<int>(DirettaBuffer::POST_ONLINE_SILENCE_BUFFERS)) {
             m_postOnlineDelayDone = true;
             m_stabilizationCount = 0;
-            DIRETTA_LOG("Post-online stabilization complete (" << count << " buffers)");
+            DIRETTA_LOG("Post-online stabilization complete");
         }
         std::memset(dest, currentSilenceByte, currentBytesPerBuffer);
         m_workerActive = false;
@@ -1321,7 +1140,7 @@ bool DirettaSync::getNewStream(diretta_stream& baseStream) {
                     << fillPct << "%) " << (currentIsDsd ? "[DSD]" : "[PCM]"));
     }
 
-    // Underrun - count silently, log at session end
+    // Underrun
     if (avail < static_cast<size_t>(currentBytesPerBuffer)) {
         m_underrunCount.fetch_add(1, std::memory_order_relaxed);
         std::memset(dest, currentSilenceByte, currentBytesPerBuffer);
diff --git a/src/DirettaSync.h b/src/DirettaSync.h
index cfde038..aa7a238 100644
--- a/src/DirettaSync.h
+++ b/src/DirettaSync.h
@@ -69,40 +69,16 @@ struct AudioFormat {
     bool operator!=(const AudioFormat& other) const { return !(*this == other); }
 };
 
-//=============================================================================
-// Retry Configuration
-//=============================================================================
-
-namespace DirettaRetry {
-    // Connection establishment (DIRETTA::Sync::open)
-    constexpr int OPEN_RETRIES = 3;
-    constexpr int OPEN_DELAY_MS = 500;
-
-    // setSink configuration
-    constexpr int SETSINK_RETRIES_FULL = 20;      // After disconnect
-    constexpr int SETSINK_RETRIES_QUICK = 15;     // Quick reconfigure
-    constexpr int SETSINK_DELAY_FULL_MS = 500;
-    constexpr int SETSINK_DELAY_QUICK_MS = 300;
-
-    // connect() call
-    constexpr int CONNECT_RETRIES = 3;
-    constexpr int CONNECT_DELAY_MS = 500;
-
-    // Format change reopen
-    constexpr int REOPEN_SINK_RETRIES = 10;
-    constexpr int REOPEN_SINK_DELAY_MS = 500;
-}
-
 //=============================================================================
 // Buffer Configuration
 //=============================================================================
 
 namespace DirettaBuffer {
     constexpr float DSD_BUFFER_SECONDS = 0.8f;
-    constexpr float PCM_BUFFER_SECONDS = 0.3f;  // Was 1.0f - low latency
+    constexpr float PCM_BUFFER_SECONDS = 1.0f;
 
     constexpr size_t DSD_PREFILL_MS = 200;
-    constexpr size_t PCM_PREFILL_MS = 30;       // Was 50 - faster start
+    constexpr size_t PCM_PREFILL_MS = 50;
     constexpr size_t PCM_LOWRATE_PREFILL_MS = 100;
 
     constexpr unsigned int DAC_STABILIZATION_MS = 100;
@@ -111,8 +87,7 @@ namespace DirettaBuffer {
     constexpr unsigned int POST_ONLINE_SILENCE_BUFFERS = 50;
 
     // UPnP push model needs larger buffers than MPD's pull model
-    // 64KB = ~370ms floor at 44.1kHz/16-bit, negligible at higher rates
-    constexpr size_t MIN_BUFFER_BYTES = 65536;  // Was 3072000
+    constexpr size_t MIN_BUFFER_BYTES = 3072000;
     constexpr size_t MAX_BUFFER_BYTES = 16777216;
     constexpr size_t MIN_PREFILL_BYTES = 1024;
 
@@ -129,31 +104,6 @@ namespace DirettaBuffer {
         size_t result = (bytesPerSecond * prefillMs) / 1000;
         return std::max(result, MIN_PREFILL_BYTES);
     }
-
-    // Calculate DSD samples per call based on rate
-    // Target: ~10-12ms chunks for consistent scheduling granularity
-    // Returns DSD samples (1-bit), which convert to bytes via: bytes = samples * channels / 8
-    inline size_t calculateDsdSamplesPerCall(uint32_t dsdSampleRate) {
-        // Target chunk duration in milliseconds
-        constexpr double TARGET_CHUNK_MS = 12.0;
-
-        // Limits
-        constexpr size_t MIN_DSD_SAMPLES = 8192;   // ~3ms at DSD64
-        constexpr size_t MAX_DSD_SAMPLES = 131072; // ~46ms at DSD64, ~3ms at DSD1024
-
-        // Calculate samples for target duration
-        // DSD sample rate is the 1-bit rate (e.g., 2822400 for DSD64)
-        size_t samplesPerCall = static_cast<size_t>(dsdSampleRate * TARGET_CHUNK_MS / 1000.0);
-
-        // Round to multiple of 256 for alignment (32 bytes per channel minimum)
-        samplesPerCall = ((samplesPerCall + 255) / 256) * 256;
-
-        // Clamp to reasonable range (match existing std::max/std::min pattern)
-        samplesPerCall = std::max(samplesPerCall, MIN_DSD_SAMPLES);
-        samplesPerCall = std::min(samplesPerCall, MAX_DSD_SAMPLES);
-
-        return samplesPerCall;
-    }
 }
 
 //=============================================================================
@@ -240,19 +190,10 @@ public:
     bool open(const AudioFormat& format);
 
     /**
-     * @brief Close connection (keeps SDK ready for quick resume)
+     * @brief Close connection
      */
     void close();
 
-    /**
-     * @brief Release target completely (closes SDK connection)
-     *
-     * Use this when playback has ended and we want to fully release
-     * the target so it can accept connections from other sources.
-     * The next open() will automatically reopen the SDK.
-     */
-    void release();
-
     bool isOpen() const { return m_open; }
     bool isOnline() { return is_online(); }
 
@@ -265,15 +206,6 @@ public:
     void pausePlayback();
     void resumePlayback();
 
-    /**
-     * @brief Send silence buffers before format transition
-     *
-     * Call this BEFORE stopPlayback() when changing formats (DSD→PCM, DSD rate change).
-     * Silence buffers flush the Diretta pipeline to prevent crackling on transitions.
-     * Scales silence duration with DSD rate (higher rates need more buffers).
-     */
-    void sendPreTransitionSilence();
-
     bool isPlaying() const { return m_playing; }
     bool isPaused() const { return m_paused; }
 
@@ -293,21 +225,12 @@ public:
     const AudioFormat& getFormat() const { return m_currentFormat; }
 
     /**
-     * @brief Set S24 pack mode hint for 24-bit audio
-     *
-     * Propagates alignment hint from TrackInfo to ring buffer for better
-     * 24-bit sample detection when track starts with silence.
+     * @brief Set S24 pack mode hint from TrackInfo
      */
     void setS24PackModeHint(DirettaRingBuffer::S24PackMode hint) {
         m_ringBuffer.setS24PackModeHint(hint);
     }
 
-    // EXPERIMENTAL: Force full reopen on next open() call
-    // When set, bypasses quick-reconnect even for same-format tracks.
-    // Use case: User-initiated track changes (vs gapless sequential playback)
-    // Set this flag before stopping playback on user interaction.
-    void setForceFullReopen(bool force) { m_forceFullReopen = force; }
-
     //=========================================================================
     // Target Management
     //=========================================================================
@@ -322,7 +245,7 @@ protected:
     // DIRETTA::Sync Overrides
     //=========================================================================
 
-    bool getNewStream(diretta_stream& stream) override;
+    bool getNewStream(DIRETTA::Stream& stream) override;
     bool getNewStreamCmp() override { return true; }
     bool startSyncWorker() override;
     void statusUpdate() override {}
@@ -377,9 +300,8 @@ private:
     uint32_t m_effectiveMTU = 1500;
 
     // Connection state
-    std::atomic<bool> m_enabled{false};      // Target discovered, ready to use
-    std::atomic<bool> m_sdkOpen{false};      // SDK-level connection open
-    std::atomic<bool> m_open{false};         // Connected to target for playback
+    std::atomic<bool> m_enabled{false};
+    std::atomic<bool> m_open{false};
     std::atomic<bool> m_playing{false};
     std::atomic<bool> m_paused{false};
 
@@ -392,16 +314,37 @@ private:
     std::atomic<bool> m_running{false};
     std::atomic<bool> m_stopRequested{false};
     std::atomic<bool> m_draining{false};
-
-    // EXPERIMENTAL: Force full reopen on user-initiated track changes
-    // Cleared after use in open()
-    bool m_forceFullReopen{false};
     std::atomic<bool> m_workerActive{false};
     std::thread m_workerThread;
     std::mutex m_workerMutex;
     std::mutex m_configMutex;
     std::atomic<bool> m_reconfiguring{false};
     mutable std::atomic<int> m_ringUsers{0};
+    std::atomic<uint32_t> m_underrunCount{0};
+
+    // Format generation counter - incremented on ANY format change
+    std::atomic<uint32_t> m_formatGeneration{0};
+
+    // Cached format values for sendAudio fast path (producer thread only)
+    uint32_t m_cachedFormatGen{0};
+    bool m_cachedDsdMode{false};
+    bool m_cachedPack24bit{false};
+    bool m_cachedUpsample16to32{false};
+    bool m_cachedNeedBitReversal{false};
+    bool m_cachedNeedByteSwap{false};
+    int m_cachedChannels{2};
+    int m_cachedBytesPerSample{2};
+
+    // Consumer state generation - incremented on config changes
+    std::atomic<uint32_t> m_consumerStateGen{0};
+
+    // Cached consumer state for getNewStream fast path (worker thread only)
+    uint32_t m_cachedConsumerGen{0};
+    int m_cachedBytesPerBuffer{176};
+    uint32_t m_cachedFramesRemainder{0};
+    int m_cachedBytesPerFrame{0};
+    bool m_cachedConsumerIsDsd{false};
+    uint8_t m_cachedSilenceByte{0};
 
     // Ring buffer
     DirettaRingBuffer m_ringBuffer;
@@ -412,6 +355,9 @@ private:
     std::atomic<int> m_bytesPerSample{2};
     std::atomic<int> m_inputBytesPerSample{2};
     std::atomic<int> m_bytesPerBuffer{176};
+    std::atomic<int> m_bytesPerFrame{0};
+    std::atomic<uint32_t> m_framesPerBufferRemainder{0};
+    std::atomic<uint32_t> m_framesPerBufferAccumulator{0};
     std::atomic<bool> m_need24BitPack{false};
     std::atomic<bool> m_need16To32Upsample{false};
     std::atomic<bool> m_isDsdMode{false};
@@ -419,23 +365,6 @@ private:
     std::atomic<bool> m_needDsdByteSwap{false};  // For LITTLE endian targets
     std::atomic<bool> m_isLowBitrate{false};
 
-    // Cached DSD conversion mode - set at track open, eliminates per-iteration branch checks
-    DirettaRingBuffer::DSDConversionMode m_dsdConversionMode{DirettaRingBuffer::DSDConversionMode::Passthrough};
-
-    // Format generation counter - incremented on ANY format change
-    // Allows sendAudio to skip reloading atomics when format hasn't changed
-    std::atomic<uint32_t> m_formatGeneration{0};
-
-    // Cached format values for sendAudio fast path (updated when generation changes)
-    // Protected by generation counter check - no race with configureRingXXX
-    uint32_t m_cachedFormatGen{0};
-    bool m_cachedDsdMode{false};
-    bool m_cachedPack24bit{false};
-    bool m_cachedUpsample16to32{false};
-    int m_cachedChannels{2};
-    int m_cachedBytesPerSample{2};
-    DirettaRingBuffer::DSDConversionMode m_cachedDsdConversionMode{DirettaRingBuffer::DSDConversionMode::Passthrough};
-
     // Prefill and stabilization
     size_t m_prefillTarget = 0;
     std::atomic<bool> m_prefillComplete{false};
@@ -446,7 +375,6 @@ private:
     // Statistics
     std::atomic<int> m_streamCount{0};
     std::atomic<int> m_pushCount{0};
-    std::atomic<uint32_t> m_underrunCount{0};
 };
 
 #endif // DIRETTA_SYNC_H
diff --git a/src/memcpyfast_audio.h b/src/memcpyfast_audio.h
index 5206d9f..fecb461 100644
--- a/src/memcpyfast_audio.h
+++ b/src/memcpyfast_audio.h
@@ -1,33 +1,20 @@
 #ifndef __MEMCPYFAST_AUDIO_H__
 #define __MEMCPYFAST_AUDIO_H__
 
+#include "FastMemcpy_Audio.h"
+#include <immintrin.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <cstdint>
 #include <cstddef>
 #include <cstring>
 
-//---------------------------------------------------------------------
-// Architecture detection
-//---------------------------------------------------------------------
-#if defined(__x86_64__) || defined(_M_X64) || defined(__i386__) || defined(_M_IX86)
-    #define MEMCPY_AUDIO_X86 1
-#elif defined(__aarch64__) || defined(_M_ARM64)
-    #define MEMCPY_AUDIO_ARM64 1
-#endif
-
-#ifdef MEMCPY_AUDIO_X86
-#include "FastMemcpy_Audio.h"
-#include <immintrin.h>
-
 #ifdef __AVX512F__
 #include "FastMemcpy_Audio_AVX512.h"
 #endif
-#endif // MEMCPY_AUDIO_X86
 
-#ifdef MEMCPY_AUDIO_X86
 //---------------------------------------------------------------------
-// Runtime CPU feature detection (x86 only)
+// Runtime CPU feature detection
 //---------------------------------------------------------------------
 static int g_avx512_checked = 0;
 static int g_has_avx512 = 0;
@@ -48,13 +35,10 @@ static inline int detect_avx512(void) {
     }
     return g_has_avx512;
 }
-#endif // MEMCPY_AUDIO_X86
 
-#ifdef MEMCPY_AUDIO_X86
 /**
  * Consistent-timing memcpy for audio buffers (128-4096 bytes)
  * Uses overlapping stores for tail handling to eliminate timing variance
- * x86 AVX2 implementation
  */
 static inline void memcpy_audio_fixed(void* dst, const void* src, size_t size) {
     uint8_t* d = static_cast<uint8_t*>(dst);
@@ -139,7 +123,7 @@ static inline void prefetch_audio_buffer(const void* src, size_t size) {
 #define AVX512_THRESHOLD (32 * 1024)
 
 //---------------------------------------------------------------------
-// Main dispatcher - selects optimal path based on size and CPU (x86)
+// Main dispatcher - selects optimal path based on size and CPU
 //---------------------------------------------------------------------
 static inline void* memcpy_audio(void *dst, const void *src, size_t len) {
 #ifndef NDEBUG
@@ -161,46 +145,4 @@ static inline void* memcpy_audio(void *dst, const void *src, size_t len) {
     return memcpy_audio_fast(dst, src, len);
 }
 
-#else // !MEMCPY_AUDIO_X86 (ARM64 and other platforms)
-
-//---------------------------------------------------------------------
-// ARM64 / Fallback implementation
-// Uses standard memcpy - still fast on ARM64 due to NEON auto-vectorization
-//---------------------------------------------------------------------
-
-/**
- * Prefetch audio buffer (no-op on non-x86, compiler may auto-prefetch)
- */
-static inline void prefetch_audio_buffer(const void* src, size_t size) {
-    (void)src;
-    (void)size;
-    // ARM64: __builtin_prefetch could be added here if needed
-}
-
-/**
- * Audio memcpy - uses standard memcpy on ARM64
- * GCC/Clang will auto-vectorize with NEON on ARM64
- */
-static inline void* memcpy_audio(void *dst, const void *src, size_t len) {
-#ifndef NDEBUG
-    const char *s = (const char *)src;
-    const char *d = (const char *)dst;
-    if (len > 0 && ((s < d && s + len > d) || (d < s && d + len > s))) {
-        fprintf(stderr, "FATAL: memcpy_audio called with overlapping buffers!\n");
-        fprintf(stderr, "  src=%p, dst=%p, len=%zu\n", src, dst, len);
-        abort();
-    }
-#endif
-    return std::memcpy(dst, src, len);
-}
-
-/**
- * Fixed-timing memcpy - uses standard memcpy on ARM64
- */
-static inline void memcpy_audio_fixed(void* dst, const void* src, size_t size) {
-    std::memcpy(dst, src, size);
-}
-
-#endif // MEMCPY_AUDIO_X86
-
 #endif // __MEMCPYFAST_AUDIO_H__
diff --git a/usb-ethernet_driver_install.sh b/usb-ethernet_driver_install.sh
deleted file mode 100644
index a91f16b..0000000
--- a/usb-ethernet_driver_install.sh
+++ /dev/null
@@ -1,460 +0,0 @@
-#!/bin/bash
-#
-# r8152 Driver Installation Script
-# Downloads, installs Realtek r8152 USB Ethernet driver and configures network
-# Supports: Ubuntu/Debian, Fedora/RHEL/CentOS
-#
-
-set -e  # Exit on error
-
-# Configuration
-CONNECTION_NAME="diretta"
-MTU_SIZE="16128"
-WORK_DIR="$HOME/r8152"
-
-# Realtek download page (driver must be downloaded manually or we parse the page)
-REALTEK_PAGE="https://www.realtek.com/Download/List?cate_id=585"
-# Direct link pattern (changes with versions)
-# As of 2025, the driver is at:
-REALTEK_DIRECT_URL="https://www.realtek.com/Download/ToDownloadPage?downloadType=Linux&downloadID=7605"
-
-# Colors for output
-RED='\033[0;31m'
-GREEN='\033[0;32m'
-YELLOW='\033[1;33m'
-BLUE='\033[0;34m'
-NC='\033[0m' # No Color
-
-print_info() {
-    echo -e "${GREEN}[INFO]${NC} $1"
-}
-
-print_warn() {
-    echo -e "${YELLOW}[WARN]${NC} $1"
-}
-
-print_error() {
-    echo -e "${RED}[ERROR]${NC} $1"
-}
-
-print_step() {
-    echo -e "${BLUE}[STEP]${NC} $1"
-}
-
-# Detect distribution
-detect_distro() {
-    if [ -f /etc/os-release ]; then
-        . /etc/os-release
-        DISTRO_ID="$ID"
-        DISTRO_LIKE="$ID_LIKE"
-    elif [ -f /etc/redhat-release ]; then
-        DISTRO_ID="rhel"
-    elif [ -f /etc/debian_version ]; then
-        DISTRO_ID="debian"
-    else
-        DISTRO_ID="unknown"
-    fi
-
-    # Determine package manager
-    case "$DISTRO_ID" in
-        ubuntu|debian|raspbian|linuxmint)
-            PKG_MANAGER="apt"
-            PKG_INSTALL="sudo apt install -y"
-            PKG_UPDATE="sudo apt update"
-            HEADERS_PKG="linux-headers-$(uname -r)"
-            IMAGE_PKG="linux-image-$(uname -r)"
-            ;;
-        fedora)
-            PKG_MANAGER="dnf"
-            PKG_INSTALL="sudo dnf install -y"
-            PKG_UPDATE="sudo dnf check-update || true"
-            HEADERS_PKG="kernel-devel-$(uname -r)"
-            IMAGE_PKG="kernel-$(uname -r)"
-            ;;
-        rhel|centos|rocky|almalinux)
-            PKG_MANAGER="dnf"
-            PKG_INSTALL="sudo dnf install -y"
-            PKG_UPDATE="sudo dnf check-update || true"
-            HEADERS_PKG="kernel-devel-$(uname -r)"
-            IMAGE_PKG="kernel-$(uname -r)"
-            ;;
-        arch|manjaro)
-            PKG_MANAGER="pacman"
-            PKG_INSTALL="sudo pacman -S --noconfirm"
-            PKG_UPDATE="sudo pacman -Sy"
-            HEADERS_PKG="linux-headers"
-            IMAGE_PKG=""
-            ;;
-        opensuse*|suse)
-            PKG_MANAGER="zypper"
-            PKG_INSTALL="sudo zypper install -y"
-            PKG_UPDATE="sudo zypper refresh"
-            HEADERS_PKG="kernel-devel"
-            IMAGE_PKG=""
-            ;;
-        *)
-            # Check by available package manager
-            if command -v apt &>/dev/null; then
-                PKG_MANAGER="apt"
-                PKG_INSTALL="sudo apt install -y"
-                PKG_UPDATE="sudo apt update"
-                HEADERS_PKG="linux-headers-$(uname -r)"
-                IMAGE_PKG="linux-image-$(uname -r)"
-            elif command -v dnf &>/dev/null; then
-                PKG_MANAGER="dnf"
-                PKG_INSTALL="sudo dnf install -y"
-                PKG_UPDATE="sudo dnf check-update || true"
-                HEADERS_PKG="kernel-devel-$(uname -r)"
-                IMAGE_PKG="kernel-$(uname -r)"
-            elif command -v yum &>/dev/null; then
-                PKG_MANAGER="yum"
-                PKG_INSTALL="sudo yum install -y"
-                PKG_UPDATE="sudo yum check-update || true"
-                HEADERS_PKG="kernel-devel-$(uname -r)"
-                IMAGE_PKG="kernel-$(uname -r)"
-            else
-                print_error "Unsupported distribution: $DISTRO_ID"
-                exit 1
-            fi
-            ;;
-    esac
-
-    print_info "Detected: $DISTRO_ID (package manager: $PKG_MANAGER)"
-}
-
-# Install build dependencies
-install_dependencies() {
-    print_step "Installing build dependencies..."
-    
-    $PKG_UPDATE
-    
-    case "$PKG_MANAGER" in
-        apt)
-            $PKG_INSTALL build-essential $HEADERS_PKG wget curl
-            [ -n "$IMAGE_PKG" ] && $PKG_INSTALL $IMAGE_PKG 2>/dev/null || true
-            ;;
-        dnf|yum)
-            $PKG_INSTALL gcc make $HEADERS_PKG wget curl elfutils-libelf-devel
-            [ -n "$IMAGE_PKG" ] && $PKG_INSTALL $IMAGE_PKG 2>/dev/null || true
-            ;;
-        pacman)
-            $PKG_INSTALL base-devel $HEADERS_PKG wget curl
-            ;;
-        zypper)
-            $PKG_INSTALL gcc make $HEADERS_PKG wget curl
-            ;;
-    esac
-}
-
-# Download driver from Realtek
-download_driver() {
-    print_step "Downloading r8152 driver from Realtek..."
-    
-    cd "$WORK_DIR"
-    
-    # If archive provided as argument, use it
-    if [ -n "$1" ] && [ -f "$1" ]; then
-        print_info "Using provided archive: $1"
-        cp "$1" .
-        DRIVER_ARCHIVE="$(basename "$1")"
-        return 0
-    fi
-    
-    # Try to download from Realtek
-    # Note: Realtek's website requires accepting a license, so direct download may not work
-    # We'll try common patterns
-    
-    print_info "Attempting to download from Realtek..."
-    print_warn "Realtek requires license acceptance. If download fails, please:"
-    echo "  1. Visit: $REALTEK_PAGE"
-    echo "  2. Download 'RTL8156B(G)/RTL8156BG(S) Linux driver' manually"
-    echo "  3. Run: $0 /path/to/downloaded-file.tar.gz"
-    echo ""
-    
-    # Try wget with common driver filenames
-    DRIVER_URLS=(
-        "https://github.com/wget/r8152/archive/refs/heads/master.zip"
-    )
-    
-    for url in "${DRIVER_URLS[@]}"; do
-        print_info "Trying: $url"
-        if wget -q --show-progress -O driver_download "$url" 2>/dev/null; then
-            # Detect file type
-            FILE_TYPE=$(file -b driver_download | cut -d' ' -f1)
-            case "$FILE_TYPE" in
-                gzip)
-                    mv driver_download r8152-driver.tar.gz
-                    DRIVER_ARCHIVE="r8152-driver.tar.gz"
-                    ;;
-                Zip)
-                    mv driver_download r8152-driver.zip
-                    DRIVER_ARCHIVE="r8152-driver.zip"
-                    ;;
-                *)
-                    rm -f driver_download
-                    continue
-                    ;;
-            esac
-            print_info "Downloaded successfully!"
-            return 0
-        fi
-    done
-    
-    # If we get here, manual download is required
-    print_error "Automatic download failed."
-    print_info "Please download manually from: $REALTEK_PAGE"
-    print_info "Then run: $0 /path/to/r8152-x.xx.x.tar.gz"
-    exit 1
-}
-
-# Extract driver archive
-extract_driver() {
-    print_step "Extracting driver..."
-    
-    cd "$WORK_DIR"
-    
-    case "$DRIVER_ARCHIVE" in
-        *.tar.gz|*.tgz)
-            tar xzf "$DRIVER_ARCHIVE"
-            ;;
-        *.tar.bz2)
-            tar xjf "$DRIVER_ARCHIVE"
-            ;;
-        *.zip)
-            unzip -q "$DRIVER_ARCHIVE"
-            ;;
-        *)
-            print_error "Unknown archive format: $DRIVER_ARCHIVE"
-            exit 1
-            ;;
-    esac
-    
-    # Find the Makefile (driver might extract to subdirectory)
-    MAKEFILE_DIR=$(find . -name "Makefile" -type f -exec grep -l "r8152" {} \; | head -1 | xargs dirname)
-    
-    if [ -z "$MAKEFILE_DIR" ]; then
-        print_error "Could not find r8152 Makefile in extracted archive"
-        exit 1
-    fi
-    
-    cd "$MAKEFILE_DIR"
-    print_info "Driver source found in: $MAKEFILE_DIR"
-}
-
-# Compile and install driver
-compile_install_driver() {
-    print_step "Compiling driver..."
-    
-    # Clean previous builds
-    make clean 2>/dev/null || true
-    
-    # Compile
-    make
-    
-    print_step "Installing driver..."
-    
-    # Unload existing module
-    sudo rmmod r8152 2>/dev/null || true
-    
-    # Install
-    sudo make install
-    
-    # Update module dependencies (critical!)
-    print_step "Updating module dependencies..."
-    sudo depmod -a
-    
-    # Load new module
-    print_step "Loading r8152 module..."
-    sudo modprobe r8152
-}
-
-# Detect network interface
-detect_interface() {
-    print_step "Detecting r8152 network interface..."
-    
-    sleep 3  # Wait for interface to appear
-    
-    # Method 1: Check dmesg for renamed interface
-    INTERFACE=$(dmesg | grep -i "r8152.*renamed" | tail -1 | grep -oP 'enx[a-f0-9]+' 2>/dev/null || true)
-    
-    # Method 2: Check ip link for enx interfaces
-    if [ -z "$INTERFACE" ]; then
-        INTERFACE=$(ip link | grep -oP 'enx[a-f0-9]+' | head -1 || true)
-    fi
-    
-    # Method 3: Check for eth interfaces
-    if [ -z "$INTERFACE" ]; then
-        INTERFACE=$(ip link | grep -oP 'eth[0-9]+' | tail -1 || true)
-    fi
-    
-    # Method 4: Check /sys for r8152 driver
-    if [ -z "$INTERFACE" ]; then
-        for iface in /sys/class/net/*; do
-            if [ -d "$iface/device/driver" ]; then
-                DRIVER=$(basename $(readlink "$iface/device/driver" 2>/dev/null) 2>/dev/null || true)
-                if [ "$DRIVER" = "r8152" ]; then
-                    INTERFACE=$(basename "$iface")
-                    break
-                fi
-            fi
-        done
-    fi
-    
-    if [ -z "$INTERFACE" ]; then
-        print_error "Could not detect r8152 interface"
-        print_info "Available interfaces:"
-        ip link
-        print_info "Driver info:"
-        lsmod | grep r8152 || echo "r8152 module not loaded"
-        exit 1
-    fi
-    
-    print_info "Detected interface: $INTERFACE"
-}
-
-# Configure NetworkManager connection
-configure_network() {
-    print_step "Configuring NetworkManager connection '$CONNECTION_NAME'..."
-    
-    # Check if NetworkManager is running
-    if ! systemctl is-active --quiet NetworkManager; then
-        print_warn "NetworkManager is not running, skipping network configuration"
-        return 0
-    fi
-    
-    if nmcli con show "$CONNECTION_NAME" &>/dev/null; then
-        print_info "Connection '$CONNECTION_NAME' exists, modifying..."
-        sudo nmcli con mod "$CONNECTION_NAME" \
-            connection.interface-name "$INTERFACE" \
-            ipv4.method disabled \
-            ipv6.method link-local \
-            ethernet.mtu "$MTU_SIZE"
-    else
-        print_info "Creating new connection '$CONNECTION_NAME'..."
-        sudo nmcli con add \
-            type ethernet \
-            con-name "$CONNECTION_NAME" \
-            ifname "$INTERFACE" \
-            ipv4.method disabled \
-            ipv6.method link-local \
-            ethernet.mtu "$MTU_SIZE"
-    fi
-    
-    # Restart connection
-    print_info "Restarting connection..."
-    sudo nmcli con down "$CONNECTION_NAME" 2>/dev/null || true
-    sudo nmcli con up "$CONNECTION_NAME"
-}
-
-# Show installation summary
-show_summary() {
-    echo ""
-    echo "=========================================="
-    echo "  r8152 Driver Installation Complete"
-    echo "=========================================="
-    echo ""
-    echo "Distribution: $DISTRO_ID"
-    echo "Interface:    $INTERFACE"
-    echo "Connection:   $CONNECTION_NAME"
-    echo "MTU:          $MTU_SIZE"
-    echo ""
-    echo "=== Driver Info ==="
-    modinfo r8152 | grep -E '^(filename|version|description)' || true
-    echo ""
-    echo "=== Interface Status ==="
-    ip addr show "$INTERFACE" 2>/dev/null || true
-    echo ""
-    echo "=== Connection Status ==="
-    nmcli con show "$CONNECTION_NAME" 2>/dev/null | grep -E '(connection.id|ipv4.method|ipv6.method|ethernet.mtu|GENERAL.STATE)' || true
-    echo ""
-    print_info "Installation successful!"
-}
-
-# Cleanup
-cleanup() {
-    if [ -d "$WORK_DIR" ]; then
-        read -p "Remove working directory $WORK_DIR? [y/N] " -n 1 -r
-        echo
-        if [[ $REPLY =~ ^[Yy]$ ]]; then
-            rm -rf "$WORK_DIR"
-            print_info "Cleaned up working directory"
-        fi
-    fi
-}
-
-# Usage
-usage() {
-    echo "Usage: $0 [OPTIONS] [driver-archive.tar.gz]"
-    echo ""
-    echo "Options:"
-    echo "  -h, --help          Show this help"
-    echo "  -c, --connection    Connection name (default: diretta)"
-    echo "  -m, --mtu           MTU size (default: 16128)"
-    echo "  -n, --no-network    Skip NetworkManager configuration"
-    echo ""
-    echo "Examples:"
-    echo "  $0                              # Download and install"
-    echo "  $0 r8152-2.21.4.tar.gz          # Install from local archive"
-    echo "  $0 -c myconn -m 9000 driver.tar.gz"
-    echo ""
-}
-
-# Parse arguments
-SKIP_NETWORK=false
-DRIVER_FILE=""
-
-while [[ $# -gt 0 ]]; do
-    case $1 in
-        -h|--help)
-            usage
-            exit 0
-            ;;
-        -c|--connection)
-            CONNECTION_NAME="$2"
-            shift 2
-            ;;
-        -m|--mtu)
-            MTU_SIZE="$2"
-            shift 2
-            ;;
-        -n|--no-network)
-            SKIP_NETWORK=true
-            shift
-            ;;
-        *)
-            DRIVER_FILE="$1"
-            shift
-            ;;
-    esac
-done
-
-# Main execution
-main() {
-    echo "=========================================="
-    echo "  r8152 Driver Installer"
-    echo "=========================================="
-    echo ""
-    
-    detect_distro
-    
-    # Create working directory
-    print_step "Creating working directory..."
-    rm -rf "$WORK_DIR"
-    mkdir -p "$WORK_DIR"
-    
-    install_dependencies
-    download_driver "$DRIVER_FILE"
-    extract_driver
-    compile_install_driver
-    detect_interface
-    
-    if [ "$SKIP_NETWORK" = false ]; then
-        configure_network
-    fi
-    
-    show_summary
-    cleanup
-}
-
-# Run
-main
\ No newline at end of file
